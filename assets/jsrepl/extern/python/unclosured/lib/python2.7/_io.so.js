"use strict";
(function(FUNCTION_TABLE_OFFSET) {
  var Module = {};
  var args = [];
  Module.arguments = [];
  var __globalConstructor__ = function globalConstructor() {};
  Runtime.QUANTUM_SIZE = 4;
  var $0___SIZE = 96;
  var $1___SIZE = 16;
  var $2___SIZE = 196;
  var $3___SIZE = 256;
  var $4___SIZE = 16;
  var $5___SIZE = 40;
  var $6___SIZE = 20;
  var $7___SIZE = 20;
  var $8___SIZE = 80;
  var $9___SIZE = 20;
  var $10___SIZE = 208;
  var $11___SIZE = 176;
  var $12___SIZE = 40;
  var $13___SIZE = 288;
  var $14___SIZE = 320;
  var $15___SIZE = 224;
  var $16___SIZE = 196;
  var $17___SIZE = 320;
  var $18___SIZE = 48;
  var $19___SIZE = 32;
  var $20___SIZE = 224;
  var $21___SIZE = 80;
  var $22___SIZE = 80;
  var $23___SIZE = 16;
  var $24___SIZE = 240;
  var $25___SIZE = 80;
  var $26___SIZE = 120;
  var $struct_FILE___SIZE = 148;
  var $struct_FILE___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 70, 71, 72, 76, 84, 88, 92, 96, 100, 104, 108 ];
  var $struct_PyBlockingIOErrorObject___SIZE = 36;
  var $struct_PyBufferProcs___SIZE = 24;
  var $struct_PyByteArrayObject___SIZE = 24;
  var $struct_PyEnvironmentErrorObject___SIZE = 32;
  var $struct_PyGetSetDef___SIZE = 20;
  var $struct_PyIntObject___SIZE = 12;
  var $struct_PyLongObject___SIZE = 0;
  var $struct_PyLongObject___FLATTENER = [];
  var $struct_PyMappingMethods___SIZE = 12;
  var $struct_PyMemberDef___SIZE = 20;
  var $struct_PyMethodDef___SIZE = 16;
  var $struct_PyNumberMethods___SIZE = 156;
  var $struct_PyObject___SIZE = 8;
  var $struct_PySequenceMethods___SIZE = 40;
  var $struct_PyStringObject___SIZE = 24;
  var $struct_PyTupleObject___SIZE = 16;
  var $struct_PyUnicodeObject___SIZE = 24;
  var $struct_Py_buffer___SIZE = 52;
  var $struct_Py_buffer___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48 ];
  var $struct__IO_marker___SIZE = 12;
  var $struct__typeobject___SIZE = 196;
  var $struct_anon___SIZE = 12;
  var $struct_buffered___SIZE = 100;
  var $struct_buffered___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 44, 52, 60, 68, 76, 84, 88, 92, 96 ];
  var $struct_bytesio___SIZE = 32;
  var $struct_cookie_type___SIZE = 24;
  var $struct_cookie_type___FLATTENER = [ 0, 8, 12, 16, 20 ];
  var $struct_encodefuncentry___SIZE = 8;
  var $struct_fileio___SIZE = 24;
  var $struct_iobase___SIZE = 16;
  var $struct_nldecoder_object___SIZE = 20;
  var $struct_rwpair___SIZE = 24;
  var $struct_stat___SIZE = 96;
  var $struct_stat___FLATTENER = [ 0, 8, 12, 16, 20, 24, 28, 32, 40, 44, 52, 56, 64, 72, 80, 88 ];
  var $struct_stringio___SIZE = 48;
  var $struct_stringio___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 25, 26, 27, 28, 32, 36, 40, 44 ];
  var $struct_textio___SIZE = 96;
  var $struct_textio___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 49, 50, 51, 52, 53, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92 ];
  var $struct_timespec___SIZE = 8;
  var $union_PyGC_Head___SIZE = 12;
  var _bufferediobase_doc;
  var __str;
  var __str1;
  var __str2;
  var __str3;
  var _bufferediobase_detach_doc;
  var __str4;
  var _bufferediobase_read_doc;
  var _bufferediobase_read1_doc;
  var __str5;
  var _bufferediobase_write_doc;
  var __str6;
  var __str7;
  var _bufferediobase_methods;
  var __str8;
  var _PyBufferedIOBase_Type;
  var __str9;
  var __str10;
  var ___PRETTY_FUNCTION___8563;
  var __str11;
  var __str12;
  var __str13;
  var __str14;
  var __str15;
  var __str16;
  var _eintr_int_9093;
  var __str17;
  var ___PRETTY_FUNCTION___9098;
  var __str18;
  var __str19;
  var __str20;
  var __str21;
  var __str22;
  var __str23;
  var __str24;
  var __str25;
  var __str26;
  var __str27;
  var __str28;
  var __str29;
  var __str30;
  var __str31;
  var __str32;
  var __str33;
  var __str34;
  var _bufferedreader_doc;
  var __str35;
  var __str36;
  var __str37;
  var __str38;
  var __str39;
  var ___PRETTY_FUNCTION___10369;
  var __str40;
  var __str41;
  var __str42;
  var __str43;
  var __str44;
  var __str45;
  var __str46;
  var __str47;
  var __str48;
  var __str49;
  var __str50;
  var __str51;
  var _bufferedreader_methods;
  var _bufferedreader_members;
  var __str52;
  var _bufferedreader_getset;
  var __str53;
  var _PyBufferedReader_Type;
  var __str54;
  var _bufferedwriter_doc;
  var __str55;
  var __str56;
  var __str57;
  var __str58;
  var __str59;
  var __str60;
  var ___PRETTY_FUNCTION___10762;
  var _bufferedwriter_methods;
  var _bufferedwriter_members;
  var _bufferedwriter_getset;
  var __str61;
  var _PyBufferedWriter_Type;
  var _bufferedrwpair_doc;
  var __str62;
  var __str63;
  var ___PRETTY_FUNCTION___11129;
  var _bufferedrwpair_methods;
  var _bufferedrwpair_getset;
  var __str64;
  var _PyBufferedRWPair_Type;
  var _bufferedrandom_doc;
  var _bufferedrandom_methods;
  var _bufferedrandom_members;
  var _bufferedrandom_getset;
  var __str65;
  var _PyBufferedRandom_Type;
  var __str66;
  var __str167;
  var ___PRETTY_FUNCTION___8438;
  var __str268;
  var __str369;
  var ___PRETTY_FUNCTION___8477;
  var __str470;
  var ___PRETTY_FUNCTION___8514;
  var __str571;
  var _flush_doc;
  var __str672;
  var _getval_doc;
  var _isatty_doc;
  var _tell_doc;
  var _read_doc;
  var __str773;
  var __str874;
  var ___PRETTY_FUNCTION___8642;
  var _read1_doc;
  var _readline_doc;
  var __str975;
  var _readlines_doc;
  var __str1076;
  var _readinto_doc;
  var __str1177;
  var __str1278;
  var ___PRETTY_FUNCTION___8844;
  var _truncate_doc;
  var __str1480;
  var _seek_doc;
  var __str1682;
  var __str1783;
  var __str1884;
  var _write_doc;
  var _writelines_doc;
  var _close_doc;
  var __str1985;
  var __str2086;
  var ___PRETTY_FUNCTION___9134;
  var __str2187;
  var __str2288;
  var __str2389;
  var __str2490;
  var ___PRETTY_FUNCTION___9218;
  var __str2692;
  var ___PRETTY_FUNCTION___9255;
  var __str2793;
  var __str2894;
  var __str3096;
  var _bytesio_getsetlist;
  var __str39105;
  var __str43109;
  var __str45111;
  var __str48114;
  var __str49115;
  var _bytesio_methods;
  var _bytesio_doc;
  var __str50116;
  var _PyBytesIO_Type;
  var __str117;
  var __str1118;
  var __str2119;
  var __str3120;
  var ___PRETTY_FUNCTION___8576;
  var __str4121;
  var __str5122;
  var __str6123;
  var __str7124;
  var ___PRETTY_FUNCTION___8670;
  var __str8125;
  var _kwlist_8657;
  var __str9126;
  var __str11128;
  var __str12129;
  var __str13130;
  var __str14131;
  var __str15132;
  var __str16133;
  var __str17134;
  var __str19136;
  var ___PRETTY_FUNCTION___8879;
  var __str20137;
  var __str21138;
  var __str22139;
  var __str23140;
  var __str24141;
  var __str25142;
  var __str26143;
  var __str27144;
  var __str28145;
  var __str29146;
  var __str30147;
  var __str31148;
  var __str32149;
  var __str33150;
  var __str34151;
  var __str35152;
  var __str36153;
  var _fileio_doc;
  var _read_doc154;
  var _readall_doc;
  var _write_doc155;
  var _fileno_doc;
  var _seek_doc156;
  var _truncate_doc157;
  var _tell_doc158;
  var _readinto_doc159;
  var _close_doc160;
  var _isatty_doc161;
  var _seekable_doc;
  var _readable_doc;
  var _writable_doc;
  var __str37162;
  var __str38163;
  var __str39164;
  var __str40165;
  var __str41166;
  var __str42167;
  var __str43168;
  var __str44169;
  var __str45170;
  var __str46171;
  var __str48173;
  var _fileio_methods;
  var __str49174;
  var __str50175;
  var __str51176;
  var __str52177;
  var _fileio_getsetlist;
  var __str53178;
  var _PyFileIO_Type;
  var _iobase_doc;
  var _iobase_seek_doc;
  var __str181;
  var _iobase_tell_doc;
  var __str1182;
  var _iobase_truncate_doc;
  var __str2183;
  var _iobase_flush_doc;
  var __str3184;
  var __str4185;
  var _iobase_close_doc;
  var __str5186;
  var __str6187;
  var ___PRETTY_FUNCTION___8634;
  var _iobase_seekable_doc;
  var __str7188;
  var _iobase_readable_doc;
  var __str8189;
  var _iobase_writable_doc;
  var __str9190;
  var _iobase_fileno_doc;
  var __str10191;
  var _iobase_isatty_doc;
  var _iobase_readline_doc;
  var __str13194;
  var __str14195;
  var __str15196;
  var __str17198;
  var __str18199;
  var ___PRETTY_FUNCTION___8875;
  var _iobase_readlines_doc;
  var __str19200;
  var __str20201;
  var __str21202;
  var __str22203;
  var __str23204;
  var __str24205;
  var __str25206;
  var __str26207;
  var __str27208;
  var __str28209;
  var __str29210;
  var __str30211;
  var __str31212;
  var __str32213;
  var __str33214;
  var __str34215;
  var __str35216;
  var __str36217;
  var __str37218;
  var __str38219;
  var _iobase_methods;
  var __str39220;
  var _iobase_getset;
  var __str40221;
  var _PyIOBase_Type;
  var _rawiobase_doc;
  var __str41223;
  var __str42224;
  var _rawiobase_readall_doc;
  var _rawiobase_methods;
  var __str44226;
  var _PyRawIOBase_Type;
  var _module_doc;
  var __str232;
  var __str1233;
  var ___PRETTY_FUNCTION___8454;
  var __str2234;
  var __str3235;
  var _blockingioerror_members;
  var __str4236;
  var __str5237;
  var __PyExc_BlockingIOError;
  var _PyExc_BlockingIOError;
  var _open_doc;
  var __str6239;
  var __str7240;
  var __str8241;
  var __str9242;
  var __str10243;
  var __str11244;
  var __str12245;
  var __str13246;
  var __str14247;
  var __str15248;
  var __str16249;
  var __str17250;
  var __str18251;
  var __str19252;
  var __str20253;
  var __str21254;
  var __str22255;
  var __str23256;
  var __str24257;
  var __str25258;
  var __str26259;
  var __str27260;
  var __str28261;
  var __str29262;
  var __str30263;
  var __str31264;
  var ___PRETTY_FUNCTION___8811;
  var __str32265;
  var __str33266;
  var __PyIO_os_module;
  var __PyIO_locale_module;
  var __PyIO_unsupported_operation;
  var __str34268;
  var _module_methods;
  var __str35269;
  var __str36270;
  var __str37271;
  var __str38272;
  var __str39273;
  var __str40274;
  var __str41275;
  var __str42276;
  var __str43277;
  var __str44278;
  var __str45279;
  var __str46280;
  var __str47281;
  var __str48282;
  var __str49283;
  var __str50284;
  var __str51285;
  var __str52286;
  var __str53287;
  var __PyIO_str_close;
  var __str54289;
  var __PyIO_str_closed;
  var __str55291;
  var __PyIO_str_decode;
  var __str56292;
  var __PyIO_str_encode;
  var __PyIO_str_fileno;
  var __str57294;
  var __PyIO_str_flush;
  var __str58296;
  var __PyIO_str_getstate;
  var __PyIO_str_isatty;
  var __str59298;
  var __PyIO_str_newlines;
  var __str60299;
  var __PyIO_str_nl;
  var __str61300;
  var __PyIO_str_read;
  var __str62302;
  var __PyIO_str_read1;
  var __str63303;
  var __PyIO_str_readable;
  var __str64305;
  var __PyIO_str_readinto;
  var __str65307;
  var __PyIO_str_readline;
  var __str66309;
  var __PyIO_str_reset;
  var __str67;
  var __PyIO_str_seek;
  var __str68;
  var __PyIO_str_seekable;
  var __str69;
  var __PyIO_str_setstate;
  var __str70;
  var __PyIO_str_tell;
  var __str71;
  var __PyIO_str_truncate;
  var __str72;
  var __PyIO_str_write;
  var __str73;
  var __PyIO_str_writable;
  var __PyIO_empty_str;
  var __PyIO_empty_bytes;
  var __PyIO_zero;
  var _stringio_doc;
  var __str319;
  var __str1320;
  var ___PRETTY_FUNCTION___8442;
  var __str2321;
  var ___PRETTY_FUNCTION___8484;
  var __str3322;
  var __str4323;
  var __str5324;
  var __str6325;
  var _stringio_getvalue_doc;
  var __str8327;
  var _stringio_tell_doc;
  var _stringio_read_doc;
  var __str9328;
  var __str10329;
  var __str11330;
  var _stringio_readline_doc;
  var __str12331;
  var __str13332;
  var _stringio_truncate_doc;
  var __str14333;
  var __str15334;
  var _stringio_seek_doc;
  var __str16335;
  var __str17336;
  var __str18337;
  var __str19338;
  var _stringio_write_doc;
  var __str20339;
  var _stringio_close_doc;
  var __str21340;
  var ___PRETTY_FUNCTION___9021;
  var __str22341;
  var ___PRETTY_FUNCTION___9091;
  var __str23342;
  var __str24343;
  var __str25344;
  var __str26345;
  var __str27346;
  var __str28347;
  var __str29348;
  var __str30349;
  var __str31350;
  var ___PRETTY_FUNCTION___9352;
  var __str32351;
  var __str33352;
  var __str34353;
  var __str35354;
  var __str36355;
  var __str37356;
  var __str38357;
  var __str39358;
  var __str40359;
  var __str41360;
  var __str42361;
  var __str43362;
  var __str44363;
  var __str45364;
  var __str46365;
  var __str47366;
  var __str48367;
  var _stringio_methods;
  var __str49368;
  var __str50369;
  var __str51370;
  var _stringio_getset;
  var __str52371;
  var _PyStringIO_Type;
  var _textiobase_doc;
  var _textiobase_detach_doc;
  var _textiobase_read_doc;
  var __str1375;
  var _textiobase_readline_doc;
  var __str2376;
  var _textiobase_write_doc;
  var __str3377;
  var _textiobase_encoding_doc;
  var _textiobase_newlines_doc;
  var _textiobase_errors_doc;
  var _textiobase_methods;
  var __str4378;
  var __str5379;
  var __str6380;
  var _textiobase_getset;
  var __str7381;
  var _PyTextIOBase_Type;
  var _incrementalnewlinedecoder_doc;
  var __str8383;
  var __str9384;
  var __str10385;
  var __str11386;
  var __str12387;
  var __str13388;
  var __str14389;
  var __str15390;
  var ___PRETTY_FUNCTION___8596;
  var __str16391;
  var __str17392;
  var __str18393;
  var __str19394;
  var __str20395;
  var __str21396;
  var __str22397;
  var __str23398;
  var __str24399;
  var __str25400;
  var __str26401;
  var __str27402;
  var __str28403;
  var __str29404;
  var __str30405;
  var __str31406;
  var _incrementalnewlinedecoder_methods;
  var _incrementalnewlinedecoder_getset;
  var __str32407;
  var _PyIncrementalNewlineDecoder_Type;
  var _textiowrapper_doc;
  var _encodefuncs;
  var __str33409;
  var __str34410;
  var __str35411;
  var __str36412;
  var __str37413;
  var __str38414;
  var __str39415;
  var __str40416;
  var __str41417;
  var __str42418;
  var __str43419;
  var __str44420;
  var __str45421;
  var __str46422;
  var __str47423;
  var __str48424;
  var __str49425;
  var __str50426;
  var __str51427;
  var __str52428;
  var __str53429;
  var __str55431;
  var __str56432;
  var ___PRETTY_FUNCTION___9695;
  var __str57433;
  var __str58434;
  var __str59435;
  var __str60436;
  var __str61437;
  var __str62438;
  var __str63439;
  var ___PRETTY_FUNCTION___10189;
  var __str64440;
  var __str65441;
  var __str66442;
  var ___PRETTY_FUNCTION___10233;
  var __str67443;
  var __str68444;
  var __str70446;
  var ___PRETTY_FUNCTION___10735;
  var __str71447;
  var __str72448;
  var __str73449;
  var __str74;
  var __str75;
  var __str76;
  var __str77;
  var __str78;
  var __str79;
  var __str80;
  var __str81;
  var __str82;
  var __str83;
  var __str84;
  var ___PRETTY_FUNCTION___11188;
  var __str85;
  var __str86;
  var __str87;
  var __str88;
  var __str89;
  var ___PRETTY_FUNCTION___11475;
  var __str90;
  var __str91;
  var __str92;
  var __str93;
  var __str94;
  var __str95;
  var __str96;
  var __str97;
  var __str98;
  var __str99;
  var __str100;
  var __str101;
  var __str102;
  var __str103;
  var __str104;
  var __str105;
  var _textiowrapper_methods;
  var _textiowrapper_members;
  var __str106;
  var __str107;
  var _textiowrapper_getset;
  var __str108;
  var _PyTextIOWrapper_Type;
  function _bufferediobase_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $buf = __stackBase__;
      var $len;
      var $data;
      $self_addr = $self;
      $args_addr = $args;
      
      var $2 = __PyArg_ParseTuple_SizeT($args_addr, __str, allocate([ $buf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 11;
      break;
     case 2:
      
      var $5 = HEAP[$buf + 8];
      
      var $7 = __PyObject_CallMethod_SizeT($self_addr, __str1, __str2, allocate([ $5, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $data = $7;
      
      
      if ($data == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      var $17 = $data;
      if ((HEAP[HEAP[$data + 4] + 84] & 134217728) == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 4:
      
      
      var $20 = HEAP[$17] - 1;
      
      
      HEAP[$data] = $20;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $31 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$31]($data);
      __label__ = 6;
      break;
     case 6:
      var $33 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($33, __str3);
      __label__ = 10;
      break;
     case 7:
      
      
      
      $len = HEAP[$17 + 8];
      
      
      
      
      
      
      var $43 = HEAP[$buf];
      _llvm_memcpy_p0i8_p0i8_i32($43, $data + 20, $len, 1, 0);
      _PyBuffer_Release($buf);
      
      
      
      var $47 = HEAP[$data] - 1;
      
      
      HEAP[$data] = $47;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $58 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$58]($data);
      __label__ = 9;
      break;
     case 9:
      
      var $61 = _PyLong_FromSsize_t($len);
      $0 = $61;
      __label__ = 11;
      break;
     case 10:
      _PyBuffer_Release($buf);
      $0 = 0;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval10 = $retval;
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferediobase_unsupported($message) {
    
    var $message_addr;
    var $retval;
    var $0;
    $message_addr = $message;
    var $1 = HEAP[__PyIO_unsupported_operation];
    
    _PyErr_SetString($1, $message_addr);
    $0 = 0;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferediobase_detach($self) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    var $1 = _bufferediobase_unsupported(__str4);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferediobase_read($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = _bufferediobase_unsupported(__str1);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferediobase_read1($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = _bufferediobase_unsupported(__str5);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferediobase_write($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = _bufferediobase_unsupported(__str6);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _buffered_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $g;
      var $_py_tmp;
      var $_py_tmp12;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      var $6 = __PyIOBase_finalize($self_addr);
      
      if ($6 < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      var $10 = $self_addr + -12;
      $g = $10;
      
      
      
      
      var $15 = HEAP[$g + 8] == -2;
      if ($15) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str9, __str10, 370, ___PRETTY_FUNCTION___8563);
      throw "Reached an unreachable!";
     case 4:
      
      
      
      HEAP[$g + 8] = -2;
      
      
      
      
      
      
      
      var $26 = HEAP[$g];
      
      var $28 = HEAP[$g + 4];
      HEAP[$28] = $26;
      
      
      
      
      
      
      
      var $36 = HEAP[$g + 4];
      
      var $38 = HEAP[$g] + 4;
      HEAP[$38] = $36;
      
      
      
      HEAP[$g] = 0;
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      
      
      if (HEAP[$self_addr + 96] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      _PyObject_ClearWeakRefs($self_addr);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $62 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $62;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $73 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$73]($_py_tmp);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      var $81 = HEAP[$self_addr + 40];
      _PyMem_Free($81);
      
      
      HEAP[$self_addr + 40] = 0;
      __label__ = 11;
      break;
     case 11:
      
      
      
      
      if (HEAP[$self_addr + 92] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 12:
      
      
      
      $_py_tmp12 = HEAP[$self_addr + 92];
      
      
      HEAP[$self_addr + 92] = 0;
      
      
      
      var $96 = HEAP[$_py_tmp12] - 1;
      
      
      HEAP[$_py_tmp12] = $96;
      
      
      
      
      if (HEAP[$_py_tmp12] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $107 = HEAP[HEAP[$_py_tmp12 + 4] + 24];
      
      FUNCTION_TABLE[$107]($_py_tmp12);
      __label__ = 14;
      break;
     case 14:
      
      
      
      
      
      var $114 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$114]($self_addr);
      __label__ = 15;
      break;
     case 15:
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_traverse($self, $visit, $arg) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $visit_addr;
      var $arg_addr;
      var $retval;
      var $0;
      var $vret;
      var $vret4;
      $self_addr = $self;
      $visit_addr = $visit;
      $arg_addr = $arg;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 8];
      var $8 = $visit_addr;
      
      var $10 = FUNCTION_TABLE[$8]($7, $arg_addr);
      $vret = $10;
      
      
      if ($vret != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      $0 = $vret;
      __label__ = 7;
      break;
     case 3:
      
      
      
      
      if (HEAP[$self_addr + 92] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      var $20 = HEAP[$self_addr + 92];
      var $21 = $visit_addr;
      
      var $23 = FUNCTION_TABLE[$21]($20, $arg_addr);
      $vret4 = $23;
      
      
      if ($vret4 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      $0 = $vret4;
      __label__ = 7;
      break;
     case 6:
      $0 = 0;
      __label__ = 7;
      break;
     case 7:
      
      $retval = $0;
      var $retval8 = $retval;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      var $_py_tmp7;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = __PyIOBase_finalize($self_addr);
      
      if ($7 < 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      $0 = -1;
      __label__ = 10;
      break;
     case 3:
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $23 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $23;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $34 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$34]($_py_tmp);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[$self_addr + 92] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      $_py_tmp7 = HEAP[$self_addr + 92];
      
      
      HEAP[$self_addr + 92] = 0;
      
      
      
      var $48 = HEAP[$_py_tmp7] - 1;
      
      
      HEAP[$_py_tmp7] = $48;
      
      
      
      
      if (HEAP[$_py_tmp7] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $59 = HEAP[HEAP[$_py_tmp7 + 4] + 24];
      
      FUNCTION_TABLE[$59]($_py_tmp7);
      __label__ = 9;
      break;
     case 9:
      $0 = 0;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval11 = $retval;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_simple_flush($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_flush];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_closed($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $closed;
      var $res;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = -1;
      __label__ = 10;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_closed];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_GetAttr($13, $10);
      $res = $14;
      
      
      if ($res == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = -1;
      __label__ = 10;
      break;
     case 7:
      
      var $18 = _PyObject_IsTrue($res);
      $closed = $18;
      
      
      
      var $22 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $22;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $33 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$33]($res);
      __label__ = 9;
      break;
     case 9:
      
      $0 = $closed;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_closed_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_closed];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_GetAttr($13, $10);
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_close($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      var $r;
      $self_addr = $self;
      $args_addr = $args;
      $res = 0;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 14;
      break;
     case 5:
      var $10 = _buffered_closed($5);
      $r = $10;
      
      
      if ($r < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      if ($r > 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      $res = __Py_NoneStruct;
      
      
      
      var $18 = HEAP[$res] + 1;
      
      
      HEAP[$res] = $18;
      __label__ = 13;
      break;
     case 8:
      var $21 = HEAP[__PyIO_str_flush];
      
      
      var $24 = _PyObject_CallMethodObjArgs($self_addr, $21, allocate(4, "i8*", ALLOC_STACK));
      $res = $24;
      
      
      if ($res == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      if ($res != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      
      
      var $32 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $32;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $43 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$43]($res);
      __label__ = 12;
      break;
     case 12:
      var $45 = HEAP[__PyIO_str_close];
      
      
      var $48 = HEAP[$self_addr + 8];
      var $49 = _PyObject_CallMethodObjArgs($48, $45, allocate(4, "i8*", ALLOC_STACK));
      $res = $49;
      __label__ = 13;
      break;
     case 13:
      
      $0 = $res;
      __label__ = 14;
      break;
     case 14:
      
      $retval = $0;
      var $retval13 = $retval;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_detach($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $raw;
      var $res;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 10;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_flush];
      
      
      var $13 = _PyObject_CallMethodObjArgs($self_addr, $10, allocate(4, "i8*", ALLOC_STACK));
      $res = $13;
      
      
      if ($res == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 10;
      break;
     case 7:
      
      
      
      var $19 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $19;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $30 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$30]($res);
      __label__ = 9;
      break;
     case 9:
      
      
      
      $raw = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      HEAP[$self_addr + 16] = 1;
      
      
      HEAP[$self_addr + 12] = 0;
      
      $0 = $raw;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_seekable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_seekable];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_readable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_readable];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_writable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_writable];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_name_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 8];
      var $12 = _PyObject_GetAttrString($11, __str13);
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_mode_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 8];
      var $12 = _PyObject_GetAttrString($11, __str14);
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_fileno($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_fileno];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_isatty($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_isatty];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_check_blocking_error() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $retval;
      var $0;
      var $t = __stackBase__;
      var $v = __stackBase__ + 4;
      var $tb = __stackBase__ + 8;
      var $err;
      _PyErr_Fetch($t, $v, $tb);
      
      
      if (HEAP[$v] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      var $3 = HEAP[_PyExc_BlockingIOError];
      var $4 = HEAP[$v];
      var $5 = _PyErr_GivenExceptionMatches($4, $3);
      
      if ($5 == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $7 = HEAP[$tb];
      var $8 = HEAP[$v];
      var $9 = HEAP[$t];
      _PyErr_Restore($9, $8, $7);
      $0 = 0;
      __label__ = 4;
      break;
     case 3:
      
      
      $err = HEAP[$v];
      var $12 = HEAP[$tb];
      var $13 = HEAP[$v];
      var $14 = HEAP[$t];
      _PyErr_Restore($14, $13, $12);
      
      
      $0 = $err + 32;
      __label__ = 4;
      break;
     case 4:
      
      $retval = $0;
      var $retval4 = $retval;
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_raw_tell($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $n;
      var $res;
      $self_addr = $self;
      var $1 = HEAP[__PyIO_str_tell];
      
      
      var $4 = HEAP[$self_addr + 8];
      var $5 = _PyObject_CallMethodObjArgs($4, $1, allocate(4, "i8*", ALLOC_STACK));
      $res = $5;
      
      
      if ($res == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 9;
      break;
     case 2:
      var $8 = HEAP[_PyExc_ValueError];
      
      var $10 = _PyNumber_AsOff_t($res, $8);
      $n = $10;
      
      
      
      var $14 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $14;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $25 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$25]($res);
      __label__ = 4;
      break;
     case 4:
      
      
      if ($n < 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      var $29 = _PyErr_Occurred();
      
      if ($29 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      var $31 = HEAP[_PyExc_IOError];
      
      var $33 = _PyErr_Format($31, __str15, allocate([ $n, 0, 0, 0, 0, 0, 0, 0 ], [ "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      __label__ = 7;
      break;
     case 7:
      $0 = -1;
      __label__ = 9;
      break;
     case 8:
      
      
      
      HEAP[$self_addr + 32] = $n;
      
      $0 = $n;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_raw_seek($self, $target, $whence) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $target_addr;
      var $whence_addr;
      var $retval;
      var $0;
      var $res;
      var $posobj;
      var $whenceobj;
      var $n;
      $self_addr = $self;
      $target_addr = $target;
      $whence_addr = $whence;
      
      var $2 = _PyLong_FromLongLong($target_addr);
      $posobj = $2;
      
      
      if ($posobj == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 19;
      break;
     case 2:
      
      var $6 = _PyLong_FromLong($whence_addr);
      $whenceobj = $6;
      
      
      if ($whenceobj == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      
      
      
      var $12 = HEAP[$posobj] - 1;
      
      
      HEAP[$posobj] = $12;
      
      
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $23 = HEAP[HEAP[$posobj + 4] + 24];
      
      FUNCTION_TABLE[$23]($posobj);
      __label__ = 5;
      break;
     case 5:
      $0 = -1;
      __label__ = 19;
      break;
     case 6:
      var $25 = HEAP[__PyIO_str_seek];
      
      
      var $28 = HEAP[$self_addr + 8];
      
      
      var $31 = _PyObject_CallMethodObjArgs($28, $25, allocate([ $posobj, 0, 0, 0, $whenceobj, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $31;
      
      
      
      var $35 = HEAP[$posobj] - 1;
      
      
      HEAP[$posobj] = $35;
      
      
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $46 = HEAP[HEAP[$posobj + 4] + 24];
      
      FUNCTION_TABLE[$46]($posobj);
      __label__ = 8;
      break;
     case 8:
      
      
      
      var $51 = HEAP[$whenceobj] - 1;
      
      
      HEAP[$whenceobj] = $51;
      
      
      
      
      if (HEAP[$whenceobj] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $62 = HEAP[HEAP[$whenceobj + 4] + 24];
      
      FUNCTION_TABLE[$62]($whenceobj);
      __label__ = 10;
      break;
     case 10:
      
      
      if ($res == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      $0 = -1;
      __label__ = 19;
      break;
     case 12:
      var $66 = HEAP[_PyExc_ValueError];
      
      var $68 = _PyNumber_AsOff_t($res, $66);
      $n = $68;
      
      
      
      var $72 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $72;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $83 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$83]($res);
      __label__ = 14;
      break;
     case 14:
      
      
      if ($n < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      var $87 = _PyErr_Occurred();
      
      if ($87 == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      var $89 = HEAP[_PyExc_IOError];
      
      var $91 = _PyErr_Format($89, __str15, allocate([ $n, 0, 0, 0, 0, 0, 0, 0 ], [ "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      __label__ = 17;
      break;
     case 17:
      $0 = -1;
      __label__ = 19;
      break;
     case 18:
      
      
      
      HEAP[$self_addr + 32] = $n;
      
      $0 = $n;
      __label__ = 19;
      break;
     case 19:
      
      $retval = $0;
      var $retval19 = $retval;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_init($self) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $n;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 84] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str16);
      $0 = -1;
      __label__ = 15;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      var $12 = HEAP[$self_addr + 40];
      _PyMem_Free($12);
      __label__ = 4;
      break;
     case 4:
      
      
      var $15 = HEAP[$self_addr + 84];
      var $16 = _PyMem_Malloc($15);
      
      
      HEAP[$self_addr + 40] = $16;
      
      
      
      
      if (HEAP[$self_addr + 40] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $23 = _PyErr_NoMemory();
      $0 = -1;
      __label__ = 15;
      break;
     case 6:
      
      
      
      var $27 = HEAP[$self_addr + 84] - 1;
      $n = $27;
      
      
      
      if (($27 & 1 & 255) != 0) {
        __lastLabel__ = 6;
        __label__ = 7;
        break;
      } else {
        __lastLabel__ = 6;
        __label__ = 9;
        break;
      }
     case 7:
      var $30 = __lastLabel__ == 7 ? $31 : $27;
      var $31 = $30 >> 1;
      
      
      
      if (($31 & 1 & 255) != 0) {
        __lastLabel__ = 7;
        __label__ = 7;
        break;
      } else {
        __lastLabel__ = 7;
        __label__ = 8;
        break;
      }
     case 8:
      $n = $31;
      __lastLabel__ = 8;
      __label__ = 9;
      break;
     case 9:
      var $_lcssa = __lastLabel__ == 8 ? $31 : $27;
      
      var $35 = $self_addr;
      if ($_lcssa == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      var $38 = HEAP[$35 + 84] - 1;
      
      
      HEAP[$self_addr + 88] = $38;
      __label__ = 12;
      break;
     case 11:
      
      HEAP[$35 + 88] = 0;
      __label__ = 12;
      break;
     case 12:
      
      var $43 = __buffered_raw_tell($self_addr);
      var $44 = $43 == -1;
      if ($44) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      _PyErr_Clear();
      __label__ = 14;
      break;
     case 14:
      $0 = 0;
      __label__ = 15;
      break;
     case 15:
      
      $retval = $0;
      var $retval15 = $retval;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __trap_eintr() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $retval;
      var $0;
      var $typ = __stackBase__;
      var $val = __stackBase__ + 4;
      var $tb = __stackBase__ + 8;
      var $env_err;
      
      
      if (HEAP[_eintr_int_9093] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      var $3 = _PyLong_FromLong(4);
      HEAP[_eintr_int_9093] = $3;
      
      
      if (HEAP[_eintr_int_9093] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str17, __str10, 699, ___PRETTY_FUNCTION___9098);
      throw "Reached an unreachable!";
     case 3:
      var $6 = HEAP[_PyExc_EnvironmentError];
      var $7 = _PyErr_ExceptionMatches($6);
      
      if ($7 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = 0;
      __label__ = 18;
      break;
     case 5:
      _PyErr_Fetch($typ, $val, $tb);
      _PyErr_NormalizeException($typ, $val, $tb);
      
      
      $env_err = HEAP[$val];
      
      
      if ($env_err == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      ___assert_fail(__str18, __str10, 706, ___PRETTY_FUNCTION___9098);
      throw "Reached an unreachable!";
     case 7:
      
      
      
      
      if (HEAP[$env_err + 20] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 8:
      var $17 = HEAP[_eintr_int_9093];
      
      
      var $20 = HEAP[$env_err + 20];
      var $21 = _PyObject_RichCompareBool($20, $17, 2);
      
      if ($21 > 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 9:
      var $23 = HEAP[$typ];
      
      
      var $26 = HEAP[$23] - 1;
      var $27 = $23;
      HEAP[$27] = $26;
      
      
      
      if (HEAP[$23] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $35 = HEAP[HEAP[HEAP[$typ] + 4] + 24];
      var $36 = HEAP[$typ];
      FUNCTION_TABLE[$35]($36);
      __label__ = 11;
      break;
     case 11:
      var $37 = HEAP[$val];
      
      
      var $40 = HEAP[$37] - 1;
      var $41 = $37;
      HEAP[$41] = $40;
      
      
      
      if (HEAP[$37] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $49 = HEAP[HEAP[HEAP[$val] + 4] + 24];
      var $50 = HEAP[$val];
      FUNCTION_TABLE[$49]($50);
      __label__ = 13;
      break;
     case 13:
      
      
      if (HEAP[$tb] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      var $53 = HEAP[$tb];
      
      
      var $56 = HEAP[$53] - 1;
      var $57 = $53;
      HEAP[$57] = $56;
      
      
      
      if (HEAP[$53] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $65 = HEAP[HEAP[HEAP[$tb] + 4] + 24];
      var $66 = HEAP[$tb];
      FUNCTION_TABLE[$65]($66);
      __label__ = 16;
      break;
     case 16:
      $0 = 1;
      __label__ = 18;
      break;
     case 17:
      var $67 = HEAP[$tb];
      var $68 = HEAP[$val];
      var $69 = HEAP[$typ];
      _PyErr_Restore($69, $68, $67);
      $0 = 0;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval18 = $retval;
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_flush($self, $args) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_86;
      var $iftmp_84;
      var $0;
      var $res;
      var $n;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 25;
      break;
     case 5:
      
      
      
      var $13 = $self_addr;
      if (HEAP[$5 + 28] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      var $15 = HEAP[$13 + 8];
      var $16 = __PyFileIO_closed($15);
      
      var $18 = $16 != 0;
      $iftmp_84 = $18;
      __lastLabel__ = 6;
      __label__ = 8;
      break;
     case 7:
      var $19 = _buffered_closed($13);
      
      var $21 = $19 != 0;
      $iftmp_84 = $21;
      __lastLabel__ = 7;
      __label__ = 8;
      break;
     case 8:
      var $22 = __lastLabel__ == 7 ? $21 : $18;
      
      if ($22 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      var $23 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($23, __str19);
      $0 = 0;
      __label__ = 25;
      break;
     case 10:
      
      var $25 = __bufferedwriter_flush_unlocked($self_addr, 0);
      $res = $25;
      
      
      if ($res != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 11:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 12:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      var $39 = HEAP[$self_addr + 60] != -1;
      if ($39) {
        __label__ = 16;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      var $47 = HEAP[$self_addr + 76] != -1;
      if ($47) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      
      
      if (HEAP[$self_addr + 52] < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      
      
      
      $iftmp_86 = HEAP[$self_addr + 44] - HEAP[$self_addr + 52];
      __label__ = 19;
      break;
     case 18:
      $iftmp_86 = 0;
      __label__ = 19;
      break;
     case 19:
      
      
      var $61 = __buffered_raw_seek($self_addr, $iftmp_86, 1);
      $n = $61;
      var $62 = $61 == -1;
      if ($62) {
        __label__ = 20;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 20:
      
      
      if ($res != 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 21:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $69 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $69;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      var $80 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$80]($_py_tmp);
      __label__ = 23;
      break;
     case 23:
      
      __bufferedreader_reset_buf($self_addr);
      __label__ = 24;
      break;
     case 24:
      
      $0 = $res;
      __label__ = 25;
      break;
     case 25:
      
      $retval = $0;
      var $retval25 = $retval;
      return $retval25;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_peek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $n = __stackBase__;
      var $res;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$n] = 0;
      $res = 0;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 14;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str20, allocate([ $n, 0, 0, 0 ], [ "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 14;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      var $18 = __bufferedwriter_flush_unlocked($self_addr, 1);
      $res = $18;
      
      
      if ($res == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      if ($res != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $27 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $27;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $38 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$38]($_py_tmp);
      __label__ = 12;
      break;
     case 12:
      var $40 = HEAP[$n];
      
      var $42 = __bufferedreader_peek_unlocked($self_addr, $40);
      $res = $42;
      __label__ = 13;
      break;
     case 13:
      
      $0 = $res;
      __label__ = 14;
      break;
     case 14:
      
      $retval = $0;
      var $retval13 = $retval;
      STACKTOP = __stackBase__;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_94;
      var $0;
      var $n = __stackBase__;
      var $res;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$n] = -1;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 21;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str21, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $n, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 21;
      break;
     case 7:
      
      var $14 = HEAP[$n] < -1;
      if ($14) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $15 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($15, __str22);
      $0 = 0;
      __label__ = 21;
      break;
     case 9:
      
      
      
      
      var $20 = $self_addr;
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      var $22 = HEAP[$20 + 8];
      var $23 = __PyFileIO_closed($22);
      
      var $25 = $23 != 0;
      $iftmp_94 = $25;
      __lastLabel__ = 10;
      __label__ = 12;
      break;
     case 11:
      var $26 = _buffered_closed($20);
      
      var $28 = $26 != 0;
      $iftmp_94 = $28;
      __lastLabel__ = 11;
      __label__ = 12;
      break;
     case 12:
      var $29 = __lastLabel__ == 11 ? $28 : $25;
      
      if ($29 != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      var $30 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($30, __str23);
      $0 = 0;
      __label__ = 21;
      break;
     case 14:
      
      var $32 = HEAP[$n] == -1;
      if ($32) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      var $34 = __bufferedreader_read_all($self_addr);
      $res = $34;
      __label__ = 20;
      break;
     case 16:
      var $35 = HEAP[$n];
      
      var $37 = __bufferedreader_read_fast($self_addr, $35);
      $res = $37;
      
      
      if ($res == __Py_NoneStruct) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      
      
      
      var $43 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $43;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $54 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$54]($res);
      __label__ = 19;
      break;
     case 19:
      var $56 = HEAP[$n];
      
      var $58 = __bufferedreader_read_generic($self_addr, $56);
      $res = $58;
      __label__ = 20;
      break;
     case 20:
      
      $0 = $res;
      __label__ = 21;
      break;
     case 21:
      
      $retval = $0;
      var $retval21 = $retval;
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_read1($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_104;
      var $0;
      var $n = __stackBase__;
      var $have;
      var $r;
      var $res;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      $res = 0;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 33;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str24, allocate([ $n, 0, 0, 0 ], [ "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 33;
      break;
     case 7:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $15 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($15, __str25);
      $0 = 0;
      __label__ = 33;
      break;
     case 9:
      
      
      if (HEAP[$n] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      var $18 = _PyString_FromStringAndSize(0, 0);
      $0 = $18;
      __label__ = 33;
      break;
     case 11:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 12:
      
      var $24 = __bufferedwriter_flush_unlocked($self_addr, 1);
      $res = $24;
      
      
      if ($res == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      if ($res != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $33 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $33;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $44 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$44]($_py_tmp);
      __label__ = 16;
      break;
     case 16:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      
      var $57 = HEAP[$self_addr + 60] == -1;
      if ($57) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      $iftmp_104 = 0;
      $have = 0;
      __label__ = 25;
      break;
     case 20:
      
      
      
      
      
      
      
      
      
      $iftmp_104 = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      $have = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      
      if ((HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295) > 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 21:
      
      
      
      if (HEAP[$n] > $have) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      HEAP[$n] = $have;
      __label__ = 23;
      break;
     case 23:
      var $72 = HEAP[$n];
      
      
      
      
      
      
      
      var $80 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      var $81 = _PyString_FromStringAndSize($80, $72);
      $res = $81;
      
      if ($81 == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      
      
      
      
      var $88 = HEAP[$n] + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $88;
      __label__ = 32;
      break;
     case 25:
      
      __bufferedreader_reset_buf($self_addr);
      
      var $93 = __bufferedreader_fill_buffer($self_addr);
      $r = $93;
      var $94 = $93 == -1;
      if ($94) {
        __label__ = 32;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      var $96 = $r == -2;
      if ($96) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      $r = 0;
      __label__ = 28;
      break;
     case 28:
      
      
      
      if (HEAP[$n] > $r) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      HEAP[$n] = $r;
      __label__ = 30;
      break;
     case 30:
      var $101 = HEAP[$n];
      
      
      var $104 = HEAP[$self_addr + 40];
      var $105 = _PyString_FromStringAndSize($104, $101);
      $res = $105;
      
      if ($105 == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      var $108 = HEAP[$n];
      
      
      HEAP[$self_addr + 44] = $108;
      __label__ = 32;
      break;
     case 32:
      
      $0 = $res;
      __label__ = 33;
      break;
     case 33:
      
      $retval = $0;
      var $retval33 = $retval;
      STACKTOP = __stackBase__;
      return $retval33;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_readinto($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      $self_addr = $self;
      $args_addr = $args;
      $res = 0;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 11;
      break;
     case 5:
      
      
      
      if (HEAP[$5 + 24] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      var $14 = __bufferedwriter_flush_unlocked($self_addr, 0);
      $res = $14;
      
      
      if ($res == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      var $20 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $20;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $31 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$31]($res);
      __label__ = 9;
      break;
     case 9:
      
      
      
      var $36 = _bufferediobase_readinto($self_addr, $args_addr);
      $res = $36;
      __label__ = 10;
      break;
     case 10:
      
      $0 = $res;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_readline($self, $limit) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $limit_addr;
      var $retval;
      var $iftmp_116;
      var $0;
      var $iftmp_114;
      var $res;
      var $chunks;
      var $n;
      var $written;
      var $start;
      var $s;
      var $end;
      var $_py_tmp;
      var $_py_tmp31;
      var $_py_tmp36;
      var $_py_tmp57;
      var $_py_tmp62;
      var $_py_tmp70;
      var $_py_tmp75;
      $self_addr = $self;
      $limit_addr = $limit;
      $res = 0;
      $chunks = 0;
      $written = 0;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $7 = HEAP[$5 + 8];
      var $8 = __PyFileIO_closed($7);
      
      var $10 = $8 != 0;
      $iftmp_114 = $10;
      __lastLabel__ = 1;
      __label__ = 3;
      break;
     case 2:
      var $11 = _buffered_closed($5);
      
      var $13 = $11 != 0;
      $iftmp_114 = $13;
      __lastLabel__ = 2;
      __label__ = 3;
      break;
     case 3:
      var $14 = __lastLabel__ == 2 ? $13 : $10;
      
      if ($14 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      var $15 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($15, __str26);
      $0 = 0;
      __label__ = 71;
      break;
     case 5:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      var $27 = HEAP[$self_addr + 60] == -1;
      if ($27) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      
      
      $iftmp_116 = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      __label__ = 10;
      break;
     case 9:
      $iftmp_116 = 0;
      __label__ = 10;
      break;
     case 10:
      
      $n = $iftmp_116;
      
      
      if ($limit_addr >= 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      
      if ($n > $limit_addr) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      $n = $limit_addr;
      __label__ = 13;
      break;
     case 13:
      
      
      
      
      
      
      
      
      $start = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      
      
      var $54 = _memchr($start, 10, $n);
      $s = $54;
      
      if ($54 != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      
      
      
      
      
      
      
      var $63 = _PyString_FromStringAndSize($start, $s + 1 + (0 - $start));
      $res = $63;
      
      
      if ($res != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 15:
      
      
      
      
      
      
      
      
      
      
      
      var $76 = $s + 1 + (0 - $start) + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $76;
      __label__ = 67;
      break;
     case 16:
      
      
      
      if ($n == $limit_addr) {
        __label__ = 17;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 17:
      
      
      var $84 = _PyString_FromStringAndSize($start, $n);
      $res = $84;
      
      
      if ($res != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 18:
      
      
      
      
      
      var $92 = $n + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $92;
      __label__ = 67;
      break;
     case 19:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 20:
      
      var $100 = __bufferedwriter_flush_unlocked($self_addr, 1);
      $res = $100;
      
      
      if ($res == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      
      if ($res != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $109 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $109;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $120 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$120]($_py_tmp);
      __label__ = 24;
      break;
     case 24:
      var $122 = _PyList_New(0);
      $chunks = $122;
      
      if ($122 == 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      
      
      if ($n > 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 26:
      
      
      var $128 = _PyString_FromStringAndSize($start, $n);
      $res = $128;
      
      
      if ($res == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 27:
      
      
      var $133 = _PyList_Append($chunks, $res);
      
      
      var $136 = $res != 0;
      if ($133 < 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 28:
      if ($136) {
        __label__ = 29;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 29:
      
      $_py_tmp31 = $res;
      $res = 0;
      
      
      
      var $141 = HEAP[$_py_tmp31] - 1;
      
      
      HEAP[$_py_tmp31] = $141;
      
      
      
      
      if (HEAP[$_py_tmp31] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 30:
      
      
      
      
      var $152 = HEAP[HEAP[$_py_tmp31 + 4] + 24];
      
      FUNCTION_TABLE[$152]($_py_tmp31);
      __label__ = 67;
      break;
     case 31:
      if ($136) {
        __label__ = 32;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 32:
      
      $_py_tmp36 = $res;
      $res = 0;
      
      
      
      var $158 = HEAP[$_py_tmp36] - 1;
      
      
      HEAP[$_py_tmp36] = $158;
      
      
      
      
      if (HEAP[$_py_tmp36] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      
      
      
      
      var $169 = HEAP[HEAP[$_py_tmp36 + 4] + 24];
      
      FUNCTION_TABLE[$169]($_py_tmp36);
      __label__ = 34;
      break;
     case 34:
      
      
      var $173 = $n + $written;
      $written = $173;
      
      
      if ($limit_addr >= 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      
      
      var $178 = $limit_addr - $n;
      $limit_addr = $178;
      __label__ = 36;
      break;
     case 36:
      
      __bufferedreader_reset_buf($self_addr);
      
      var $181 = __bufferedreader_fill_buffer($self_addr);
      $n = $181;
      var $182 = $181 == -1;
      if ($182) {
        __label__ = 67;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 37:
      
      
      if ($n <= 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 38:
      
      
      if ($limit_addr >= 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 39:
      
      
      
      if ($n > $limit_addr) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      
      $n = $limit_addr;
      __label__ = 41;
      break;
     case 41:
      
      
      
      $start = HEAP[$self_addr + 40];
      
      
      
      $end = $start + $n;
      
      $s = $start;
      __label__ = 45;
      break;
     case 42:
      
      
      
      var $201 = HEAP[$s] == 10;
      
      var $203 = $s + 1;
      $s = $203;
      
      if ($201 != 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 43:
      
      
      
      
      
      
      var $210 = _PyString_FromStringAndSize($start, $s - $start);
      $res = $210;
      
      
      if ($res == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      
      
      
      
      
      
      
      HEAP[$self_addr + 44] = $s - $start;
      __label__ = 58;
      break;
     case 45:
      
      
      
      if ($s < $end) {
        __label__ = 42;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      var $226 = _PyString_FromStringAndSize($start, $n);
      $res = $226;
      
      
      if ($res == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      
      
      
      if ($n == $limit_addr) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      
      
      
      
      HEAP[$self_addr + 44] = $n;
      __label__ = 58;
      break;
     case 49:
      
      
      var $238 = _PyList_Append($chunks, $res);
      
      
      var $241 = $res != 0;
      if ($238 < 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 50:
      if ($241) {
        __label__ = 51;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 51:
      
      $_py_tmp57 = $res;
      $res = 0;
      
      
      
      var $246 = HEAP[$_py_tmp57] - 1;
      
      
      HEAP[$_py_tmp57] = $246;
      
      
      
      
      if (HEAP[$_py_tmp57] == 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 52:
      
      
      
      
      var $257 = HEAP[HEAP[$_py_tmp57 + 4] + 24];
      
      FUNCTION_TABLE[$257]($_py_tmp57);
      __label__ = 67;
      break;
     case 53:
      if ($241) {
        __label__ = 54;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 54:
      
      $_py_tmp62 = $res;
      $res = 0;
      
      
      
      var $263 = HEAP[$_py_tmp62] - 1;
      
      
      HEAP[$_py_tmp62] = $263;
      
      
      
      
      if (HEAP[$_py_tmp62] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 55:
      
      
      
      
      var $274 = HEAP[HEAP[$_py_tmp62 + 4] + 24];
      
      FUNCTION_TABLE[$274]($_py_tmp62);
      __label__ = 56;
      break;
     case 56:
      
      
      var $278 = $n + $written;
      $written = $278;
      
      
      if ($limit_addr >= 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 57:
      
      
      var $283 = $limit_addr - $n;
      $limit_addr = $283;
      __label__ = 36;
      break;
     case 58:
      
      
      if ($res != 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 59:
      
      
      var $288 = _PyList_Append($chunks, $res);
      
      
      var $291 = $res != 0;
      if ($288 < 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 60:
      if ($291) {
        __label__ = 61;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 61:
      
      $_py_tmp70 = $res;
      $res = 0;
      
      
      
      var $296 = HEAP[$_py_tmp70] - 1;
      
      
      HEAP[$_py_tmp70] = $296;
      
      
      
      
      if (HEAP[$_py_tmp70] == 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 62:
      
      
      
      
      var $307 = HEAP[HEAP[$_py_tmp70 + 4] + 24];
      
      FUNCTION_TABLE[$307]($_py_tmp70);
      __label__ = 67;
      break;
     case 63:
      if ($291) {
        __label__ = 64;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 64:
      
      $_py_tmp75 = $res;
      $res = 0;
      
      
      
      var $313 = HEAP[$_py_tmp75] - 1;
      
      
      HEAP[$_py_tmp75] = $313;
      
      
      
      
      if (HEAP[$_py_tmp75] == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 65:
      
      
      
      
      var $324 = HEAP[HEAP[$_py_tmp75 + 4] + 24];
      
      FUNCTION_TABLE[$324]($_py_tmp75);
      __label__ = 66;
      break;
     case 66:
      var $326 = HEAP[__PyIO_empty_bytes];
      
      var $328 = __PyString_Join($326, $chunks);
      $res = $328;
      __label__ = 67;
      break;
     case 67:
      
      
      if ($chunks != 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 68:
      
      
      
      var $333 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $333;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      
      
      
      
      var $344 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$344]($chunks);
      __label__ = 70;
      break;
     case 70:
      
      $0 = $res;
      __label__ = 71;
      break;
     case 71:
      
      $retval = $0;
      var $retval83 = $retval;
      return $retval83;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $limit = __stackBase__;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$limit] = -1;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 8;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str27, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $limit, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 8;
      break;
     case 7:
      var $13 = HEAP[$limit];
      
      var $15 = __buffered_readline($self_addr, $13);
      $0 = $15;
      __label__ = 8;
      break;
     case 8:
      
      $retval = $0;
      var $retval8 = $retval;
      STACKTOP = __stackBase__;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_tell($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_133;
      var $0;
      var $pos;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 15;
      break;
     case 5:
      var $10 = __buffered_raw_tell($5);
      $pos = $10;
      
      var $12 = $pos == -1;
      if ($12) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 15;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      var $20 = HEAP[$self_addr + 60] != -1;
      if ($20) {
        __label__ = 11;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      var $28 = HEAP[$self_addr + 76] != -1;
      if ($28) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      
      
      if (HEAP[$self_addr + 52] < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      
      
      
      
      
      
      
      $iftmp_133 = HEAP[$self_addr + 52] - HEAP[$self_addr + 44];
      __label__ = 14;
      break;
     case 13:
      $iftmp_133 = 0;
      __label__ = 14;
      break;
     case 14:
      
      
      var $42 = $pos - $iftmp_133;
      $pos = $42;
      
      var $44 = _PyLong_FromLongLong($pos);
      $0 = $44;
      __label__ = 15;
      break;
     case 15:
      
      $retval = $0;
      var $retval15 = $retval;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_150;
      var $iftmp_148;
      var $iftmp_146;
      var $iftmp_145;
      var $iftmp_140;
      var $0;
      var $target;
      var $n;
      var $whence = __stackBase__;
      var $targetobj = __stackBase__ + 4;
      var $res;
      var $current;
      var $avail;
      var $offset;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$whence] = 0;
      $res = 0;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 60;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str28, allocate([ $targetobj, 0, 0, 0, $whence, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 60;
      break;
     case 7:
      
      
      
      
      
      if (HEAP[$whence] < 0 | HEAP[$whence] > 2) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $17 = HEAP[$whence];
      var $18 = HEAP[_PyExc_ValueError];
      var $19 = _PyErr_Format($18, __str29, allocate([ $17, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 60;
      break;
     case 9:
      
      
      
      
      var $24 = $self_addr;
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      var $26 = HEAP[$24 + 8];
      var $27 = __PyFileIO_closed($26);
      
      var $29 = $27 != 0;
      $iftmp_140 = $29;
      __lastLabel__ = 10;
      __label__ = 12;
      break;
     case 11:
      var $30 = _buffered_closed($24);
      
      var $32 = $30 != 0;
      $iftmp_140 = $32;
      __lastLabel__ = 11;
      __label__ = 12;
      break;
     case 12:
      var $33 = __lastLabel__ == 11 ? $32 : $29;
      
      var $34 = HEAP[_PyExc_ValueError];
      if ($33 != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      _PyErr_SetString($34, __str30);
      $0 = 0;
      __label__ = 60;
      break;
     case 14:
      var $35 = HEAP[$targetobj];
      var $36 = _PyNumber_AsOff_t($35, $34);
      $target = $36;
      
      var $38 = $target == -1;
      if ($38) {
        __label__ = 15;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 15:
      var $39 = _PyErr_Occurred();
      
      if ($39 != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      $0 = 0;
      __label__ = 60;
      break;
     case 17:
      
      
      if (HEAP[$whence] != 2) {
        __label__ = 18;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 18:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 19:
      
      
      
      var $50 = HEAP[$self_addr + 32] != -1;
      var $51 = $self_addr;
      if ($50) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      $iftmp_145 = HEAP[$51 + 32];
      __label__ = 22;
      break;
     case 21:
      var $54 = __buffered_raw_tell($51);
      $iftmp_145 = $54;
      __label__ = 22;
      break;
     case 22:
      
      $current = $iftmp_145;
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 23:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      
      
      var $67 = HEAP[$self_addr + 60] == -1;
      if ($67) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      $iftmp_146 = 0;
      $avail = 0;
      __label__ = 40;
      break;
     case 26:
      
      
      
      
      
      
      
      $iftmp_146 = HEAP[$self_addr + 60] - HEAP[$self_addr + 44];
      $avail = HEAP[$self_addr + 60] - HEAP[$self_addr + 44];
      
      if (HEAP[$self_addr + 60] - HEAP[$self_addr + 44] > 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 27:
      
      
      if (HEAP[$whence] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 28:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 29:
      
      
      
      var $85 = HEAP[$self_addr + 60] != -1;
      if ($85) {
        __label__ = 32;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 30:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      
      var $93 = HEAP[$self_addr + 76] != -1;
      if ($93) {
        __label__ = 32;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 32:
      
      
      
      
      if (HEAP[$self_addr + 52] < 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 33:
      
      
      
      
      
      
      
      $iftmp_148 = HEAP[$self_addr + 52] - HEAP[$self_addr + 44];
      __label__ = 35;
      break;
     case 34:
      $iftmp_148 = 0;
      __label__ = 35;
      break;
     case 35:
      
      
      
      
      
      
      
      
      $offset = 0 - (0 - $iftmp_148) + (0 - $current) + $target;
      __label__ = 37;
      break;
     case 36:
      
      $offset = $target;
      __label__ = 37;
      break;
     case 37:
      
      
      
      
      
      
      if (0 - HEAP[$self_addr + 44] <= $offset) {
        __label__ = 38;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 38:
      
      
      
      if ($offset <= $avail) {
        __label__ = 39;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 39:
      
      
      
      
      var $123 = $offset + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $123;
      
      
      
      
      
      
      var $131 = _PyLong_FromLongLong(0 - $avail + $current + $offset);
      $0 = $131;
      __label__ = 60;
      break;
     case 40:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 41:
      
      var $137 = __bufferedwriter_flush_unlocked($self_addr, 0);
      $res = $137;
      
      
      if ($res == 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 42:
      
      
      if ($res != 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 43:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $146 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $146;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 44:
      
      
      
      
      var $157 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$157]($_py_tmp);
      __label__ = 45;
      break;
     case 45:
      
      __bufferedwriter_reset_buf($self_addr);
      __label__ = 46;
      break;
     case 46:
      
      
      if (HEAP[$whence] == 1) {
        __label__ = 47;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 47:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 48:
      
      
      
      var $169 = HEAP[$self_addr + 60] != -1;
      if ($169) {
        __label__ = 51;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 49:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      
      
      var $177 = HEAP[$self_addr + 76] != -1;
      if ($177) {
        __label__ = 51;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 51:
      
      
      
      
      if (HEAP[$self_addr + 52] < 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 52:
      
      
      
      
      
      
      
      $iftmp_150 = HEAP[$self_addr + 52] - HEAP[$self_addr + 44];
      __label__ = 54;
      break;
     case 53:
      $iftmp_150 = 0;
      __label__ = 54;
      break;
     case 54:
      
      
      var $191 = $target - $iftmp_150;
      $target = $191;
      __label__ = 55;
      break;
     case 55:
      var $192 = HEAP[$whence];
      
      
      var $195 = __buffered_raw_seek($self_addr, $target, $192);
      $n = $195;
      var $196 = $195 == -1;
      if ($196) {
        __label__ = 59;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 56:
      
      
      HEAP[$self_addr + 52] = -1;
      
      var $200 = _PyLong_FromLongLong($n);
      $res = $200;
      
      
      if ($res != 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 57:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 58:
      
      __bufferedreader_reset_buf($self_addr);
      __label__ = 59;
      break;
     case 59:
      
      $0 = $res;
      __label__ = 60;
      break;
     case 60:
      
      $retval = $0;
      var $retval61 = $retval;
      STACKTOP = __stackBase__;
      return $retval61;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_155;
      var $0;
      var $pos = __stackBase__;
      var $res;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$pos] = __Py_NoneStruct;
      $res = 0;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 27;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str31, allocate([ $pos, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 27;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      var $18 = __bufferedwriter_flush_unlocked($self_addr, 0);
      $res = $18;
      
      
      if ($res == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      if ($res != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $27 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $27;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $38 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$38]($_py_tmp);
      __label__ = 12;
      break;
     case 12:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 13:
      
      
      if (HEAP[$pos] == __Py_NoneStruct) {
        __label__ = 14;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 14:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      var $53 = HEAP[$self_addr + 60] != -1;
      if ($53) {
        __label__ = 18;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      var $61 = HEAP[$self_addr + 76] != -1;
      if ($61) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      
      
      
      
      if (HEAP[$self_addr + 52] < 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      
      
      
      
      $iftmp_155 = HEAP[$self_addr + 44] - HEAP[$self_addr + 52];
      __label__ = 21;
      break;
     case 20:
      $iftmp_155 = 0;
      __label__ = 21;
      break;
     case 21:
      
      
      var $75 = __buffered_raw_seek($self_addr, $iftmp_155, 1);
      var $76 = $75 == -1;
      if ($76) {
        __label__ = 26;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      __bufferedreader_reset_buf($self_addr);
      __label__ = 23;
      break;
     case 23:
      var $78 = HEAP[$pos];
      var $79 = HEAP[__PyIO_str_truncate];
      
      
      var $82 = HEAP[$self_addr + 8];
      var $83 = _PyObject_CallMethodObjArgs($82, $79, allocate([ $78, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $83;
      
      if ($83 == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      var $86 = __buffered_raw_tell($self_addr);
      var $87 = $86 == -1;
      if ($87) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      _PyErr_Clear();
      __label__ = 26;
      break;
     case 26:
      
      $0 = $res;
      __label__ = 27;
      break;
     case 27:
      
      $retval = $0;
      var $retval26 = $retval;
      STACKTOP = __stackBase__;
      return $retval26;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_iternext($self) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $line;
      var $tp;
      $self_addr = $self;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 19;
      break;
     case 5:
      
      
      
      $tp = HEAP[$5 + 4];
      
      
      
      
      
      if ($tp == _PyBufferedReader_Type | $tp == _PyBufferedRandom_Type) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      var $18 = __buffered_readline($self_addr, -1);
      $line = $18;
      __lastLabel__ = 6;
      __label__ = 12;
      break;
     case 7:
      var $19 = HEAP[__PyIO_str_readline];
      
      
      var $22 = _PyObject_CallMethodObjArgs($self_addr, $19, allocate(4, "i8*", ALLOC_STACK));
      $line = $22;
      
      
      if ($line != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      var $32 = $line;
      if ((HEAP[HEAP[$line + 4] + 84] & 134217728) == 0) {
        __lastLabel__ = 8;
        __label__ = 9;
        break;
      } else {
        __lastLabel__ = 8;
        __label__ = 12;
        break;
      }
     case 9:
      
      
      
      var $36 = HEAP[HEAP[$32 + 4] + 12];
      var $37 = HEAP[_PyExc_IOError];
      var $38 = _PyErr_Format($37, __str32, allocate([ $36, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $42 = HEAP[$line] - 1;
      
      
      HEAP[$line] = $42;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $53 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$53]($line);
      __label__ = 11;
      break;
     case 11:
      $0 = 0;
      __label__ = 19;
      break;
     case 12:
      var $55 = __lastLabel__ == 6 ? $18 : $32;
      
      if ($55 == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      $0 = 0;
      __label__ = 19;
      break;
     case 14:
      
      
      
      
      
      var $62 = $line;
      if (HEAP[$line + 8] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      
      
      var $65 = HEAP[$62] - 1;
      
      
      HEAP[$line] = $65;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $76 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$76]($line);
      __label__ = 17;
      break;
     case 17:
      $0 = 0;
      __label__ = 19;
      break;
     case 18:
      $0 = $62;
      __label__ = 19;
      break;
     case 19:
      
      $retval = $0;
      var $retval20 = $retval;
      return $retval20;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_repr($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $nameobj;
      var $res;
      var $repr;
      $self_addr = $self;
      
      
      var $3 = _PyObject_GetAttrString($self_addr, __str13);
      $nameobj = $3;
      
      
      if ($nameobj == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      var $6 = HEAP[_PyExc_AttributeError];
      var $7 = _PyErr_ExceptionMatches($6);
      
      if ($7 != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_Clear();
      
      
      
      
      
      var $14 = HEAP[HEAP[$self_addr + 4] + 12];
      var $15 = _PyString_FromFormat(__str33, allocate([ $14, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $15;
      __label__ = 10;
      break;
     case 3:
      $0 = 0;
      __label__ = 11;
      break;
     case 4:
      
      var $17 = _PyObject_Repr($nameobj);
      $repr = $17;
      
      
      
      var $21 = HEAP[$nameobj] - 1;
      
      
      HEAP[$nameobj] = $21;
      
      
      
      
      if (HEAP[$nameobj] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $32 = HEAP[HEAP[$nameobj + 4] + 24];
      
      FUNCTION_TABLE[$32]($nameobj);
      __label__ = 6;
      break;
     case 6:
      
      
      if ($repr == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      $0 = 0;
      __label__ = 11;
      break;
     case 8:
      
      
      
      
      
      
      
      
      
      var $45 = HEAP[HEAP[$self_addr + 4] + 12];
      var $46 = _PyString_FromFormat(__str34, allocate([ $45, 0, 0, 0, $repr + 20, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $46;
      
      
      
      var $50 = HEAP[$repr] - 1;
      
      
      HEAP[$repr] = $50;
      
      
      
      
      if (HEAP[$repr] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $61 = HEAP[HEAP[$repr + 4] + 24];
      
      FUNCTION_TABLE[$61]($repr);
      __label__ = 10;
      break;
     case 10:
      
      $0 = $res;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval11 = $retval;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_reset_buf($self) {
    
    var $self_addr;
    $self_addr = $self;
    
    
    HEAP[$self_addr + 60] = -1;
    return;
  }
  function _bufferedreader_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $iftmp_176;
      var $0;
      var $kwlist = __stackBase__;
      var $buffer_size = __stackBase__ + 12;
      var $raw = __stackBase__ + 16;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str35;
      
      HEAP[$kwlist + 4] = __str36;
      
      HEAP[$kwlist + 8] = 0;
      HEAP[$buffer_size] = 8192;
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      var $kwlist1 = $kwlist;
      var $10 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str37, $kwlist1, allocate([ $raw, 0, 0, 0, $buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($10 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 14;
      break;
     case 2:
      var $12 = HEAP[$raw];
      var $13 = __PyIOBase_check_readable($12, __Py_TrueStruct);
      
      if ($13 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = -1;
      __label__ = 14;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $27 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $27;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $38 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$38]($_py_tmp);
      __label__ = 7;
      break;
     case 7:
      
      
      
      var $43 = HEAP[HEAP[$raw]] + 1;
      var $44 = HEAP[$raw];
      HEAP[$44] = $43;
      var $45 = HEAP[$raw];
      
      
      HEAP[$self_addr + 8] = $45;
      var $48 = HEAP[$buffer_size];
      
      
      HEAP[$self_addr + 84] = $48;
      
      
      HEAP[$self_addr + 20] = 1;
      
      
      HEAP[$self_addr + 24] = 0;
      
      var $56 = __buffered_init($self_addr);
      
      if ($56 < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = -1;
      __label__ = 14;
      break;
     case 9:
      
      __bufferedreader_reset_buf($self_addr);
      
      
      
      
      
      if (HEAP[$self_addr + 4] != _PyBufferedReader_Type) {
        __label__ = 12;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      if (HEAP[HEAP[$raw] + 4] != _PyFileIO_Type) {
        __label__ = 12;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 11:
      $iftmp_176 = 1;
      __label__ = 13;
      break;
     case 12:
      $iftmp_176 = 0;
      __label__ = 13;
      break;
     case 13:
      
      
      
      HEAP[$self_addr + 28] = $iftmp_176;
      
      
      HEAP[$self_addr + 12] = 1;
      $0 = 0;
      __label__ = 14;
      break;
     case 14:
      
      $retval = $0;
      var $retval15 = $retval;
      STACKTOP = __stackBase__;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_raw_read($self, $start, $len) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $start_addr;
      var $len_addr;
      var $retval;
      var $0;
      var $buf = __stackBase__;
      var $memobj;
      var $res;
      var $n;
      $self_addr = $self;
      $start_addr = $start;
      $len_addr = $len;
      
      
      var $3 = _PyBuffer_FillInfo($buf, 0, $start_addr, $len_addr, 0, 9);
      var $4 = $3 == -1;
      if ($4) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 23;
      break;
     case 2:
      var $5 = _PyMemoryView_FromBuffer($buf);
      $memobj = $5;
      
      
      if ($memobj == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = -1;
      __label__ = 23;
      break;
     case 4:
      var $8 = HEAP[__PyIO_str_readinto];
      
      
      var $11 = HEAP[$self_addr + 8];
      
      var $13 = _PyObject_CallMethodObjArgs($11, $8, allocate([ $memobj, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $13;
      
      if ($13 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      var $15 = __trap_eintr();
      
      if ($15 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      var $20 = HEAP[$memobj] - 1;
      
      
      HEAP[$memobj] = $20;
      
      
      
      
      if (HEAP[$memobj] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $31 = HEAP[HEAP[$memobj + 4] + 24];
      
      FUNCTION_TABLE[$31]($memobj);
      __label__ = 8;
      break;
     case 8:
      
      
      if ($res == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $0 = -1;
      __label__ = 23;
      break;
     case 10:
      
      
      if ($res == __Py_NoneStruct) {
        __label__ = 11;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 11:
      
      
      
      var $40 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $40;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $51 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$51]($res);
      __label__ = 13;
      break;
     case 13:
      $0 = -2;
      __label__ = 23;
      break;
     case 14:
      var $53 = HEAP[_PyExc_ValueError];
      
      var $55 = _PyNumber_AsSsize_t($res, $53);
      $n = $55;
      
      
      
      var $59 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $59;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $70 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$70]($res);
      __label__ = 16;
      break;
     case 16:
      
      
      if ($n < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      if ($n > $len_addr) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      var $77 = HEAP[_PyExc_IOError];
      
      
      var $80 = _PyErr_Format($77, __str38, allocate([ $n, 0, 0, 0, $len_addr, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = -1;
      __label__ = 23;
      break;
     case 19:
      
      
      if ($n > 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 20:
      
      
      
      var $86 = HEAP[$self_addr + 32] != -1;
      if ($86) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      
      var $92 = $n + HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = $92;
      __label__ = 22;
      break;
     case 22:
      
      $0 = $n;
      __label__ = 23;
      break;
     case 23:
      
      $retval = $0;
      var $retval23 = $retval;
      STACKTOP = __stackBase__;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_fill_buffer($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $start;
      var $len;
      var $n;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      var $8 = HEAP[$self_addr + 60] == -1;
      if ($8) {
        __label__ = 3;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      
      $start = HEAP[$self_addr + 60] & 4294967295;
      __label__ = 4;
      break;
     case 3:
      $start = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      
      
      
      $len = HEAP[$self_addr + 84] - $start;
      
      
      
      
      var $22 = HEAP[$self_addr + 40] + $start;
      
      
      var $25 = __bufferedreader_raw_read($self_addr, $22, $len);
      $n = $25;
      
      if ($25 <= 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      $0 = $n;
      __label__ = 7;
      break;
     case 6:
      
      
      
      
      
      
      HEAP[$self_addr + 60] = $n + $start;
      
      
      
      
      
      
      HEAP[$self_addr + 52] = $n + $start;
      
      $0 = $n;
      __label__ = 7;
      break;
     case 7:
      
      $retval = $0;
      var $retval7 = $retval;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_read_all($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $iftmp_182;
      var $0;
      var $current_size;
      var $res;
      var $data;
      var $chunks;
      var $_py_tmp;
      $self_addr = $self;
      $data = 0;
      var $1 = _PyList_New(0);
      $chunks = $1;
      
      
      if ($chunks == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 52;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 4:
      
      
      
      var $15 = HEAP[$self_addr + 60] == -1;
      if ($15) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $iftmp_182 = 0;
      $current_size = 0;
      __label__ = 11;
      break;
     case 6:
      
      
      
      
      
      
      
      
      
      $iftmp_182 = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      $current_size = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      
      if ((HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295) != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      
      
      
      
      
      
      
      var $33 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      
      var $35 = _PyString_FromStringAndSize($33, $current_size);
      $data = $35;
      
      
      if ($data == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      
      var $41 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $41;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $52 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$52]($chunks);
      __label__ = 10;
      break;
     case 10:
      $0 = 0;
      __label__ = 52;
      break;
     case 11:
      
      __bufferedreader_reset_buf($self_addr);
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 12:
      
      var $60 = __bufferedwriter_flush_unlocked($self_addr, 1);
      $res = $60;
      
      
      if ($res == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 13:
      
      
      
      var $66 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $66;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $77 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$77]($chunks);
      __label__ = 15;
      break;
     case 15:
      $0 = 0;
      __label__ = 52;
      break;
     case 16:
      
      
      if ($res != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 17:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $85 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $85;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $96 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$96]($_py_tmp);
      __label__ = 19;
      break;
     case 19:
      
      
      if ($data != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 20:
      
      
      var $102 = _PyList_Append($chunks, $data);
      var $103 = $102 < 0;
      
      
      
      var $107 = HEAP[$data] - 1;
      
      
      HEAP[$data] = $107;
      
      
      
      var $113 = HEAP[$data] == 0;
      if ($103) {
        __label__ = 21;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 21:
      if ($113) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      var $118 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$118]($data);
      __label__ = 23;
      break;
     case 23:
      
      
      
      var $123 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $123;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      
      
      var $134 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$134]($chunks);
      __label__ = 25;
      break;
     case 25:
      $0 = 0;
      __label__ = 52;
      break;
     case 26:
      if ($113) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      
      
      var $140 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$140]($data);
      __label__ = 28;
      break;
     case 28:
      var $142 = HEAP[__PyIO_str_read];
      
      
      var $145 = HEAP[$self_addr + 8];
      var $146 = _PyObject_CallMethodObjArgs($145, $142, allocate(4, "i8*", ALLOC_STACK));
      $data = $146;
      
      if ($146 == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 29:
      
      
      
      var $151 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $151;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      
      
      
      
      var $162 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$162]($chunks);
      __label__ = 31;
      break;
     case 31:
      $0 = 0;
      __label__ = 52;
      break;
     case 32:
      
      
      if ($data != __Py_NoneStruct) {
        __label__ = 33;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 33:
      
      
      
      
      
      
      
      var $173 = $data;
      if ((HEAP[HEAP[$data + 4] + 84] & 134217728) == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 34:
      
      
      var $176 = HEAP[$173] - 1;
      
      
      HEAP[$data] = $176;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      
      
      
      
      var $187 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$187]($data);
      __label__ = 36;
      break;
     case 36:
      
      
      
      var $192 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $192;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      
      
      
      
      var $203 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$203]($chunks);
      __label__ = 38;
      break;
     case 38:
      var $205 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($205, __str3);
      $0 = 0;
      __label__ = 52;
      break;
     case 39:
      
      if ($173 == __Py_NoneStruct) {
        __label__ = 41;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 40:
      
      
      
      
      
      if (HEAP[$data + 8] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 41:
      
      
      if ($current_size == 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 42:
      
      
      
      var $217 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $217;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      
      
      
      
      var $228 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$228]($chunks);
      __label__ = 44;
      break;
     case 44:
      
      $0 = $data;
      __label__ = 52;
      break;
     case 45:
      var $231 = HEAP[__PyIO_empty_bytes];
      
      var $233 = __PyString_Join($231, $chunks);
      $res = $233;
      
      
      
      var $237 = HEAP[$data] - 1;
      
      
      HEAP[$data] = $237;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 46:
      
      
      
      
      var $248 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$248]($data);
      __label__ = 47;
      break;
     case 47:
      
      
      
      var $253 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $253;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      
      
      
      
      var $264 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$264]($chunks);
      __label__ = 49;
      break;
     case 49:
      
      $0 = $res;
      __label__ = 52;
      break;
     case 50:
      
      
      
      
      
      var $272 = $current_size + HEAP[$data + 8];
      $current_size = $272;
      
      
      
      var $276 = HEAP[$self_addr + 32] != -1;
      if ($276) {
        __label__ = 51;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 51:
      
      
      
      
      
      
      
      
      var $285 = HEAP[$data + 8] + HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = $285;
      __label__ = 19;
      break;
     case 52:
      
      $retval = $0;
      var $retval54 = $retval;
      return $retval54;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_read_fast($self, $n) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $n_addr;
      var $retval;
      var $0;
      var $iftmp_189;
      var $current_size;
      var $res;
      $self_addr = $self;
      $n_addr = $n;
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      var $12 = HEAP[$self_addr + 60] == -1;
      if ($12) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      
      $iftmp_189 = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      __label__ = 5;
      break;
     case 4:
      $iftmp_189 = 0;
      __label__ = 5;
      break;
     case 5:
      
      $current_size = $iftmp_189;
      
      
      
      if ($n_addr <= $current_size) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      
      
      
      
      
      var $33 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      
      var $35 = _PyString_FromStringAndSize($33, $n_addr);
      $res = $35;
      
      
      if ($res != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $43 = $n_addr + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $43;
      __label__ = 8;
      break;
     case 8:
      
      $0 = $res;
      __label__ = 10;
      break;
     case 9:
      
      var $48 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $48;
      $0 = __Py_NoneStruct;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_read_generic($self, $n) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $n_addr;
      var $retval;
      var $iftmp_195;
      var $0;
      var $iftmp_190;
      var $res = __stackBase__;
      var $current_size;
      var $remaining;
      var $written;
      var $out;
      var $r;
      var $r31;
      $self_addr = $self;
      $n_addr = $n;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      var $12 = HEAP[$self_addr + 60] == -1;
      if ($12) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      
      $iftmp_190 = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      __label__ = 5;
      break;
     case 4:
      $iftmp_190 = 0;
      __label__ = 5;
      break;
     case 5:
      
      $current_size = $iftmp_190;
      
      
      
      if ($n_addr <= $current_size) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      var $28 = __bufferedreader_read_fast($self_addr, $n_addr);
      $0 = $28;
      __label__ = 49;
      break;
     case 7:
      
      var $30 = _PyString_FromStringAndSize(0, $n_addr);
      HEAP[$res] = $30;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      
      $out = HEAP[$res] + 20;
      
      $remaining = $n_addr;
      $written = 0;
      
      
      if ($current_size > 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      
      
      
      
      var $48 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      
      _llvm_memcpy_p0i8_p0i8_i32($out, $48, $current_size, 1, 0);
      
      
      var $52 = $remaining - $current_size;
      $remaining = $52;
      
      
      var $55 = $current_size + $written;
      $written = $55;
      __label__ = 10;
      break;
     case 10:
      
      __bufferedreader_reset_buf($self_addr);
      var $_pr = $remaining;
      __lastLabel__ = 10;
      __label__ = 25;
      break;
     case 11:
      
      
      
      
      var $61 = $self_addr;
      if (HEAP[$self_addr + 88] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      var $not = HEAP[$61 + 88] ^ -1;
      
      var $65 = $remaining & $not;
      $iftmp_195 = $65;
      __lastLabel__ = 12;
      __label__ = 14;
      break;
     case 13:
      
      
      
      
      
      
      
      var $73 = ($remaining / HEAP[$self_addr + 84] | 0) * HEAP[$61 + 84];
      $iftmp_195 = $73;
      __lastLabel__ = 13;
      __label__ = 14;
      break;
     case 14:
      var $74 = __lastLabel__ == 13 ? $73 : $65;
      $r = $74;
      
      if ($74 == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      
      
      var $81 = __bufferedreader_raw_read($self_addr, $out + $written, $r);
      $r = $81;
      
      var $83 = $r == -1;
      if ($83) {
        __label__ = 45;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      var $87 = $r == -2;
      
      if ($r == 0 | $87) {
        __label__ = 17;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 17:
      
      
      if ($r == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      if ($written > 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      var $93 = __PyString_Resize($res, $written);
      
      if ($93 != 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 20:
      
      $0 = HEAP[$res];
      __label__ = 49;
      break;
     case 21:
      var $96 = HEAP[$res];
      
      
      var $99 = HEAP[$96] - 1;
      var $100 = $96;
      HEAP[$100] = $99;
      
      
      
      if (HEAP[$96] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      var $108 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $109 = HEAP[$res];
      FUNCTION_TABLE[$108]($109);
      __label__ = 23;
      break;
     case 23:
      
      var $111 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $111;
      $0 = __Py_NoneStruct;
      __label__ = 49;
      break;
     case 24:
      
      
      var $114 = $remaining - $r;
      $remaining = $114;
      
      
      var $117 = $r + $written;
      $written = $117;
      __lastLabel__ = 24;
      __label__ = 25;
      break;
     case 25:
      var $118 = __lastLabel__ == 24 ? $114 : $_pr;
      
      if ($118 > 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      
      
      
      
      if (HEAP[$self_addr + 84] < $remaining) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      ___assert_fail(__str39, __str10, 1462, ___PRETTY_FUNCTION___10369);
      throw "Reached an unreachable!";
     case 28:
      
      
      HEAP[$self_addr + 44] = 0;
      
      
      HEAP[$self_addr + 52] = 0;
      
      
      HEAP[$self_addr + 60] = 0;
      
      
      if ($remaining <= 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 29:
      
      var $132 = __bufferedreader_fill_buffer($self_addr);
      $r31 = $132;
      
      var $134 = $r31 == -1;
      if ($134) {
        __label__ = 45;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 30:
      
      
      
      var $138 = $r31 == -2;
      
      if ($r31 == 0 | $138) {
        __label__ = 31;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 31:
      
      
      if ($r31 == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 32:
      
      
      if ($written > 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 33:
      
      var $144 = __PyString_Resize($res, $written);
      
      if ($144 != 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 34:
      
      $0 = HEAP[$res];
      __label__ = 49;
      break;
     case 35:
      var $147 = HEAP[$res];
      
      
      var $150 = HEAP[$147] - 1;
      var $151 = $147;
      HEAP[$151] = $150;
      
      
      
      if (HEAP[$147] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 36:
      
      
      
      
      var $159 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $160 = HEAP[$res];
      FUNCTION_TABLE[$159]($160);
      __label__ = 37;
      break;
     case 37:
      
      var $162 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $162;
      $0 = __Py_NoneStruct;
      __label__ = 49;
      break;
     case 38:
      
      
      
      if ($remaining > $r31) {
        __label__ = 39;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 39:
      
      
      
      
      
      
      
      
      var $174 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      
      
      
      _llvm_memcpy_p0i8_p0i8_i32($out + $written, $174, $r31, 1, 0);
      
      
      var $180 = $r31 + $written;
      $written = $180;
      
      
      
      
      
      var $186 = $r31 + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $186;
      
      
      var $191 = $remaining - $r31;
      $remaining = $191;
      __label__ = 42;
      break;
     case 40:
      
      
      if ($remaining > 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      
      
      
      
      var $202 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      
      
      
      _llvm_memcpy_p0i8_p0i8_i32($out + $written, $202, $remaining, 1, 0);
      
      
      var $208 = $remaining + $written;
      $written = $208;
      
      
      
      
      
      var $214 = $remaining + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $214;
      $remaining = 0;
      __label__ = 42;
      break;
     case 42:
      
      
      
      
      
      if ($remaining == 0 | $remaining <= 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 43:
      
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 60] < HEAP[$self_addr + 84]) {
        __label__ = 29;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      $0 = HEAP[$res];
      __label__ = 49;
      break;
     case 45:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      var $231 = HEAP[$res];
      
      
      var $234 = HEAP[$231] - 1;
      var $235 = $231;
      HEAP[$235] = $234;
      
      
      
      if (HEAP[$231] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      
      
      
      
      var $243 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $244 = HEAP[$res];
      FUNCTION_TABLE[$243]($244);
      __label__ = 48;
      break;
     case 48:
      $0 = 0;
      __label__ = 49;
      break;
     case 49:
      
      $retval = $0;
      var $retval53 = $retval;
      STACKTOP = __stackBase__;
      return $retval53;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_peek_unlocked($self, $n) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $n_addr;
      var $retval;
      var $0;
      var $iftmp_208;
      var $have;
      var $r;
      $self_addr = $self;
      $n_addr = $n;
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      var $12 = HEAP[$self_addr + 60] == -1;
      if ($12) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $iftmp_208 = 0;
      $have = 0;
      var $13 = $self_addr;
      __lastLabel__ = 3;
      __label__ = 6;
      break;
     case 4:
      
      
      
      
      
      
      
      
      
      $iftmp_208 = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      $have = (HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295);
      
      var $24 = $self_addr;
      if ((HEAP[$self_addr + 60] & 4294967295) - (HEAP[$self_addr + 44] & 4294967295) > 0) {
        __lastLabel__ = 4;
        __label__ = 5;
        break;
      } else {
        __lastLabel__ = 4;
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      
      
      var $31 = HEAP[$24 + 40] + (HEAP[$self_addr + 44] & 4294967295);
      
      var $33 = _PyString_FromStringAndSize($31, $have);
      $0 = $33;
      __label__ = 11;
      break;
     case 6:
      var $34 = __lastLabel__ == 3 ? $13 : $24;
      __bufferedreader_reset_buf($34);
      
      var $36 = __bufferedreader_fill_buffer($self_addr);
      $r = $36;
      var $37 = $36 == -1;
      if ($37) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      $0 = 0;
      __label__ = 11;
      break;
     case 8:
      
      var $39 = $r == -2;
      if ($39) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $r = 0;
      __label__ = 10;
      break;
     case 10:
      
      
      HEAP[$self_addr + 44] = 0;
      
      
      var $44 = HEAP[$self_addr + 40];
      
      var $46 = _PyString_FromStringAndSize($44, $r);
      $0 = $46;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval12 = $retval;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _complain_about_max_buffer_size() {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $retval;
      var $0;
      var $1 = HEAP[_PyExc_DeprecationWarning];
      var $2 = _PyErr_WarnEx($1, __str54, 1);
      
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      $0 = 1;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedwriter_reset_buf($self) {
    
    var $self_addr;
    $self_addr = $self;
    
    
    HEAP[$self_addr + 68] = 0;
    
    
    HEAP[$self_addr + 76] = -1;
    return;
  }
  function _bufferedwriter_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $iftmp_217;
      var $0;
      var $kwlist = __stackBase__;
      var $buffer_size = __stackBase__ + 16;
      var $max_buffer_size = __stackBase__ + 20;
      var $raw = __stackBase__ + 24;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str35;
      
      HEAP[$kwlist + 4] = __str36;
      
      HEAP[$kwlist + 8] = __str55;
      
      HEAP[$kwlist + 12] = 0;
      HEAP[$buffer_size] = 8192;
      HEAP[$max_buffer_size] = -234;
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      var $kwlist1 = $kwlist;
      var $11 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str56, $kwlist1, allocate([ $raw, 0, 0, 0, $buffer_size, 0, 0, 0, $max_buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 17;
      break;
     case 2:
      
      var $14 = HEAP[$max_buffer_size] != -234;
      if ($14) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      var $15 = _complain_about_max_buffer_size();
      
      if ($15 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = -1;
      __label__ = 17;
      break;
     case 5:
      var $17 = HEAP[$raw];
      var $18 = __PyIOBase_check_writable($17, __Py_TrueStruct);
      
      if ($18 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = -1;
      __label__ = 17;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $32 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $32;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $43 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$43]($_py_tmp);
      __label__ = 10;
      break;
     case 10:
      
      
      
      var $48 = HEAP[HEAP[$raw]] + 1;
      var $49 = HEAP[$raw];
      HEAP[$49] = $48;
      var $50 = HEAP[$raw];
      
      
      HEAP[$self_addr + 8] = $50;
      
      
      HEAP[$self_addr + 20] = 0;
      
      
      HEAP[$self_addr + 24] = 1;
      var $57 = HEAP[$buffer_size];
      
      
      HEAP[$self_addr + 84] = $57;
      
      var $61 = __buffered_init($self_addr);
      
      if ($61 < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      $0 = -1;
      __label__ = 17;
      break;
     case 12:
      
      __bufferedwriter_reset_buf($self_addr);
      
      
      HEAP[$self_addr + 44] = 0;
      
      
      
      
      
      if (HEAP[$self_addr + 4] != _PyBufferedWriter_Type) {
        __label__ = 15;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      
      if (HEAP[HEAP[$raw] + 4] != _PyFileIO_Type) {
        __label__ = 15;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      $iftmp_217 = 1;
      __label__ = 16;
      break;
     case 15:
      $iftmp_217 = 0;
      __label__ = 16;
      break;
     case 16:
      
      
      
      HEAP[$self_addr + 28] = $iftmp_217;
      
      
      HEAP[$self_addr + 12] = 1;
      $0 = 0;
      __label__ = 17;
      break;
     case 17:
      
      $retval = $0;
      var $retval18 = $retval;
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedwriter_raw_write($self, $start, $len) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $start_addr;
      var $len_addr;
      var $retval;
      var $0;
      var $buf = __stackBase__;
      var $memobj;
      var $res;
      var $n;
      $self_addr = $self;
      $start_addr = $start;
      $len_addr = $len;
      
      
      var $3 = _PyBuffer_FillInfo($buf, 0, $start_addr, $len_addr, 1, 8);
      var $4 = $3 == -1;
      if ($4) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 19;
      break;
     case 2:
      var $5 = _PyMemoryView_FromBuffer($buf);
      $memobj = $5;
      
      
      if ($memobj == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = -1;
      __label__ = 19;
      break;
     case 4:
      var $8 = HEAP[__PyIO_str_write];
      
      
      var $11 = HEAP[$self_addr + 8];
      
      var $13 = _PyObject_CallMethodObjArgs($11, $8, allocate([ $memobj, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $13;
      
      if ($13 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      var $15 = __trap_eintr();
      
      if ($15 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      var $20 = HEAP[$memobj] - 1;
      
      
      HEAP[$memobj] = $20;
      
      
      
      
      if (HEAP[$memobj] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $31 = HEAP[HEAP[$memobj + 4] + 24];
      
      FUNCTION_TABLE[$31]($memobj);
      __label__ = 8;
      break;
     case 8:
      
      
      if ($res == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $0 = -1;
      __label__ = 19;
      break;
     case 10:
      var $35 = HEAP[_PyExc_ValueError];
      
      var $37 = _PyNumber_AsSsize_t($res, $35);
      $n = $37;
      
      
      
      var $41 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $41;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $52 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$52]($res);
      __label__ = 12;
      break;
     case 12:
      
      
      if ($n < 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      if ($n > $len_addr) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      var $59 = HEAP[_PyExc_IOError];
      
      
      var $62 = _PyErr_Format($59, __str57, allocate([ $n, 0, 0, 0, $len_addr, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = -1;
      __label__ = 19;
      break;
     case 15:
      
      
      if ($n > 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      
      var $68 = HEAP[$self_addr + 32] != -1;
      if ($68) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      
      var $74 = $n + HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = $74;
      __label__ = 18;
      break;
     case 18:
      
      $0 = $n;
      __label__ = 19;
      break;
     case 19:
      
      $retval = $0;
      var $retval19 = $retval;
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedwriter_flush_unlocked($self, $restore_pos) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $restore_pos_addr;
      var $retval;
      var $0;
      var $iftmp_223;
      var $written;
      var $n;
      var $rewind;
      var $w;
      var $forward;
      $self_addr = $self;
      $restore_pos_addr = $restore_pos;
      $written = 0;
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      var $8 = HEAP[$self_addr + 76] == -1;
      if ($8) {
        __label__ = 23;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 68] == HEAP[$self_addr + 76]) {
        __label__ = 23;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 4:
      
      
      
      var $23 = HEAP[$self_addr + 60] != -1;
      if ($23) {
        __label__ = 7;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      var $31 = HEAP[$self_addr + 76] != -1;
      if ($31) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 52] < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      $iftmp_223 = HEAP[$self_addr + 52] - HEAP[$self_addr + 44];
      __label__ = 10;
      break;
     case 9:
      $iftmp_223 = 0;
      __label__ = 10;
      break;
     case 10:
      
      
      
      
      
      
      
      
      
      $rewind = $iftmp_223 + (HEAP[$self_addr + 44] - HEAP[$self_addr + 68]);
      
      if ($iftmp_223 + (HEAP[$self_addr + 44] - HEAP[$self_addr + 68]) != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 11:
      
      
      
      var $56 = __buffered_raw_seek($self_addr, 0 - $rewind, 1);
      $n = $56;
      
      
      if ($n < 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      
      
      
      
      var $63 = HEAP[$self_addr + 52] - $rewind;
      
      
      HEAP[$self_addr + 52] = $63;
      __label__ = 17;
      break;
     case 13:
      
      
      
      
      
      
      
      
      var $74 = (HEAP[$self_addr + 76] & 4294967295) - (HEAP[$self_addr + 68] & 4294967295);
      
      
      
      
      
      
      
      var $82 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 68] & 4294967295);
      
      var $84 = __bufferedwriter_raw_write($self_addr, $82, $74);
      
      $n = $84;
      
      var $87 = $n == -1;
      if ($87) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      var $88 = __buffered_check_blocking_error();
      $w = $88;
      
      
      if ($w == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      
      
      
      var $97 = HEAP[$w] + HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 68] = $97;
      
      
      var $102 = HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 52] = $102;
      
      
      
      var $108 = $written + HEAP[$w];
      $written = $108;
      
      
      HEAP[$w] = $written;
      __label__ = 24;
      break;
     case 16:
      
      
      
      
      var $115 = $n + HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 68] = $115;
      
      
      var $120 = HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 52] = $120;
      
      
      
      var $126 = ($n & 4294967295) + $written;
      $written = $126;
      var $127 = _PyErr_CheckSignals();
      
      if ($127 < 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 68] < HEAP[$self_addr + 76]) {
        __label__ = 13;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      if ($restore_pos_addr != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 19:
      
      
      
      
      $forward = $rewind - $written;
      
      
      if ($forward != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 20:
      
      
      var $146 = __buffered_raw_seek($self_addr, $forward, 1);
      $n = $146;
      
      
      if ($n < 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      
      
      
      var $153 = $forward + HEAP[$self_addr + 52];
      
      
      HEAP[$self_addr + 52] = $153;
      __label__ = 22;
      break;
     case 22:
      
      __bufferedwriter_reset_buf($self_addr);
      __label__ = 23;
      break;
     case 23:
      
      var $158 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $158;
      $0 = __Py_NoneStruct;
      __label__ = 25;
      break;
     case 24:
      $0 = 0;
      __label__ = 25;
      break;
     case 25:
      
      $retval = $0;
      var $retval24 = $retval;
      return $retval24;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedwriter_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_229;
      var $iftmp_226;
      var $0;
      var $res;
      var $buf = __stackBase__;
      var $written;
      var $avail;
      var $remaining;
      var $offset;
      var $w;
      var $_py_tmp;
      var $n;
      var $w54;
      $self_addr = $self;
      $args_addr = $args;
      $res = 0;
      
      
      
      
      if (HEAP[$self_addr + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str12);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 74;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str58, allocate([ $buf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 74;
      break;
     case 7:
      
      
      
      
      var $17 = $self_addr;
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      var $19 = HEAP[$17 + 8];
      var $20 = __PyFileIO_closed($19);
      
      var $22 = $20 != 0;
      $iftmp_226 = $22;
      __lastLabel__ = 8;
      __label__ = 10;
      break;
     case 9:
      var $23 = _buffered_closed($17);
      
      var $25 = $23 != 0;
      $iftmp_226 = $25;
      __lastLabel__ = 9;
      __label__ = 10;
      break;
     case 10:
      var $26 = __lastLabel__ == 9 ? $25 : $22;
      
      if ($26 != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $27 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($27, __str59);
      _PyBuffer_Release($buf);
      $0 = 0;
      __label__ = 74;
      break;
     case 12:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      var $35 = HEAP[$self_addr + 60] == -1;
      if ($35) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      var $43 = HEAP[$self_addr + 76] == -1;
      if ($43) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      HEAP[$self_addr + 44] = 0;
      
      
      HEAP[$self_addr + 52] = 0;
      __label__ = 17;
      break;
     case 17:
      
      
      
      
      
      
      
      
      $avail = HEAP[$self_addr + 84] - (HEAP[$self_addr + 44] & 4294967295);
      
      
      
      
      if (HEAP[$buf + 8] <= $avail) {
        __label__ = 18;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 18:
      
      var $61 = HEAP[$buf + 8];
      
      var $63 = HEAP[$buf];
      
      
      
      
      
      
      
      var $71 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 44] & 4294967295);
      _llvm_memcpy_p0i8_p0i8_i32($71, $63, $61, 1, 0);
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      var $79 = HEAP[$self_addr + 76] == -1;
      if ($79) {
        __label__ = 21;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 20:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 68] > HEAP[$self_addr + 44]) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      var $89 = HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 68] = $89;
      __label__ = 22;
      break;
     case 22:
      
      
      
      
      
      
      var $98 = HEAP[$buf + 8] + HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 44] = $98;
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 23:
      
      
      
      var $108 = HEAP[$self_addr + 60] != -1;
      if ($108) {
        __label__ = 24;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 24:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 60] < HEAP[$self_addr + 44]) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      var $118 = HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 60] = $118;
      __label__ = 26;
      break;
     case 26:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 44] > HEAP[$self_addr + 76]) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      var $130 = HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 76] = $130;
      __label__ = 28;
      break;
     case 28:
      
      
      $written = HEAP[$buf + 8];
      __label__ = 72;
      break;
     case 29:
      
      var $136 = __bufferedwriter_flush_unlocked($self_addr, 0);
      $res = $136;
      
      
      if ($res == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 30:
      var $139 = __buffered_check_blocking_error();
      $w = $139;
      
      
      if ($w == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      __bufferedreader_reset_buf($self_addr);
      __label__ = 33;
      break;
     case 33:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 34:
      
      
      
      var $154 = HEAP[$self_addr + 76] == -1;
      if ($154) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      ___assert_fail(__str60, __str10, 1832, ___PRETTY_FUNCTION___10762);
      throw "Reached an unreachable!";
     case 36:
      
      
      
      
      
      
      
      
      var $163 = (HEAP[$self_addr + 76] & 4294967295) - (HEAP[$self_addr + 68] & 4294967295);
      
      
      
      
      
      
      
      var $171 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 68] & 4294967295);
      
      
      var $174 = HEAP[$self_addr + 40];
      _llvm_memmove_p0i8_p0i8_i32($174, $171, $163, 1, 0);
      
      
      
      
      
      
      var $181 = HEAP[$self_addr + 76] - HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 76] = $181;
      
      
      
      
      
      
      var $190 = HEAP[$self_addr + 52] - HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 52] = $190;
      
      
      
      
      
      
      var $199 = HEAP[$self_addr + 44] - HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 44] = $199;
      
      
      HEAP[$self_addr + 68] = 0;
      
      
      
      
      
      
      
      
      $avail = HEAP[$self_addr + 84] - (HEAP[$self_addr + 76] & 4294967295);
      
      
      
      
      if (HEAP[$buf + 8] <= $avail) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      _PyErr_Clear();
      
      var $217 = HEAP[$buf + 8];
      
      var $219 = HEAP[$buf];
      
      
      
      
      
      
      
      var $227 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 76] & 4294967295);
      _llvm_memcpy_p0i8_p0i8_i32($227, $219, $217, 1, 0);
      
      
      
      
      
      
      var $234 = HEAP[$buf + 8] + HEAP[$self_addr + 76];
      
      
      HEAP[$self_addr + 76] = $234;
      
      
      $written = HEAP[$buf + 8];
      __label__ = 72;
      break;
     case 38:
      
      
      var $241 = HEAP[$buf];
      
      
      
      
      
      
      
      var $249 = HEAP[$self_addr + 40] + (HEAP[$self_addr + 76] & 4294967295);
      _llvm_memcpy_p0i8_p0i8_i32($249, $241, $avail, 1, 0);
      
      
      
      
      
      var $255 = $avail + HEAP[$self_addr + 76];
      
      
      HEAP[$self_addr + 76] = $255;
      
      
      HEAP[$w] = $avail;
      __label__ = 73;
      break;
     case 39:
      
      
      if ($res != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $266 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $266;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $277 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$277]($_py_tmp);
      __label__ = 42;
      break;
     case 42:
      
      
      
      
      if (HEAP[$self_addr + 20] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 43:
      
      
      
      var $286 = HEAP[$self_addr + 60] != -1;
      if ($286) {
        __label__ = 46;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      
      
      var $294 = HEAP[$self_addr + 76] != -1;
      if ($294) {
        __label__ = 46;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 46:
      
      
      
      
      if (HEAP[$self_addr + 52] < 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      $iftmp_229 = 0;
      $offset = 0;
      __label__ = 51;
      break;
     case 48:
      
      
      
      
      
      
      
      $iftmp_229 = HEAP[$self_addr + 52] - HEAP[$self_addr + 44];
      $offset = HEAP[$self_addr + 52] - HEAP[$self_addr + 44];
      
      if (HEAP[$self_addr + 52] - HEAP[$self_addr + 44] != 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 49:
      
      
      
      var $310 = __buffered_raw_seek($self_addr, 0 - $offset, 1);
      
      if ($310 < 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      
      
      
      var $316 = HEAP[$self_addr + 52] - $offset;
      
      
      HEAP[$self_addr + 52] = $316;
      __label__ = 51;
      break;
     case 51:
      
      
      $remaining = HEAP[$buf + 8];
      $written = 0;
      var $321 = $buf + 8;
      var $322 = $buf;
      __label__ = 62;
      break;
     case 52:
      
      
      var $325 = HEAP[$321] - $written;
      
      
      var $328 = HEAP[$322] + $written;
      
      var $330 = __bufferedwriter_raw_write($self_addr, $328, $325);
      $n = $330;
      
      var $332 = $n == -1;
      if ($332) {
        __label__ = 53;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 53:
      var $333 = __buffered_check_blocking_error();
      $w54 = $333;
      
      
      if ($w54 == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 54:
      
      
      
      var $339 = $written + HEAP[$w54];
      $written = $339;
      
      
      
      var $343 = $remaining - HEAP[$w54];
      $remaining = $343;
      
      
      
      
      
      if (HEAP[$self_addr + 84] < $remaining) {
        __label__ = 55;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 55:
      
      
      var $351 = HEAP[$self_addr + 84];
      
      
      
      var $355 = HEAP[$buf] + $written;
      
      
      var $358 = HEAP[$self_addr + 40];
      _llvm_memcpy_p0i8_p0i8_i32($358, $355, $351, 1, 0);
      
      
      HEAP[$self_addr + 52] = 0;
      
      
      
      var $364 = HEAP[$self_addr + 84];
      
      
      HEAP[$self_addr + 44] = $364;
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 56:
      
      
      
      var $374 = HEAP[$self_addr + 60] != -1;
      if ($374) {
        __label__ = 57;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 57:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 60] < HEAP[$self_addr + 44]) {
        __label__ = 58;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 58:
      
      
      var $384 = HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 60] = $384;
      __label__ = 59;
      break;
     case 59:
      
      
      
      var $390 = HEAP[$self_addr + 84];
      
      
      HEAP[$self_addr + 76] = $390;
      
      
      
      
      var $397 = $written + HEAP[$self_addr + 84];
      
      HEAP[$w54] = $397;
      __label__ = 73;
      break;
     case 60:
      _PyErr_Clear();
      __label__ = 63;
      break;
     case 61:
      
      
      var $401 = $n + $written;
      $written = $401;
      
      
      var $404 = $remaining - $n;
      $remaining = $404;
      var $405 = _PyErr_CheckSignals();
      
      if ($405 < 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      
      
      
      
      
      if (HEAP[$self_addr + 84] < $remaining) {
        __label__ = 52;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 63:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 64:
      
      __bufferedreader_reset_buf($self_addr);
      __label__ = 65;
      break;
     case 65:
      
      
      if ($remaining > 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      
      
      
      
      var $423 = HEAP[$buf] + $written;
      
      
      var $426 = HEAP[$self_addr + 40];
      _llvm_memcpy_p0i8_p0i8_i32($426, $423, $remaining, 1, 0);
      
      
      var $429 = $remaining + $written;
      $written = $429;
      __label__ = 67;
      break;
     case 67:
      
      
      HEAP[$self_addr + 68] = 0;
      
      
      
      
      HEAP[$self_addr + 76] = $remaining;
      
      
      
      
      HEAP[$self_addr + 44] = $remaining;
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 68:
      
      
      
      var $447 = HEAP[$self_addr + 60] != -1;
      if ($447) {
        __label__ = 69;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 69:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 60] < HEAP[$self_addr + 44]) {
        __label__ = 70;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 70:
      
      
      var $457 = HEAP[$self_addr + 44];
      
      
      HEAP[$self_addr + 60] = $457;
      __label__ = 71;
      break;
     case 71:
      
      
      HEAP[$self_addr + 52] = 0;
      __label__ = 72;
      break;
     case 72:
      
      var $463 = _PyLong_FromSsize_t($written);
      $res = $463;
      __label__ = 73;
      break;
     case 73:
      _PyBuffer_Release($buf);
      
      $0 = $res;
      __label__ = 74;
      break;
     case 74:
      
      $retval = $0;
      var $retval74 = $retval;
      STACKTOP = __stackBase__;
      return $retval74;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $reader = __stackBase__;
      var $writer = __stackBase__ + 4;
      var $buffer_size = __stackBase__ + 8;
      var $max_buffer_size = __stackBase__ + 12;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      HEAP[$buffer_size] = 8192;
      HEAP[$max_buffer_size] = -234;
      
      var $2 = __PyArg_ParseTuple_SizeT($args_addr, __str62, allocate([ $reader, 0, 0, 0, $writer, 0, 0, 0, $buffer_size, 0, 0, 0, $max_buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 17;
      break;
     case 2:
      
      var $5 = HEAP[$max_buffer_size] != -234;
      if ($5) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      var $6 = _complain_about_max_buffer_size();
      
      if ($6 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = -1;
      __label__ = 17;
      break;
     case 5:
      var $8 = HEAP[$reader];
      var $9 = __PyIOBase_check_readable($8, __Py_TrueStruct);
      
      if ($9 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = -1;
      __label__ = 17;
      break;
     case 7:
      var $11 = HEAP[$writer];
      var $12 = __PyIOBase_check_writable($11, __Py_TrueStruct);
      
      if ($12 == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = -1;
      __label__ = 17;
      break;
     case 9:
      var $14 = HEAP[$buffer_size];
      var $15 = HEAP[$reader];
      var $16 = __PyObject_CallFunction_SizeT(_PyBufferedReader_Type, __str63, allocate([ $15, 0, 0, 0, $14, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      var $17 = $16;
      
      
      HEAP[$self_addr + 8] = $17;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      $0 = -1;
      __label__ = 17;
      break;
     case 11:
      var $24 = HEAP[$buffer_size];
      var $25 = HEAP[$writer];
      var $26 = __PyObject_CallFunction_SizeT(_PyBufferedWriter_Type, __str63, allocate([ $25, 0, 0, 0, $24, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      var $27 = $26;
      
      
      HEAP[$self_addr + 12] = $27;
      
      
      
      
      if (HEAP[$self_addr + 12] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 12:
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $47 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $47;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $58 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$58]($_py_tmp);
      __label__ = 15;
      break;
     case 15:
      $0 = -1;
      __label__ = 17;
      break;
     case 16:
      $0 = 0;
      __label__ = 17;
      break;
     case 17:
      
      $retval = $0;
      var $retval17 = $retval;
      STACKTOP = __stackBase__;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_traverse($self, $visit, $arg) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $visit_addr;
      var $arg_addr;
      var $retval;
      var $0;
      var $vret;
      $self_addr = $self;
      $visit_addr = $visit;
      $arg_addr = $arg;
      
      
      
      
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 16];
      var $8 = $visit_addr;
      
      var $10 = FUNCTION_TABLE[$8]($7, $arg_addr);
      $vret = $10;
      
      
      if ($vret != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      $0 = $vret;
      __label__ = 4;
      break;
     case 3:
      $0 = 0;
      __label__ = 4;
      break;
     case 4:
      
      $retval = $0;
      var $retval4 = $retval;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      var $_py_tmp4;
      var $_py_tmp8;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $14 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $14;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $25 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$25]($_py_tmp);
      __label__ = 3;
      break;
     case 3:
      
      
      
      
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      
      
      $_py_tmp4 = HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      
      var $40 = HEAP[$_py_tmp4] - 1;
      
      
      HEAP[$_py_tmp4] = $40;
      
      
      
      
      if (HEAP[$_py_tmp4] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $51 = HEAP[HEAP[$_py_tmp4 + 4] + 24];
      
      FUNCTION_TABLE[$51]($_py_tmp4);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      $_py_tmp8 = HEAP[$self_addr + 16];
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      
      var $65 = HEAP[$_py_tmp8] - 1;
      
      
      HEAP[$_py_tmp8] = $65;
      
      
      
      
      if (HEAP[$_py_tmp8] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $76 = HEAP[HEAP[$_py_tmp8 + 4] + 24];
      
      FUNCTION_TABLE[$76]($_py_tmp8);
      __label__ = 9;
      break;
     case 9:
      $0 = 0;
      
      $retval = $0;
      var $retval11 = $retval;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $g;
      var $_py_tmp;
      var $_py_tmp6;
      var $_py_tmp10;
      $self_addr = $self;
      
      
      var $2 = $self_addr + -12;
      $g = $2;
      
      
      
      
      var $7 = HEAP[$g + 8] == -2;
      if ($7) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str9, __str10, 2084, ___PRETTY_FUNCTION___11129);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      HEAP[$g + 8] = -2;
      
      
      
      
      
      
      
      var $18 = HEAP[$g];
      
      var $20 = HEAP[$g + 4];
      HEAP[$20] = $18;
      
      
      
      
      
      
      
      var $28 = HEAP[$g + 4];
      
      var $30 = HEAP[$g] + 4;
      HEAP[$30] = $28;
      
      
      
      HEAP[$g] = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $47 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $47;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $58 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$58]($_py_tmp);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      
      
      $_py_tmp6 = HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      
      var $73 = HEAP[$_py_tmp6] - 1;
      
      
      HEAP[$_py_tmp6] = $73;
      
      
      
      
      if (HEAP[$_py_tmp6] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $84 = HEAP[HEAP[$_py_tmp6 + 4] + 24];
      
      FUNCTION_TABLE[$84]($_py_tmp6);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 9:
      
      
      
      $_py_tmp10 = HEAP[$self_addr + 16];
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      
      var $98 = HEAP[$_py_tmp10] - 1;
      
      
      HEAP[$_py_tmp10] = $98;
      
      
      
      
      if (HEAP[$_py_tmp10] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $109 = HEAP[HEAP[$_py_tmp10 + 4] + 24];
      
      FUNCTION_TABLE[$109]($_py_tmp10);
      __label__ = 11;
      break;
     case 11:
      
      
      
      
      
      var $116 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$116]($self_addr);
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __forward_call($self, $name, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $name_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $func;
      var $ret;
      $self_addr = $self;
      $name_addr = $name;
      $args_addr = $args;
      
      
      
      var $4 = _PyObject_GetAttrString($self_addr, $name_addr);
      $func = $4;
      
      
      if ($func == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $7 = HEAP[_PyExc_AttributeError];
      
      _PyErr_SetString($7, $name_addr);
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      var $11 = _PyObject_CallObject($func, $args_addr);
      $ret = $11;
      
      
      
      var $15 = HEAP[$func] - 1;
      
      
      HEAP[$func] = $15;
      
      
      
      
      if (HEAP[$func] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $26 = HEAP[HEAP[$func + 4] + 24];
      
      FUNCTION_TABLE[$26]($func);
      __label__ = 4;
      break;
     case 4:
      
      $0 = $ret;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_read($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 8];
    
    var $5 = __forward_call($3, __str1, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_peek($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 8];
    
    var $5 = __forward_call($3, __str47, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_read1($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 8];
    
    var $5 = __forward_call($3, __str5, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_readinto($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 8];
    
    var $5 = __forward_call($3, __str7, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_write($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 12];
    
    var $5 = __forward_call($3, __str6, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_flush($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 12];
    
    var $5 = __forward_call($3, __str40, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_readable($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 8];
    
    var $5 = __forward_call($3, __str43, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_writable($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    
    var $3 = HEAP[$self_addr + 12];
    
    var $5 = __forward_call($3, __str44, $args_addr);
    $0 = $5;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrwpair_close($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $ret;
      $self_addr = $self;
      $args_addr = $args;
      
      
      var $3 = HEAP[$self_addr + 12];
      
      var $5 = __forward_call($3, __str41, $args_addr);
      $ret = $5;
      
      
      if ($ret == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      var $11 = HEAP[$ret] - 1;
      
      
      HEAP[$ret] = $11;
      
      
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $22 = HEAP[HEAP[$ret + 4] + 24];
      
      FUNCTION_TABLE[$22]($ret);
      __label__ = 4;
      break;
     case 4:
      
      
      var $26 = HEAP[$self_addr + 8];
      
      var $28 = __forward_call($26, __str41, $args_addr);
      $0 = $28;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_isatty($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $ret;
      $self_addr = $self;
      $args_addr = $args;
      
      
      var $3 = HEAP[$self_addr + 12];
      
      var $5 = __forward_call($3, __str46, $args_addr);
      $ret = $5;
      
      
      var $8 = $ret;
      if ($ret != __Py_ZeroStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = $8;
      __label__ = 5;
      break;
     case 2:
      
      
      var $11 = HEAP[$8] - 1;
      
      
      HEAP[$ret] = $11;
      
      
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $22 = HEAP[HEAP[$ret + 4] + 24];
      
      FUNCTION_TABLE[$22]($ret);
      __label__ = 4;
      break;
     case 4:
      
      
      var $26 = HEAP[$self_addr + 8];
      
      var $28 = __forward_call($26, __str46, $args_addr);
      $0 = $28;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_closed_get($self, $context) {
    
    var $self_addr;
    var $context_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $context_addr = $context;
    var $1 = HEAP[__PyIO_str_closed];
    
    
    
    var $5 = HEAP[$self_addr + 12];
    var $6 = _PyObject_GetAttr($5, $1);
    $0 = $6;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bufferedrandom_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $iftmp_259;
      var $0;
      var $kwlist = __stackBase__;
      var $buffer_size = __stackBase__ + 16;
      var $max_buffer_size = __stackBase__ + 20;
      var $raw = __stackBase__ + 24;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str35;
      
      HEAP[$kwlist + 4] = __str36;
      
      HEAP[$kwlist + 8] = __str55;
      
      HEAP[$kwlist + 12] = 0;
      HEAP[$buffer_size] = 8192;
      HEAP[$max_buffer_size] = -234;
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      var $kwlist1 = $kwlist;
      var $11 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str56, $kwlist1, allocate([ $raw, 0, 0, 0, $buffer_size, 0, 0, 0, $max_buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 21;
      break;
     case 2:
      
      var $14 = HEAP[$max_buffer_size] != -234;
      if ($14) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      var $15 = _complain_about_max_buffer_size();
      
      if ($15 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = -1;
      __label__ = 21;
      break;
     case 5:
      var $17 = HEAP[$raw];
      var $18 = __PyIOBase_check_seekable($17, __Py_TrueStruct);
      
      if ($18 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = -1;
      __label__ = 21;
      break;
     case 7:
      var $20 = HEAP[$raw];
      var $21 = __PyIOBase_check_readable($20, __Py_TrueStruct);
      
      if ($21 == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = -1;
      __label__ = 21;
      break;
     case 9:
      var $23 = HEAP[$raw];
      var $24 = __PyIOBase_check_writable($23, __Py_TrueStruct);
      
      if ($24 == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      $0 = -1;
      __label__ = 21;
      break;
     case 11:
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 12:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $38 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $38;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $49 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$49]($_py_tmp);
      __label__ = 14;
      break;
     case 14:
      
      
      
      var $54 = HEAP[HEAP[$raw]] + 1;
      var $55 = HEAP[$raw];
      HEAP[$55] = $54;
      var $56 = HEAP[$raw];
      
      
      HEAP[$self_addr + 8] = $56;
      var $59 = HEAP[$buffer_size];
      
      
      HEAP[$self_addr + 84] = $59;
      
      
      HEAP[$self_addr + 20] = 1;
      
      
      HEAP[$self_addr + 24] = 1;
      
      var $67 = __buffered_init($self_addr);
      
      if ($67 < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      $0 = -1;
      __label__ = 21;
      break;
     case 16:
      
      __bufferedreader_reset_buf($self_addr);
      
      __bufferedwriter_reset_buf($self_addr);
      
      
      HEAP[$self_addr + 44] = 0;
      
      
      
      
      
      if (HEAP[$self_addr + 4] != _PyBufferedRandom_Type) {
        __label__ = 19;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      if (HEAP[HEAP[$raw] + 4] != _PyFileIO_Type) {
        __label__ = 19;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      $iftmp_259 = 1;
      __label__ = 20;
      break;
     case 19:
      $iftmp_259 = 0;
      __label__ = 20;
      break;
     case 20:
      
      
      
      HEAP[$self_addr + 28] = $iftmp_259;
      
      
      HEAP[$self_addr + 12] = 1;
      $0 = 0;
      __label__ = 21;
      break;
     case 21:
      
      $retval = $0;
      var $retval22 = $retval;
      STACKTOP = __stackBase__;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _get_line($self, $output) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $output_addr;
      var $retval;
      var $0;
      var $n;
      var $str_end;
      var $len;
      $self_addr = $self;
      $output_addr = $output;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str66, __str167, 32, ___PRETTY_FUNCTION___8438);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      
      
      
      $str_end = HEAP[$self_addr + 8] + HEAP[$self_addr + 16];
      
      
      
      
      
      
      
      $n = HEAP[$self_addr + 8] + HEAP[$self_addr + 12];
      __label__ = 4;
      break;
     case 3:
      
      var $20 = $n + 1;
      $n = $20;
      __label__ = 4;
      break;
     case 4:
      
      
      
      if ($n >= $str_end) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      if (HEAP[$n] != 10) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      if ($n < $str_end) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      var $31 = $n + 1;
      $n = $31;
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      
      
      
      
      
      
      $len = $n - (HEAP[$self_addr + 8] + HEAP[$self_addr + 12]);
      
      
      
      
      
      
      var $49 = HEAP[$self_addr + 8] + HEAP[$self_addr + 12];
      
      HEAP[$output_addr] = $49;
      
      
      if ($len < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      ___assert_fail(__str268, __str167, 48, ___PRETTY_FUNCTION___8438);
      throw "Reached an unreachable!";
     case 10:
      
      
      
      
      
      
      if (HEAP[$self_addr + 12] >= 2147483647 - $len) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      ___assert_fail(__str369, __str167, 49, ___PRETTY_FUNCTION___8438);
      throw "Reached an unreachable!";
     case 12:
      
      
      
      
      var $63 = $len + HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = $63;
      
      $0 = $len;
      
      $retval = $0;
      var $retval12 = $retval;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _resize_buffer($self, $size) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $size_addr;
      var $retval;
      var $iftmp_2;
      var $0;
      var $alloc;
      var $new_buf;
      $self_addr = $self;
      $size_addr = $size;
      
      
      
      $alloc = HEAP[$self_addr + 20];
      $new_buf = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str66, __str167, 66, ___PRETTY_FUNCTION___8477);
      throw "Reached an unreachable!";
     case 2:
      
      
      if ($size_addr < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      var $11 = Math.floor($alloc / 2);
      
      
      var $14 = $size_addr;
      if ($11 > $size_addr) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      $alloc = $14 + 1;
      __label__ = 13;
      break;
     case 5:
      
      
      if ($14 < $alloc) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 17;
      break;
     case 7:
      
      
      
      
      
      
      var $24 = $size_addr;
      if ($size_addr <= $alloc * 1.125) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      var $25 = $24 >>> 3;
      var $26 = $size_addr;
      
      
      if ($size_addr <= 8) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $iftmp_2 = 3;
      __label__ = 11;
      break;
     case 10:
      $iftmp_2 = 6;
      __label__ = 11;
      break;
     case 11:
      
      
      
      $alloc = $26 + $25 + $iftmp_2;
      __label__ = 13;
      break;
     case 12:
      
      $alloc = $24 + 1;
      __label__ = 13;
      break;
     case 13:
      
      
      var $35 = HEAP[$self_addr + 8];
      
      var $37 = _PyMem_Realloc($35, $alloc);
      $new_buf = $37;
      
      if ($37 == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      var $39 = _PyErr_NoMemory();
      $0 = -1;
      __label__ = 17;
      break;
     case 15:
      
      
      
      HEAP[$self_addr + 20] = $alloc;
      
      
      
      HEAP[$self_addr + 8] = $new_buf;
      $0 = 0;
      __label__ = 17;
      break;
     case 16:
      var $46 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($46, __str470);
      $0 = -1;
      __label__ = 17;
      break;
     case 17:
      
      $retval = $0;
      var $retval16 = $retval;
      return $retval16;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _write_bytes($self, $bytes, $len) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $bytes_addr;
      var $len_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $bytes_addr = $bytes;
      $len_addr = $len;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str66, __str167, 113, ___PRETTY_FUNCTION___8514);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 12] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str571, __str167, 114, ___PRETTY_FUNCTION___8514);
      throw "Reached an unreachable!";
     case 4:
      
      
      if ($len_addr < 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      ___assert_fail(__str268, __str167, 115, ___PRETTY_FUNCTION___8514);
      throw "Reached an unreachable!";
     case 6:
      
      
      
      
      
      
      
      
      
      if ($len_addr + HEAP[$self_addr + 12] > HEAP[$self_addr + 20]) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      
      var $24 = $len_addr + HEAP[$self_addr + 12];
      
      var $26 = _resize_buffer($self_addr, $24);
      
      if ($26 < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = -1;
      __label__ = 14;
      break;
     case 9:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 12] > HEAP[$self_addr + 16]) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      
      
      var $41 = HEAP[$self_addr + 12] - HEAP[$self_addr + 16];
      
      
      
      
      
      
      var $48 = HEAP[$self_addr + 8] + HEAP[$self_addr + 16];
      _llvm_memset_p0i8_i32($48, 0, $41, 1, 0);
      __label__ = 11;
      break;
     case 11:
      
      
      
      
      
      
      
      var $56 = HEAP[$self_addr + 8] + HEAP[$self_addr + 12];
      
      _llvm_memcpy_p0i8_p0i8_i32($56, $bytes_addr, $len_addr, 1, 0);
      
      
      
      
      var $62 = $len_addr + HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = $62;
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 16] < HEAP[$self_addr + 12]) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      var $74 = HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 16] = $74;
      __label__ = 13;
      break;
     case 13:
      
      $0 = $len_addr;
      __label__ = 14;
      break;
     case 14:
      
      $retval = $0;
      var $retval14 = $retval;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_get_closed($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $6 = HEAP[__Py_TrueStruct] + 1;
      HEAP[__Py_TrueStruct] = $6;
      $0 = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 2:
      
      var $8 = HEAP[__Py_ZeroStruct] + 1;
      HEAP[__Py_ZeroStruct] = $8;
      $0 = __Py_ZeroStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _return_true($self) {
    
    var $retval;
    var $0;
    
    var $2 = HEAP[__Py_TrueStruct] + 1;
    HEAP[__Py_TrueStruct] = $2;
    $0 = __Py_TrueStruct;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _bytesio_flush($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $7 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $7;
      $0 = __Py_NoneStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_getvalue($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[$self_addr + 16];
      
      
      var $11 = HEAP[$self_addr + 8];
      var $12 = _PyString_FromStringAndSize($11, $8);
      $0 = $12;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_isatty($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $7 = HEAP[__Py_ZeroStruct] + 1;
      HEAP[__Py_ZeroStruct] = $7;
      $0 = __Py_ZeroStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_tell($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[$self_addr + 12];
      var $9 = _PyLong_FromSsize_t($8);
      $0 = $9;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $size;
      var $n;
      var $output;
      var $arg = __stackBase__;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 18;
      break;
     case 2:
      
      var $7 = _PyArg_ParseTuple($args_addr, __str773, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 18;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      $size = $14;
      
      var $16 = $size == -1;
      if ($16) {
        __label__ = 6;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      $0 = 0;
      __label__ = 18;
      break;
     case 8:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $size = -1;
      __label__ = 11;
      break;
     case 10:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str874, allocate([ $25, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 18;
      break;
     case 11:
      
      
      
      
      
      
      var $34 = HEAP[$self_addr + 16] - HEAP[$self_addr + 12];
      $n = $34;
      
      
      if ($size < 0) {
        __lastLabel__ = 11;
        __label__ = 13;
        break;
      } else {
        __lastLabel__ = 11;
        __label__ = 12;
        break;
      }
     case 12:
      
      var $38 = $n;
      
      if ($size > $38) {
        __lastLabel__ = 12;
        __label__ = 13;
        break;
      } else {
        __lastLabel__ = 12;
        __label__ = 15;
        break;
      }
     case 13:
      var $40 = __lastLabel__ == 12 ? $38 : $34;
      $size = $40;
      
      if ($40 < 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      $size = 0;
      __label__ = 15;
      break;
     case 15:
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      ___assert_fail(__str66, __str167, 252, ___PRETTY_FUNCTION___8642);
      throw "Reached an unreachable!";
     case 17:
      
      
      
      
      
      
      
      $output = HEAP[$self_addr + 8] + HEAP[$self_addr + 12];
      
      
      
      
      var $57 = $size + HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = $57;
      
      
      var $62 = _PyString_FromStringAndSize($output, $size);
      $0 = $62;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval19 = $retval;
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_read1($self, $n) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $n_addr;
      var $retval;
      var $0;
      var $arg;
      var $res;
      $self_addr = $self;
      $n_addr = $n;
      
      var $2 = _PyTuple_Pack(1, allocate([ $n_addr, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      $arg = $2;
      
      
      if ($arg == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      var $7 = _bytesio_read($self_addr, $arg);
      $res = $7;
      
      
      
      var $11 = HEAP[$arg] - 1;
      
      
      HEAP[$arg] = $11;
      
      
      
      
      if (HEAP[$arg] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $22 = HEAP[HEAP[$arg + 4] + 24];
      
      FUNCTION_TABLE[$22]($arg);
      __label__ = 4;
      break;
     case 4:
      
      $0 = $res;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $size;
      var $n;
      var $output = __stackBase__;
      var $arg = __stackBase__ + 4;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 15;
      break;
     case 2:
      
      var $7 = _PyArg_ParseTuple($args_addr, __str975, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 15;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      $size = $14;
      
      var $16 = $size == -1;
      if ($16) {
        __label__ = 6;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      $0 = 0;
      __label__ = 15;
      break;
     case 8:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $size = -1;
      __label__ = 11;
      break;
     case 10:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str874, allocate([ $25, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 15;
      break;
     case 11:
      
      var $29 = _get_line($self_addr, $output);
      $n = $29;
      
      
      if ($size >= 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 12:
      
      
      
      if ($size < $n) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      var $37 = $n - $size;
      $size = $37;
      
      
      var $40 = $n - $size;
      $n = $40;
      
      
      
      
      var $45 = HEAP[$self_addr + 12] - $size;
      
      
      HEAP[$self_addr + 12] = $45;
      __label__ = 14;
      break;
     case 14:
      var $48 = HEAP[$output];
      
      var $50 = _PyString_FromStringAndSize($48, $n);
      $0 = $50;
      __label__ = 15;
      break;
     case 15:
      
      $retval = $0;
      var $retval16 = $retval;
      STACKTOP = __stackBase__;
      return $retval16;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_readlines($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $maxsize;
      var $size;
      var $n;
      var $result;
      var $line;
      var $output = __stackBase__;
      var $arg = __stackBase__ + 4;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 26;
      break;
     case 2:
      
      var $7 = _PyArg_ParseTuple($args_addr, __str1076, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 26;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      $maxsize = $14;
      
      var $16 = $maxsize == -1;
      if ($16) {
        __label__ = 6;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      $0 = 0;
      __label__ = 26;
      break;
     case 8:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $maxsize = -1;
      __label__ = 11;
      break;
     case 10:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str874, allocate([ $25, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 26;
      break;
     case 11:
      $size = 0;
      var $28 = _PyList_New(0);
      $result = $28;
      
      if ($28 == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 12:
      $0 = 0;
      __label__ = 26;
      break;
     case 13:
      var $30 = HEAP[$output];
      
      var $32 = _PyString_FromStringAndSize($30, $n);
      $line = $32;
      
      
      if ($line == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      var $37 = _PyList_Append($result, $line);
      var $38 = $37 == -1;
      
      
      
      var $42 = HEAP[$line] - 1;
      
      
      HEAP[$line] = $42;
      
      
      
      var $48 = HEAP[$line] == 0;
      if ($38) {
        __label__ = 15;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 15:
      if ($48) {
        __label__ = 16;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 16:
      
      
      
      
      var $53 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$53]($line);
      __label__ = 23;
      break;
     case 17:
      if ($48) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $59 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$59]($line);
      __label__ = 19;
      break;
     case 19:
      
      
      var $63 = $n + $size;
      $size = $63;
      
      
      if ($maxsize > 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      if ($size >= $maxsize) {
        __label__ = 22;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      var $70 = _get_line($self_addr, $output);
      $n = $70;
      
      if ($70 != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      $0 = $result;
      __label__ = 26;
      break;
     case 23:
      
      
      
      var $76 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $76;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      
      
      var $87 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$87]($result);
      __label__ = 25;
      break;
     case 25:
      $0 = 0;
      __label__ = 26;
      break;
     case 26:
      
      $retval = $0;
      var $retval28 = $retval;
      STACKTOP = __stackBase__;
      return $retval28;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $buf = __stackBase__;
      var $len;
      var $n;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 12;
      break;
     case 2:
      
      var $7 = _PyArg_ParseTuple($args_addr, __str1177, allocate([ $buf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 12;
      break;
     case 4:
      
      
      $len = HEAP[$buf + 8];
      
      
      
      
      
      
      
      $n = HEAP[$self_addr + 16] - HEAP[$self_addr + 12];
      
      
      
      if ($len > $n) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      $len = $n;
      
      
      if ($len < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $len = 0;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      
      
      
      var $31 = HEAP[$self_addr + 8] + HEAP[$self_addr + 12];
      
      var $33 = HEAP[$buf];
      _llvm_memcpy_p0i8_p0i8_i32($33, $31, $len, 1, 0);
      
      
      
      
      
      
      if ($len + HEAP[$self_addr + 12] == 2147483647) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      ___assert_fail(__str1278, __str167, 411, ___PRETTY_FUNCTION___8844);
      throw "Reached an unreachable!";
     case 9:
      
      
      if ($len < 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      ___assert_fail(__str268, __str167, 412, ___PRETTY_FUNCTION___8844);
      throw "Reached an unreachable!";
     case 11:
      
      
      
      
      var $46 = $len + HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = $46;
      _PyBuffer_Release($buf);
      
      var $50 = _PyLong_FromSsize_t($len);
      $0 = $50;
      __label__ = 12;
      break;
     case 12:
      
      $retval = $0;
      var $retval12 = $retval;
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $size;
      var $arg = __stackBase__;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 18;
      break;
     case 2:
      
      var $7 = _PyArg_ParseTuple($args_addr, __str31, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 18;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      $size = $14;
      var $15 = $size;
      var $16 = $15 == -1;
      if ($16) {
        __lastLabel__ = 5;
        __label__ = 6;
        break;
      } else {
        __lastLabel__ = 5;
        __label__ = 12;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      $0 = 0;
      __label__ = 18;
      break;
     case 8:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      var $23 = HEAP[$self_addr + 12];
      $size = $23;
      __lastLabel__ = 9;
      __label__ = 12;
      break;
     case 10:
      
      
      
      
      var $28 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $29 = HEAP[_PyExc_TypeError];
      var $30 = _PyErr_Format($29, __str874, allocate([ $28, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 18;
      break;
     case 11:
      var $_pr = $size;
      __lastLabel__ = 11;
      __label__ = 12;
      break;
     case 12:
      var $31 = __lastLabel__ == 11 ? $_pr : __lastLabel__ == 5 ? $15 : $23;
      
      if ($31 < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      var $33 = HEAP[_PyExc_ValueError];
      
      var $35 = _PyErr_Format($33, __str1480, allocate([ $size, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 18;
      break;
     case 14:
      
      
      
      
      
      if (HEAP[$self_addr + 16] > $size) {
        __label__ = 15;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 15:
      
      
      
      HEAP[$self_addr + 16] = $size;
      
      
      var $46 = _resize_buffer($self_addr, $size);
      
      if ($46 < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      $0 = 0;
      __label__ = 18;
      break;
     case 17:
      
      var $49 = _PyLong_FromSsize_t($size);
      $0 = $49;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval18 = $retval;
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_iternext($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $next = __stackBase__;
      var $n;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 6;
      break;
     case 2:
      
      var $7 = _get_line($self_addr, $next);
      $n = $7;
      
      
      if (HEAP[$next] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      if ($n == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $12 = HEAP[$next];
      
      var $14 = _PyString_FromStringAndSize($12, $n);
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $posobj = __stackBase__;
      var $pos;
      var $mode = __stackBase__ + 4;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$mode] = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 24;
      break;
     case 2:
      
      var $7 = _PyArg_ParseTuple($args_addr, __str28, allocate([ $posobj, 0, 0, 0, $mode, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 24;
      break;
     case 4:
      var $9 = HEAP[_PyExc_OverflowError];
      var $10 = HEAP[$posobj];
      var $11 = _PyNumber_AsSsize_t($10, $9);
      $pos = $11;
      var $12 = $pos;
      var $13 = $12 == -1;
      if ($13) {
        __lastLabel__ = 4;
        __label__ = 5;
        break;
      } else {
        __lastLabel__ = 4;
        __label__ = 8;
        break;
      }
     case 5:
      var $14 = _PyErr_Occurred();
      
      if ($14 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 24;
      break;
     case 7:
      var $_pr = $pos;
      __lastLabel__ = 7;
      __label__ = 8;
      break;
     case 8:
      var $16 = __lastLabel__ == 7 ? $_pr : $12;
      
      var $18 = HEAP[$mode];
      
      
      if ($16 < 0 & $18 == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      var $20 = HEAP[_PyExc_ValueError];
      
      var $22 = _PyErr_Format($20, __str1682, allocate([ $pos, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 24;
      break;
     case 10:
      
      if ($18 == 1) {
        __label__ = 11;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 11:
      
      
      
      
      
      
      if (2147483647 - HEAP[$self_addr + 12] < $pos) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      var $30 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($30, __str1783);
      $0 = 0;
      __label__ = 24;
      break;
     case 13:
      
      
      
      
      var $35 = $pos + HEAP[$self_addr + 12];
      $pos = $35;
      __lastLabel__ = 13;
      __label__ = 21;
      break;
     case 14:
      
      
      if (HEAP[$mode] == 2) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      
      
      
      
      
      
      if (2147483647 - HEAP[$self_addr + 16] < $pos) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      var $44 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($44, __str1783);
      $0 = 0;
      __label__ = 24;
      break;
     case 17:
      
      
      
      
      var $49 = $pos + HEAP[$self_addr + 16];
      $pos = $49;
      __lastLabel__ = 17;
      __label__ = 21;
      break;
     case 18:
      
      
      if (HEAP[$mode] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      var $52 = HEAP[$mode];
      var $53 = HEAP[_PyExc_ValueError];
      var $54 = _PyErr_Format($53, __str1884, allocate([ $52, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 24;
      break;
     case 20:
      var $_pr2 = $pos;
      __lastLabel__ = 20;
      __label__ = 21;
      break;
     case 21:
      var $55 = __lastLabel__ == 20 ? $_pr2 : __lastLabel__ == 17 ? $49 : $35;
      
      if ($55 < 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      $pos = 0;
      __label__ = 23;
      break;
     case 23:
      
      
      
      HEAP[$self_addr + 12] = $pos;
      
      
      var $62 = HEAP[$self_addr + 12];
      var $63 = _PyLong_FromSsize_t($62);
      $0 = $63;
      __label__ = 24;
      break;
     case 24:
      
      $retval = $0;
      var $retval23 = $retval;
      STACKTOP = __stackBase__;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_write($self, $obj) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $obj_addr;
      var $retval;
      var $0;
      var $n;
      var $buf = __stackBase__;
      var $result;
      $self_addr = $self;
      $obj_addr = $obj;
      $n = 0;
      $result = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 10;
      break;
     case 2:
      
      var $7 = _PyObject_GetBuffer($obj_addr, $buf, 8);
      
      if ($7 < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 10;
      break;
     case 4:
      
      
      
      if (HEAP[$buf + 8] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      var $13 = HEAP[$buf + 8];
      
      var $15 = HEAP[$buf];
      
      var $17 = _write_bytes($self_addr, $15, $13);
      $n = $17;
      __lastLabel__ = 5;
      __label__ = 7;
      break;
     case 6:
      var $_pr = $n;
      __lastLabel__ = 6;
      __label__ = 7;
      break;
     case 7:
      var $18 = __lastLabel__ == 6 ? $_pr : $17;
      
      if ($18 >= 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      var $21 = _PyLong_FromSsize_t($n);
      $result = $21;
      __label__ = 9;
      break;
     case 9:
      _PyBuffer_Release($buf);
      
      $0 = $result;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval9 = $retval;
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_writelines($self, $v) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $v_addr;
      var $retval;
      var $0;
      var $it;
      var $item;
      var $ret;
      $self_addr = $self;
      $v_addr = $v;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      $0 = 0;
      __label__ = 18;
      break;
     case 2:
      
      var $7 = _PyObject_GetIter($v_addr);
      $it = $7;
      
      
      if ($it == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 18;
      break;
     case 4:
      
      
      var $12 = _bytesio_write($self_addr, $item);
      $ret = $12;
      
      
      
      var $16 = HEAP[$item] - 1;
      
      
      HEAP[$item] = $16;
      
      
      
      
      if (HEAP[$item] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $27 = HEAP[HEAP[$item + 4] + 24];
      
      FUNCTION_TABLE[$27]($item);
      __label__ = 6;
      break;
     case 6:
      
      
      if ($ret == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      
      
      
      var $34 = HEAP[$it] - 1;
      
      
      HEAP[$it] = $34;
      
      
      
      
      if (HEAP[$it] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $45 = HEAP[HEAP[$it + 4] + 24];
      
      FUNCTION_TABLE[$45]($it);
      __label__ = 9;
      break;
     case 9:
      $0 = 0;
      __label__ = 18;
      break;
     case 10:
      
      
      
      var $50 = HEAP[$ret] - 1;
      
      
      HEAP[$ret] = $50;
      
      
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $61 = HEAP[HEAP[$ret + 4] + 24];
      
      FUNCTION_TABLE[$61]($ret);
      __label__ = 12;
      break;
     case 12:
      
      var $64 = _PyIter_Next($it);
      $item = $64;
      
      if ($64 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      var $69 = HEAP[$it] - 1;
      
      
      HEAP[$it] = $69;
      
      
      
      
      if (HEAP[$it] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $80 = HEAP[HEAP[$it + 4] + 24];
      
      FUNCTION_TABLE[$80]($it);
      __label__ = 15;
      break;
     case 15:
      var $82 = _PyErr_Occurred();
      
      if ($82 != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      $0 = 0;
      __label__ = 18;
      break;
     case 17:
      
      var $85 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $85;
      $0 = __Py_NoneStruct;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval19 = $retval;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_close($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 8];
      _PyMem_Free($7);
      
      
      HEAP[$self_addr + 8] = 0;
      __label__ = 2;
      break;
     case 2:
      
      var $11 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $11;
      $0 = __Py_NoneStruct;
      
      $retval = $0;
      var $retval2 = $retval;
      return $retval2;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_getstate($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $initvalue;
      var $dict;
      var $state;
      $self_addr = $self;
      
      var $2 = _bytesio_getvalue($self_addr);
      $initvalue = $2;
      
      
      if ($initvalue == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 9;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      var $10 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $10;
      $dict = __Py_NoneStruct;
      __label__ = 6;
      break;
     case 4:
      
      
      var $13 = HEAP[$self_addr + 24];
      var $14 = _PyDict_Copy($13);
      $dict = $14;
      
      
      if ($dict == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 9;
      break;
     case 6:
      
      
      var $19 = HEAP[$self_addr + 12];
      
      
      var $22 = _Py_BuildValue(__str1985, allocate([ $initvalue, 0, 0, 0, $19, 0, 0, 0, $dict, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      $state = $22;
      
      
      
      var $26 = HEAP[$initvalue] - 1;
      
      
      HEAP[$initvalue] = $26;
      
      
      
      
      if (HEAP[$initvalue] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $37 = HEAP[HEAP[$initvalue + 4] + 24];
      
      FUNCTION_TABLE[$37]($initvalue);
      __label__ = 8;
      break;
     case 8:
      
      $0 = $state;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_setstate($self, $state) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $state_addr;
      var $retval;
      var $0;
      var $result;
      var $position_obj;
      var $dict;
      var $pos;
      $self_addr = $self;
      $state_addr = $state;
      
      
      if ($state_addr == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str2086, __str167, 668, ___PRETTY_FUNCTION___9134);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$state_addr + 4] + 84] & 67108864) == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      if (HEAP[$state_addr + 8] <= 2) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $19 = HEAP[HEAP[$state_addr + 4] + 12];
      
      
      
      
      
      var $25 = HEAP[HEAP[$self_addr + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str2187, allocate([ $25, 0, 0, 0, $19, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 27;
      break;
     case 5:
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      
      
      var $36 = HEAP[$state_addr + 12];
      
      var $38 = _bytesio_write($self_addr, $36);
      $result = $38;
      
      
      if ($result == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 27;
      break;
     case 7:
      
      
      
      var $44 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $44;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $55 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$55]($result);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      
      $position_obj = HEAP[$state_addr + 12 + 4];
      
      
      
      
      
      
      if (HEAP[HEAP[$position_obj + 4] + 48] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$position_obj + 4] + 84] & 131072) == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 11:
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$position_obj + 4] + 48] + 152] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $87 = HEAP[HEAP[$position_obj + 4] + 12];
      var $88 = HEAP[_PyExc_TypeError];
      var $89 = _PyErr_Format($88, __str2288, allocate([ $87, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 27;
      break;
     case 13:
      var $90 = HEAP[_PyExc_OverflowError];
      
      var $92 = _PyNumber_AsSsize_t($position_obj, $90);
      $pos = $92;
      var $93 = $pos;
      var $94 = $93 == -1;
      if ($94) {
        __lastLabel__ = 13;
        __label__ = 14;
        break;
      } else {
        __lastLabel__ = 13;
        __label__ = 17;
        break;
      }
     case 14:
      var $95 = _PyErr_Occurred();
      
      if ($95 != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      $0 = 0;
      __label__ = 27;
      break;
     case 16:
      var $_pr = $pos;
      __lastLabel__ = 16;
      __label__ = 17;
      break;
     case 17:
      var $97 = __lastLabel__ == 16 ? $_pr : $93;
      
      if ($97 < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      var $99 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($99, __str2389);
      $0 = 0;
      __label__ = 27;
      break;
     case 19:
      
      
      
      HEAP[$self_addr + 12] = $pos;
      
      
      
      
      
      $dict = HEAP[$state_addr + 12 + 8];
      
      
      if ($dict != __Py_NoneStruct) {
        __label__ = 20;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 20:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$dict + 4] + 84] & 536870912) == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $121 = HEAP[HEAP[$dict + 4] + 12];
      var $122 = HEAP[_PyExc_TypeError];
      var $123 = _PyErr_Format($122, __str2490, allocate([ $121, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 27;
      break;
     case 22:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 23:
      
      
      var $130 = HEAP[$self_addr + 24];
      
      var $132 = _PyDict_Update($130, $dict);
      
      if ($132 < 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 24:
      $0 = 0;
      __label__ = 27;
      break;
     case 25:
      
      
      
      var $137 = HEAP[$dict] + 1;
      
      
      HEAP[$dict] = $137;
      
      
      
      HEAP[$self_addr + 24] = $dict;
      __label__ = 26;
      break;
     case 26:
      
      var $144 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $144;
      $0 = __Py_NoneStruct;
      __label__ = 27;
      break;
     case 27:
      
      $retval = $0;
      var $retval27 = $retval;
      return $retval27;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $g;
      var $_py_tmp;
      $self_addr = $self;
      
      
      var $2 = $self_addr + -12;
      $g = $2;
      
      
      
      
      var $7 = HEAP[$g + 8] == -2;
      if ($7) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str9, __str167, 738, ___PRETTY_FUNCTION___9218);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      HEAP[$g + 8] = -2;
      
      
      
      
      
      
      
      var $18 = HEAP[$g];
      
      var $20 = HEAP[$g + 4];
      HEAP[$20] = $18;
      
      
      
      
      
      
      
      var $28 = HEAP[$g + 4];
      
      var $30 = HEAP[$g] + 4;
      HEAP[$30] = $28;
      
      
      
      HEAP[$g] = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      var $40 = HEAP[$self_addr + 8];
      _PyMem_Free($40);
      
      
      HEAP[$self_addr + 8] = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      
      $_py_tmp = HEAP[$self_addr + 24];
      
      
      HEAP[$self_addr + 24] = 0;
      
      
      
      var $55 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $55;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $66 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$66]($_py_tmp);
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      _PyObject_ClearWeakRefs($self_addr);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      
      var $79 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$79]($self_addr);
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_new($type, $args, $kwds) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $type_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $self;
      $type_addr = $type;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      
      if ($type_addr == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$type_addr + 152] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str2692, __str167, 754, ___PRETTY_FUNCTION___9255);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $9 = HEAP[$type_addr + 152];
      
      var $11 = FUNCTION_TABLE[$9]($type_addr, 0);
      
      $self = $11;
      
      
      if ($self == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = 0;
      __label__ = 10;
      break;
     case 5:
      var $15 = _PyMem_Malloc(0);
      
      
      HEAP[$self + 8] = $15;
      
      
      
      
      
      var $23 = $self;
      if (HEAP[$self + 8] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      var $26 = HEAP[$23] - 1;
      
      HEAP[$23] = $26;
      
      
      
      if (HEAP[$23] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $36 = HEAP[HEAP[$self + 4] + 24];
      
      
      FUNCTION_TABLE[$36]($self);
      __label__ = 8;
      break;
     case 8:
      var $39 = _PyErr_NoMemory();
      $0 = $39;
      __label__ = 10;
      break;
     case 9:
      $0 = $23;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $kwlist = __stackBase__;
      var $initvalue = __stackBase__ + 8;
      var $res;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str2793;
      
      HEAP[$kwlist + 4] = 0;
      HEAP[$initvalue] = 0;
      
      
      var $kwlist1 = $kwlist;
      var $5 = _PyArg_ParseTupleAndKeywords($args_addr, $kwds_addr, __str2894, $kwlist1, allocate([ $initvalue, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($5 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 9;
      break;
     case 2:
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      
      
      
      if (HEAP[$initvalue] != 0 & HEAP[$initvalue] != __Py_NoneStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 3:
      var $15 = HEAP[$initvalue];
      
      var $17 = _bytesio_write($self_addr, $15);
      $res = $17;
      
      
      if ($res == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = -1;
      __label__ = 9;
      break;
     case 5:
      
      
      
      var $23 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $23;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $34 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$34]($res);
      __label__ = 7;
      break;
     case 7:
      
      
      HEAP[$self_addr + 12] = 0;
      __label__ = 8;
      break;
     case 8:
      $0 = 0;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval11 = $retval;
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_traverse($self, $visit, $arg) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $visit_addr;
      var $arg_addr;
      var $retval;
      var $0;
      var $vret;
      $self_addr = $self;
      $visit_addr = $visit;
      $arg_addr = $arg;
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 24];
      var $8 = $visit_addr;
      
      var $10 = FUNCTION_TABLE[$8]($7, $arg_addr);
      $vret = $10;
      
      
      if ($vret != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      $0 = $vret;
      __label__ = 4;
      break;
     case 3:
      $0 = 0;
      __label__ = 4;
      break;
     case 4:
      
      $retval = $0;
      var $retval4 = $retval;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      $_py_tmp = HEAP[$self_addr + 24];
      
      
      HEAP[$self_addr + 24] = 0;
      
      
      
      var $13 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $13;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $24 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$24]($_py_tmp);
      __label__ = 3;
      break;
     case 3:
      $0 = 0;
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyFileIO_closed($self) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    
    
    
    
    
    
    $0 = HEAP[$self_addr + 8] < 0;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _internal_close($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $err;
      var $save_errno;
      var $fd;
      $self_addr = $self;
      $err = 0;
      $save_errno = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] >= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      $fd = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = -1;
      
      var $11 = _close($fd);
      $err = $11;
      
      
      if ($err < 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 2:
      var $14 = ___errno_location();
      
      $save_errno = HEAP[$14];
      __label__ = 3;
      break;
     case 3:
      
      
      if ($err < 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      var $17 = ___errno_location();
      
      HEAP[$17] = $save_errno;
      var $19 = HEAP[_PyExc_IOError];
      var $20 = _PyErr_SetFromErrno($19);
      $0 = -1;
      __label__ = 6;
      break;
     case 5:
      $0 = 0;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_close($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 27 >>> 31 & 1) == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      HEAP[$self_addr + 8] = -1;
      
      var $11 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $11;
      $0 = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 2:
      var $12 = ___errno_location();
      
      var $14 = _internal_close($self_addr);
      HEAP[$12] = $14;
      var $15 = ___errno_location();
      
      
      if (HEAP[$15] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 5;
      break;
     case 4:
      
      var $19 = __PyObject_CallMethod_SizeT(_PyRawIOBase_Type, __str117, __str1118, allocate([ $self_addr, 0, 0, 0 ], [ "%struct.fileio*", 0, 0, 0 ], ALLOC_STACK));
      $0 = $19;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_new($type, $args, $kwds) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $type_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $self;
      $type_addr = $type;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      
      if ($type_addr == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$type_addr + 152] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str2119, __str3120, 126, ___PRETTY_FUNCTION___8576);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $9 = HEAP[$type_addr + 152];
      
      var $11 = FUNCTION_TABLE[$9]($type_addr, 0);
      
      $self = $11;
      
      
      if ($self != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      HEAP[$self + 8] = -1;
      
      
      
      var $20 = HEAP[$self + 12] & -2;
      HEAP[$self + 12] = $20;
      
      
      
      var $24 = HEAP[$self + 12] & -3;
      HEAP[$self + 12] = $24;
      
      
      
      var $28 = HEAP[$self + 12] & -13;
      var $29 = $28 | 12;
      HEAP[$self + 12] = $29;
      
      
      
      var $33 = HEAP[$self + 12] & -17;
      var $34 = $33 | 16;
      HEAP[$self + 12] = $34;
      
      
      HEAP[$self + 16] = 0;
      __label__ = 5;
      break;
     case 5:
      
      
      $0 = $self;
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _dircheck($self, $name) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 96;
    _memset(__stackBase__, 0, 96);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $name_addr;
      var $retval;
      var $0;
      var $buf = __stackBase__;
      var $msg;
      var $exc;
      $self_addr = $self;
      $name_addr = $name;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      var $7 = HEAP[$self_addr + 8];
      var $8 = ___01fstat64_($7, $buf);
      
      if ($8 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 3:
      
      
      
      
      if ((HEAP[$buf + 16] & 61440) == 16384) {
        __label__ = 4;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 4:
      var $14 = _strerror(21);
      $msg = $14;
      
      var $16 = _internal_close($self_addr);
      
      if ($16 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = -1;
      __label__ = 11;
      break;
     case 6:
      var $18 = HEAP[_PyExc_IOError];
      
      
      var $21 = __PyObject_CallFunction_SizeT($18, __str4121, allocate([ 21, 0, 0, 0, $msg, 0, 0, 0, $name_addr, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $exc = $21;
      var $22 = HEAP[_PyExc_IOError];
      
      _PyErr_SetObject($22, $exc);
      
      
      if ($exc != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      var $29 = HEAP[$exc] - 1;
      
      
      HEAP[$exc] = $29;
      
      
      
      
      if (HEAP[$exc] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $40 = HEAP[HEAP[$exc + 4] + 24];
      
      FUNCTION_TABLE[$40]($exc);
      __label__ = 9;
      break;
     case 9:
      $0 = -1;
      __label__ = 11;
      break;
     case 10:
      $0 = 0;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval11 = $retval;
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _check_fd($fd) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 96;
    _memset(__stackBase__, 0, 96);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $fd_addr;
      var $retval;
      var $0;
      var $buf = __stackBase__;
      var $exc;
      var $msg;
      $fd_addr = $fd;
      
      var $2 = ___01fstat64_($fd_addr, $buf);
      
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 1:
      var $4 = ___errno_location();
      
      
      if (HEAP[$4] == 9) {
        __label__ = 2;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 2:
      var $7 = _strerror(9);
      $msg = $7;
      var $8 = HEAP[_PyExc_OSError];
      
      var $10 = __PyObject_CallFunction_SizeT($8, __str5122, allocate([ 9, 0, 0, 0, $msg, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $exc = $10;
      var $11 = HEAP[_PyExc_OSError];
      
      _PyErr_SetObject($11, $exc);
      
      
      if ($exc != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      var $18 = HEAP[$exc] - 1;
      
      
      HEAP[$exc] = $18;
      
      
      
      
      if (HEAP[$exc] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $29 = HEAP[HEAP[$exc + 4] + 24];
      
      FUNCTION_TABLE[$29]($exc);
      __label__ = 5;
      break;
     case 5:
      $0 = -1;
      __label__ = 7;
      break;
     case 6:
      $0 = 0;
      __label__ = 7;
      break;
     case 7:
      
      $retval = $0;
      var $retval7 = $retval;
      STACKTOP = __stackBase__;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_init($oself, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $oself_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $self;
      var $name = __stackBase__;
      var $nameobj = __stackBase__ + 4;
      var $stringobj;
      var $mode = __stackBase__ + 8;
      var $s;
      var $ret;
      var $rwa;
      var $plus;
      var $append;
      var $flags;
      var $fd;
      var $closefd = __stackBase__ + 12;
      var $namelen = __stackBase__ + 16;
      var $u;
      var $pos;
      var $_py_tmp;
      $oself_addr = $oself;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      
      $self = $oself_addr;
      HEAP[$name] = 0;
      $stringobj = 0;
      HEAP[$mode] = __str6123;
      $ret = 0;
      $rwa = 0;
      $plus = 0;
      $append = 0;
      $flags = 0;
      $fd = -1;
      HEAP[$closefd] = 1;
      
      
      
      
      if (HEAP[$oself_addr + 4] != _PyFileIO_Type) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $9 = HEAP[$oself_addr + 4];
      var $10 = _PyType_IsSubtype($9, _PyFileIO_Type);
      
      if ($10 == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str7124, __str3120, 205, ___PRETTY_FUNCTION___8670);
      throw "Reached an unreachable!";
     case 3:
      
      
      
      
      if (HEAP[$self + 8] >= 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      var $17 = _internal_close($self);
      
      if ($17 < 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = -1;
      __label__ = 71;
      break;
     case 6:
      
      
      var $21 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str8125, _kwlist_8657, allocate([ $nameobj, 0, 0, 0, $mode, 0, 0, 0, $closefd, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($21 == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      $0 = -1;
      __label__ = 71;
      break;
     case 8:
      
      
      
      
      if (HEAP[HEAP[$nameobj] + 4] == _PyFloat_Type) {
        __label__ = 10;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      var $29 = HEAP[HEAP[$nameobj] + 4];
      var $30 = _PyType_IsSubtype($29, _PyFloat_Type);
      
      if ($30 != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      var $32 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($32, __str12129);
      $0 = -1;
      __label__ = 71;
      break;
     case 11:
      var $33 = HEAP[$nameobj];
      var $34 = _PyLong_AsLong($33);
      $fd = $34;
      
      
      if ($fd < 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 12:
      var $37 = _PyErr_Occurred();
      
      if ($37 == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      var $39 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($39, __str13130);
      $0 = -1;
      __label__ = 71;
      break;
     case 14:
      _PyErr_Clear();
      
      
      if ($fd < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 15:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$nameobj] + 4] + 84] & 134217728) != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      
      if (HEAP[HEAP[$nameobj] + 4] == _PyByteArray_Type) {
        __label__ = 18;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      var $54 = HEAP[HEAP[$nameobj] + 4];
      var $55 = _PyType_IsSubtype($54, _PyByteArray_Type);
      
      if ($55 != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      var $57 = HEAP[$nameobj];
      var $58 = _PyObject_AsCharBuffer($57, $name, $namelen);
      
      if ($58 < 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 19:
      $0 = -1;
      __label__ = 71;
      break;
     case 20:
      var $60 = HEAP[$nameobj];
      var $61 = _PyUnicodeUCS2_FromObject($60);
      $u = $61;
      
      
      if ($u == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      $0 = -1;
      __label__ = 71;
      break;
     case 22:
      var $64 = HEAP[_Py_FileSystemDefaultEncoding];
      
      var $66 = _PyUnicodeUCS2_AsEncodedString($u, $64, 0);
      $stringobj = $66;
      
      
      
      var $70 = HEAP[$u] - 1;
      
      
      HEAP[$u] = $70;
      
      
      
      
      if (HEAP[$u] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $81 = HEAP[HEAP[$u + 4] + 24];
      
      FUNCTION_TABLE[$81]($u);
      __label__ = 24;
      break;
     case 24:
      
      
      if ($stringobj == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      $0 = -1;
      __label__ = 71;
      break;
     case 26:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$stringobj + 4] + 84] & 134217728) == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      var $92 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($92, __str14131);
      __label__ = 66;
      break;
     case 28:
      
      
      
      
      HEAP[$name] = $stringobj + 20;
      __label__ = 29;
      break;
     case 29:
      
      $s = HEAP[$mode];
      __label__ = 41;
      break;
     case 30:
      
      
      var $100 = HEAP[$s];
      
      var $102 = $s + 1;
      $s = $102;
      if ($100 == 43) {
        __label__ = 38;
        break;
      } else if ($100 == 97) {
        __label__ = 36;
        break;
      } else if ($100 == 98) {
        __label__ = 41;
        break;
      } else if ($100 == 114) {
        __label__ = 31;
        break;
      } else if ($100 == 119) {
        __label__ = 34;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 31:
      
      
      if ($rwa != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      var $105 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($105, __str15132);
      __label__ = 66;
      break;
     case 33:
      $rwa = 1;
      
      
      
      var $109 = HEAP[$self + 12] & -2;
      var $110 = $109 | 1;
      HEAP[$self + 12] = $110;
      __label__ = 41;
      break;
     case 34:
      
      
      if ($rwa != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 35:
      $rwa = 1;
      
      
      
      var $116 = HEAP[$self + 12] & -3;
      var $117 = $116 | 2;
      HEAP[$self + 12] = $117;
      
      var $119 = $flags | 576;
      $flags = $119;
      __label__ = 41;
      break;
     case 36:
      
      
      if ($rwa != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 37:
      $rwa = 1;
      
      
      
      var $125 = HEAP[$self + 12] & -3;
      var $126 = $125 | 2;
      HEAP[$self + 12] = $126;
      
      var $128 = $flags | 64;
      $flags = $128;
      $append = 1;
      __label__ = 41;
      break;
     case 38:
      
      
      if ($plus != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 39:
      
      
      
      var $134 = HEAP[$self + 12] & -3;
      var $135 = $134 | 2;
      HEAP[$self + 12] = $135;
      
      
      
      
      
      
      
      
      
      
      
      var $147 = HEAP[$self + 12] & -2;
      var $148 = HEAP[$self + 12] << 30 >>> 31 & 1 & 1 | $147;
      HEAP[$self + 12] = $148;
      $plus = 1;
      __label__ = 41;
      break;
     case 40:
      var $149 = HEAP[$mode];
      var $150 = HEAP[_PyExc_ValueError];
      var $151 = _PyErr_Format($150, __str16133, allocate([ $149, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 66;
      break;
     case 41:
      
      
      
      if (HEAP[$s] != 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 42:
      
      
      if ($rwa == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 43:
      
      
      
      
      
      
      
      if ((HEAP[$self + 12] << 31 >>> 31 & 1) == 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      
      
      
      
      
      
      if ((HEAP[$self + 12] << 30 >>> 31 & 1) == 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      var $172 = $flags | 2;
      $flags = $172;
      __label__ = 49;
      break;
     case 46:
      
      
      
      
      
      
      
      var $180 = $flags;
      if ((HEAP[$self + 12] << 31 >>> 31 & 1) != 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      $flags = $180;
      __label__ = 49;
      break;
     case 48:
      var $181 = $180 | 1;
      $flags = $181;
      __label__ = 49;
      break;
     case 49:
      
      
      if ($append != 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      
      var $185 = $flags | 1024;
      $flags = $185;
      __label__ = 51;
      break;
     case 51:
      
      
      if ($fd >= 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 52:
      
      var $189 = _check_fd($fd);
      
      if ($189 != 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 53:
      
      
      
      HEAP[$self + 8] = $fd;
      
      
      
      
      
      
      
      
      
      var $203 = HEAP[$self + 12] & -17;
      var $204 = (HEAP[$closefd] & 255 & 1) << 4 & 16 | $203;
      HEAP[$self + 12] = $204;
      __label__ = 59;
      break;
     case 54:
      
      
      
      var $208 = HEAP[$self + 12] & -17;
      var $209 = $208 | 16;
      HEAP[$self + 12] = $209;
      
      
      if (HEAP[$closefd] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 55:
      var $212 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($212, __str17134);
      __label__ = 66;
      break;
     case 56:
      var $213 = ___errno_location();
      HEAP[$213] = 0;
      var $214 = HEAP[$name];
      
      var $216 = ___01open64_($214, $flags, allocate([ 438, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      
      
      HEAP[$self + 8] = $216;
      
      
      
      
      var $223 = HEAP[$name];
      if (HEAP[$self + 8] < 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      var $224 = HEAP[_PyExc_IOError];
      var $225 = _PyErr_SetFromErrnoWithFilename($224, $223);
      __label__ = 66;
      break;
     case 58:
      
      var $227 = _dircheck($self, $223);
      
      if ($227 < 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 59:
      var $229 = HEAP[$nameobj];
      
      
      var $232 = _PyObject_SetAttrString($self, __str13, $229);
      
      if ($232 < 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 60:
      
      
      if ($append != 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 61:
      
      
      var $238 = HEAP[$self + 8];
      var $239 = _portable_lseek($238, 0, 2);
      $pos = $239;
      
      
      if ($pos == 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 62:
      
      
      if (HEAP[$closefd] != 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 63:
      
      
      var $246 = HEAP[$self + 8];
      var $247 = _close($246);
      
      
      HEAP[$self + 8] = -1;
      __label__ = 66;
      break;
     case 64:
      
      
      
      var $253 = HEAP[$pos] - 1;
      
      
      HEAP[$pos] = $253;
      
      
      
      
      if (HEAP[$pos] == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 65:
      
      
      
      
      var $264 = HEAP[HEAP[$pos + 4] + 24];
      
      FUNCTION_TABLE[$264]($pos);
      __label__ = 67;
      break;
     case 66:
      $ret = -1;
      __label__ = 67;
      break;
     case 67:
      
      
      if ($stringobj != 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 68:
      
      $_py_tmp = $stringobj;
      $stringobj = 0;
      
      
      
      var $272 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $272;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      
      
      
      
      var $283 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$283]($_py_tmp);
      __label__ = 70;
      break;
     case 70:
      
      $0 = $ret;
      __label__ = 71;
      break;
     case 71:
      
      $retval = $0;
      var $retval73 = $retval;
      STACKTOP = __stackBase__;
      return $retval73;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_traverse($self, $visit, $arg) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $visit_addr;
      var $arg_addr;
      var $retval;
      var $0;
      var $vret;
      $self_addr = $self;
      $visit_addr = $visit;
      $arg_addr = $arg;
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 20];
      var $8 = $visit_addr;
      
      var $10 = FUNCTION_TABLE[$8]($7, $arg_addr);
      $vret = $10;
      
      
      if ($vret != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      $0 = $vret;
      __label__ = 4;
      break;
     case 3:
      $0 = 0;
      __label__ = 4;
      break;
     case 4:
      
      $retval = $0;
      var $retval4 = $retval;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      $_py_tmp = HEAP[$self_addr + 20];
      
      
      HEAP[$self_addr + 20] = 0;
      
      
      
      var $13 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $13;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $24 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$24]($_py_tmp);
      __label__ = 3;
      break;
     case 3:
      $0 = 0;
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $g;
      var $_py_tmp;
      $self_addr = $self;
      
      
      var $2 = __PyIOBase_finalize($self_addr);
      
      if ($2 < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      var $6 = $self_addr + -12;
      $g = $6;
      
      
      
      
      var $11 = HEAP[$g + 8] == -2;
      if ($11) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str19136, __str3120, 410, ___PRETTY_FUNCTION___8879);
      throw "Reached an unreachable!";
     case 3:
      
      
      
      HEAP[$g + 8] = -2;
      
      
      
      
      
      
      
      var $22 = HEAP[$g];
      
      var $24 = HEAP[$g + 4];
      HEAP[$24] = $22;
      
      
      
      
      
      
      
      var $32 = HEAP[$g + 4];
      
      var $34 = HEAP[$g] + 4;
      HEAP[$34] = $32;
      
      
      
      HEAP[$g] = 0;
      
      
      
      
      if (HEAP[$self_addr + 16] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      _PyObject_ClearWeakRefs($self_addr);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      
      $_py_tmp = HEAP[$self_addr + 20];
      
      
      HEAP[$self_addr + 20] = 0;
      
      
      
      var $56 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $56;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $67 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$67]($_py_tmp);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      var $74 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$74]($self_addr);
      __label__ = 9;
      break;
     case 9:
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _err_closed() {
    
    var $retval;
    var $0;
    var $1 = HEAP[_PyExc_ValueError];
    _PyErr_SetString($1, __str20137);
    $0 = 0;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _err_mode($action) {
    
    var $action_addr;
    var $retval;
    var $0;
    $action_addr = $action;
    var $1 = HEAP[_PyExc_ValueError];
    
    var $3 = _PyErr_Format($1, __str21138, allocate([ $action_addr, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
    $0 = 0;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _fileio_fileno($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[$self_addr + 8];
      var $9 = _PyInt_FromLong($8);
      $0 = $9;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_readable($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      
      
      var $12 = HEAP[$self_addr + 12] << 31 >>> 31 & 1;
      var $13 = _PyBool_FromLong($12);
      $0 = $13;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_writable($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      
      
      var $12 = HEAP[$self_addr + 12] << 30 >>> 31 & 1;
      var $13 = _PyBool_FromLong($12);
      $0 = $13;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_seekable($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $pos;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 9;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 28 >> 30 & 3) < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 3:
      
      
      var $15 = HEAP[$self_addr + 8];
      var $16 = _portable_lseek($15, 0, 1);
      $pos = $16;
      
      
      if ($pos == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      _PyErr_Clear();
      
      
      
      var $22 = HEAP[$self_addr + 12] & -13;
      HEAP[$self_addr + 12] = $22;
      __label__ = 8;
      break;
     case 5:
      
      
      
      var $26 = HEAP[$pos] - 1;
      
      
      HEAP[$pos] = $26;
      
      
      
      
      if (HEAP[$pos] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $37 = HEAP[HEAP[$pos + 4] + 24];
      
      FUNCTION_TABLE[$37]($pos);
      __label__ = 7;
      break;
     case 7:
      
      
      
      var $42 = HEAP[$self_addr + 12] & -13;
      var $43 = $42 | 4;
      HEAP[$self_addr + 12] = $43;
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      
      var $50 = HEAP[$self_addr + 12] << 28 >> 30 & 3;
      var $51 = _PyBool_FromLong($50);
      $0 = $51;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $pbuf = __stackBase__;
      var $n;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 11;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 31 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $13 = _err_mode(__str22139);
      $0 = $13;
      __label__ = 11;
      break;
     case 4:
      
      var $15 = __PyArg_ParseTuple_SizeT($args_addr, __str23140, allocate([ $pbuf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 11;
      break;
     case 6:
      var $17 = ___errno_location();
      HEAP[$17] = 0;
      
      var $19 = HEAP[$pbuf + 8];
      
      var $21 = HEAP[$pbuf];
      
      
      var $24 = HEAP[$self_addr + 8];
      var $25 = _read($24, $21, $19);
      $n = $25;
      _PyBuffer_Release($pbuf);
      
      
      if ($n < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      var $28 = ___errno_location();
      
      
      if (HEAP[$28] == 11) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      var $32 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $32;
      $0 = __Py_NoneStruct;
      __label__ = 11;
      break;
     case 9:
      var $33 = HEAP[_PyExc_IOError];
      var $34 = _PyErr_SetFromErrno($33);
      $0 = 0;
      __label__ = 11;
      break;
     case 10:
      
      var $36 = _PyLong_FromSsize_t($n);
      $0 = $36;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval11 = $retval;
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _new_buffersize($self, $currentsize) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 96;
    _memset(__stackBase__, 0, 96);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $currentsize_addr;
      var $retval;
      var $0;
      var $pos;
      var $end;
      var $st = __stackBase__;
      $self_addr = $self;
      $currentsize_addr = $currentsize;
      
      
      var $3 = HEAP[$self_addr + 8];
      var $4 = ___01fstat64_($3, $st);
      
      if ($4 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      
      
      $end = HEAP[$st + 44];
      
      
      var $10 = HEAP[$self_addr + 8];
      var $11 = ___01lseek64_($10, 0, 1);
      $pos = $11;
      
      
      if ($end > 8191) {
        __label__ = 2;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 2:
      
      
      
      
      
      
      if ($end >= $pos & $pos >= 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      
      $0 = $currentsize_addr + 1 + ($end & 4294967295) + (0 - ($pos & 4294967295));
      __label__ = 9;
      break;
     case 4:
      var $27 = $currentsize_addr;
      
      if ($27 > 8192) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      
      var $30 = $currentsize_addr;
      if ($27 <= 524288) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      $0 = $currentsize_addr + $30;
      __label__ = 9;
      break;
     case 7:
      
      $0 = $30 + 524288;
      __label__ = 9;
      break;
     case 8:
      
      $0 = $27 + 8192;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval10 = $retval;
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_readall($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $result = __stackBase__;
      var $total;
      var $n;
      var $newsize;
      $self_addr = $self;
      $total = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 32;
      break;
     case 2:
      var $6 = _PyString_FromStringAndSize(0, 8192);
      HEAP[$result] = $6;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 32;
      break;
     case 4:
      
      
      var $11 = _new_buffersize($self_addr, $total);
      $newsize = $11;
      
      
      
      
      
      if ($newsize < 0 | $newsize == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      var $16 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($16, __str24141);
      var $17 = HEAP[$result];
      
      
      var $20 = HEAP[$17] - 1;
      var $21 = $17;
      HEAP[$21] = $20;
      
      
      
      if (HEAP[$17] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $29 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $30 = HEAP[$result];
      FUNCTION_TABLE[$29]($30);
      __label__ = 7;
      break;
     case 7:
      $0 = 0;
      __label__ = 32;
      break;
     case 8:
      
      
      
      
      
      
      if (HEAP[HEAP[$result] + 8] < $newsize) {
        __label__ = 9;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 9:
      
      var $38 = __PyString_Resize($result, $newsize);
      
      if ($38 < 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 10:
      
      
      if ($total == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 11:
      var $42 = HEAP[$result];
      
      
      var $45 = HEAP[$42] - 1;
      var $46 = $42;
      HEAP[$46] = $45;
      
      
      
      if (HEAP[$42] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $54 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $55 = HEAP[$result];
      FUNCTION_TABLE[$54]($55);
      __label__ = 13;
      break;
     case 13:
      $0 = 0;
      __label__ = 32;
      break;
     case 14:
      _PyErr_Clear();
      __label__ = 26;
      break;
     case 15:
      var $56 = ___errno_location();
      HEAP[$56] = 0;
      
      
      
      
      
      
      
      
      var $65 = HEAP[$result] + 20 + $total;
      
      
      var $68 = HEAP[$self_addr + 8];
      var $69 = _read($68, $65, $newsize - $total);
      $n = $69;
      
      if ($69 == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      var $73 = $total;
      if ($n < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 17:
      
      if ($73 > 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      var $75 = ___errno_location();
      
      var $77 = HEAP[$75] == 11;
      var $78 = HEAP[$result];
      
      
      var $81 = HEAP[$78] - 1;
      var $82 = $78;
      HEAP[$82] = $81;
      
      
      var $85 = HEAP[$78] == 0;
      if ($77) {
        __label__ = 19;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 19:
      if ($85) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $90 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $91 = HEAP[$result];
      FUNCTION_TABLE[$90]($91);
      __label__ = 21;
      break;
     case 21:
      
      var $93 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $93;
      $0 = __Py_NoneStruct;
      __label__ = 32;
      break;
     case 22:
      if ($85) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $98 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $99 = HEAP[$result];
      FUNCTION_TABLE[$98]($99);
      __label__ = 24;
      break;
     case 24:
      var $100 = HEAP[_PyExc_IOError];
      var $101 = _PyErr_SetFromErrno($100);
      $0 = 0;
      __label__ = 32;
      break;
     case 25:
      
      var $103 = $n + $73;
      $total = $103;
      __label__ = 4;
      break;
     case 26:
      
      
      
      
      
      
      if (HEAP[HEAP[$result] + 8] > $total) {
        __label__ = 27;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 27:
      
      var $111 = __PyString_Resize($result, $total);
      
      if ($111 < 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 28:
      var $113 = HEAP[$result];
      
      
      var $116 = HEAP[$113] - 1;
      var $117 = $113;
      HEAP[$117] = $116;
      
      
      
      if (HEAP[$113] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $125 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $126 = HEAP[$result];
      FUNCTION_TABLE[$125]($126);
      __label__ = 30;
      break;
     case 30:
      $0 = 0;
      __label__ = 32;
      break;
     case 31:
      
      $0 = HEAP[$result];
      __label__ = 32;
      break;
     case 32:
      
      $retval = $0;
      var $retval33 = $retval;
      STACKTOP = __stackBase__;
      return $retval33;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $ptr;
      var $n;
      var $size = __stackBase__;
      var $bytes = __stackBase__ + 4;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$size] = -1;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 22;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 31 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $13 = _err_mode(__str22139);
      $0 = $13;
      __label__ = 22;
      break;
     case 4:
      
      var $15 = __PyArg_ParseTuple_SizeT($args_addr, __str25142, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $size, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 22;
      break;
     case 6:
      
      
      if (HEAP[$size] < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      var $20 = _fileio_readall($self_addr);
      $0 = $20;
      __label__ = 22;
      break;
     case 8:
      var $21 = HEAP[$size];
      var $22 = _PyString_FromStringAndSize(0, $21);
      HEAP[$bytes] = $22;
      
      
      if (HEAP[$bytes] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 22;
      break;
     case 10:
      
      
      
      
      $ptr = HEAP[$bytes] + 20;
      var $29 = ___errno_location();
      HEAP[$29] = 0;
      var $30 = HEAP[$size];
      
      
      var $33 = HEAP[$self_addr + 8];
      
      var $35 = _read($33, $ptr, $30);
      $n = $35;
      
      
      if ($n < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 11:
      var $38 = HEAP[$bytes];
      
      
      var $41 = HEAP[$38] - 1;
      var $42 = $38;
      HEAP[$42] = $41;
      
      
      
      if (HEAP[$38] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $50 = HEAP[HEAP[HEAP[$bytes] + 4] + 24];
      var $51 = HEAP[$bytes];
      FUNCTION_TABLE[$50]($51);
      __label__ = 13;
      break;
     case 13:
      var $52 = ___errno_location();
      
      
      if (HEAP[$52] == 11) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      var $56 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $56;
      $0 = __Py_NoneStruct;
      __label__ = 22;
      break;
     case 15:
      var $57 = HEAP[_PyExc_IOError];
      var $58 = _PyErr_SetFromErrno($57);
      $0 = 0;
      __label__ = 22;
      break;
     case 16:
      
      
      
      if ($n != HEAP[$size]) {
        __label__ = 17;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 17:
      
      var $63 = __PyString_Resize($bytes, $n);
      
      if ($63 < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 18:
      var $65 = HEAP[$bytes];
      
      
      var $68 = HEAP[$65] - 1;
      var $69 = $65;
      HEAP[$69] = $68;
      
      
      
      if (HEAP[$65] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $77 = HEAP[HEAP[HEAP[$bytes] + 4] + 24];
      var $78 = HEAP[$bytes];
      FUNCTION_TABLE[$77]($78);
      __label__ = 20;
      break;
     case 20:
      $0 = 0;
      __label__ = 22;
      break;
     case 21:
      
      $0 = HEAP[$bytes];
      __label__ = 22;
      break;
     case 22:
      
      $retval = $0;
      var $retval22 = $retval;
      STACKTOP = __stackBase__;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $pbuf = __stackBase__;
      var $n;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 11;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 30 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $13 = _err_mode(__str26143);
      $0 = $13;
      __label__ = 11;
      break;
     case 4:
      
      var $15 = __PyArg_ParseTuple_SizeT($args_addr, __str27144, allocate([ $pbuf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 11;
      break;
     case 6:
      var $17 = ___errno_location();
      HEAP[$17] = 0;
      
      var $19 = HEAP[$pbuf + 8];
      
      var $21 = HEAP[$pbuf];
      
      
      var $24 = HEAP[$self_addr + 8];
      var $25 = _write($24, $21, $19);
      $n = $25;
      _PyBuffer_Release($pbuf);
      
      
      if ($n < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      var $28 = ___errno_location();
      
      
      if (HEAP[$28] == 11) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      var $32 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $32;
      $0 = __Py_NoneStruct;
      __label__ = 11;
      break;
     case 9:
      var $33 = HEAP[_PyExc_IOError];
      var $34 = _PyErr_SetFromErrno($33);
      $0 = 0;
      __label__ = 11;
      break;
     case 10:
      
      var $36 = _PyLong_FromSsize_t($n);
      $0 = $36;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval11 = $retval;
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _portable_lseek($fd, $posobj, $whence) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $fd_addr;
      var $posobj_addr;
      var $whence_addr;
      var $retval;
      var $0;
      var $pos;
      var $res;
      $fd_addr = $fd;
      $posobj_addr = $posobj;
      $whence_addr = $whence;
      
      
      if ($posobj_addr == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $pos = 0;
      __label__ = 7;
      break;
     case 2:
      
      
      
      
      if (HEAP[$posobj_addr + 4] == _PyFloat_Type) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      var $9 = HEAP[$posobj_addr + 4];
      var $10 = _PyType_IsSubtype($9, _PyFloat_Type);
      
      if ($10 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      var $12 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($12, __str28145);
      $0 = 0;
      __label__ = 10;
      break;
     case 5:
      
      var $14 = _PyLong_AsLongLong($posobj_addr);
      $pos = $14;
      var $15 = _PyErr_Occurred();
      
      if ($15 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 10;
      break;
     case 7:
      
      
      
      var $20 = ___01lseek64_($fd_addr, $pos, $whence_addr);
      $res = $20;
      
      if ($20 < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $22 = HEAP[_PyExc_IOError];
      var $23 = _PyErr_SetFromErrno($22);
      $0 = $23;
      __label__ = 10;
      break;
     case 9:
      
      var $25 = _PyLong_FromLongLong($res);
      $0 = $25;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $posobj = __stackBase__;
      var $whence = __stackBase__ + 4;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$whence] = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 5;
      break;
     case 2:
      
      var $7 = __PyArg_ParseTuple_SizeT($args_addr, __str29146, allocate([ $posobj, 0, 0, 0, $whence, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 5;
      break;
     case 4:
      var $9 = HEAP[$whence];
      var $10 = HEAP[$posobj];
      
      
      var $13 = HEAP[$self_addr + 8];
      var $14 = _portable_lseek($13, $10, $9);
      $0 = $14;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_tell($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[$self_addr + 8];
      var $9 = _portable_lseek($8, 0, 1);
      $0 = $9;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $posobj = __stackBase__;
      var $pos;
      var $ret;
      var $fd;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$posobj] = 0;
      
      
      
      $fd = HEAP[$self_addr + 8];
      
      
      if ($fd < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $6 = _err_closed();
      $0 = $6;
      __label__ = 19;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 30 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $14 = _err_mode(__str26143);
      $0 = $14;
      __label__ = 19;
      break;
     case 4:
      
      var $16 = __PyArg_ParseTuple_SizeT($args_addr, __str30147, allocate([ $posobj, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($16 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 19;
      break;
     case 6:
      
      
      
      
      
      if (HEAP[$posobj] == __Py_NoneStruct | HEAP[$posobj] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      var $23 = _portable_lseek($fd, 0, 1);
      HEAP[$posobj] = $23;
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      $0 = 0;
      __label__ = 19;
      break;
     case 9:
      
      
      
      var $29 = HEAP[HEAP[$posobj]] + 1;
      var $30 = HEAP[$posobj];
      HEAP[$30] = $29;
      __label__ = 10;
      break;
     case 10:
      var $31 = HEAP[$posobj];
      var $32 = _PyLong_AsLongLong($31);
      $pos = $32;
      var $33 = _PyErr_Occurred();
      
      if ($33 != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 11:
      var $35 = HEAP[$posobj];
      
      
      var $38 = HEAP[$35] - 1;
      var $39 = $35;
      HEAP[$39] = $38;
      
      
      
      if (HEAP[$35] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $47 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $48 = HEAP[$posobj];
      FUNCTION_TABLE[$47]($48);
      __label__ = 13;
      break;
     case 13:
      $0 = 0;
      __label__ = 19;
      break;
     case 14:
      var $49 = ___errno_location();
      HEAP[$49] = 0;
      
      
      var $52 = ___01ftruncate64_($fd, $pos);
      $ret = $52;
      
      
      var $55 = HEAP[$posobj];
      if ($ret != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      
      
      var $58 = HEAP[$55] - 1;
      var $59 = $55;
      HEAP[$59] = $58;
      
      
      
      if (HEAP[$55] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $67 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $68 = HEAP[$posobj];
      FUNCTION_TABLE[$67]($68);
      __label__ = 17;
      break;
     case 17:
      var $69 = HEAP[_PyExc_IOError];
      var $70 = _PyErr_SetFromErrno($69);
      $0 = 0;
      __label__ = 19;
      break;
     case 18:
      $0 = $55;
      __label__ = 19;
      break;
     case 19:
      
      $retval = $0;
      var $retval21 = $retval;
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _mode_string($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 31 >>> 31 & 1) != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 12] << 30 >>> 31 & 1) != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      $0 = __str31148;
      __label__ = 5;
      break;
     case 3:
      $0 = __str32149;
      __label__ = 5;
      break;
     case 4:
      $0 = __str33150;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_repr($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $nameobj;
      var $res;
      var $repr;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _PyString_FromFormat(__str34151, allocate(1, "i32", ALLOC_STACK));
      $0 = $5;
      __label__ = 13;
      break;
     case 2:
      
      
      var $8 = _PyObject_GetAttrString($self_addr, __str13);
      $nameobj = $8;
      
      
      if ($nameobj == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      var $11 = HEAP[_PyExc_AttributeError];
      var $12 = _PyErr_ExceptionMatches($11);
      
      if ($12 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      _PyErr_Clear();
      
      var $15 = _mode_string($self_addr);
      
      
      var $18 = HEAP[$self_addr + 8];
      var $19 = _PyString_FromFormat(__str35152, allocate([ $18, 0, 0, 0, $15, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $19;
      __label__ = 12;
      break;
     case 5:
      $0 = 0;
      __label__ = 13;
      break;
     case 6:
      
      var $21 = _PyObject_Repr($nameobj);
      $repr = $21;
      
      
      
      var $25 = HEAP[$nameobj] - 1;
      
      
      HEAP[$nameobj] = $25;
      
      
      
      
      if (HEAP[$nameobj] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $36 = HEAP[HEAP[$nameobj + 4] + 24];
      
      FUNCTION_TABLE[$36]($nameobj);
      __label__ = 8;
      break;
     case 8:
      
      
      if ($repr == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 13;
      break;
     case 10:
      
      var $41 = _mode_string($self_addr);
      
      
      
      
      var $46 = _PyString_FromFormat(__str36153, allocate([ $repr + 20, 0, 0, 0, $41, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $46;
      
      
      
      var $50 = HEAP[$repr] - 1;
      
      
      HEAP[$repr] = $50;
      
      
      
      
      if (HEAP[$repr] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $61 = HEAP[HEAP[$repr + 4] + 24];
      
      FUNCTION_TABLE[$61]($repr);
      __label__ = 12;
      break;
     case 12:
      
      $0 = $res;
      __label__ = 13;
      break;
     case 13:
      
      $retval = $0;
      var $retval13 = $retval;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_isatty($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $res;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      $0 = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[$self_addr + 8];
      var $9 = _isatty($8);
      $res = $9;
      
      var $11 = _PyBool_FromLong($res);
      $0 = $11;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _get_closed($self, $closure) {
    
    var $self_addr;
    var $closure_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $closure_addr = $closure;
    
    
    
    
    var $5 = HEAP[$self_addr + 8] < 0;
    var $6 = _PyBool_FromLong($5);
    $0 = $6;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _get_closefd($self, $closure) {
    
    var $self_addr;
    var $closure_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $closure_addr = $closure;
    
    
    
    
    
    
    var $7 = HEAP[$self_addr + 12] << 27 >>> 31 & 1;
    var $8 = _PyBool_FromLong($7);
    $0 = $8;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _get_mode($self, $closure) {
    
    var $self_addr;
    var $closure_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $closure_addr = $closure;
    
    var $2 = _mode_string($self_addr);
    var $3 = _PyUnicodeUCS2_FromString($2);
    $0 = $3;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _iobase_unsupported($message) {
    
    var $message_addr;
    var $retval;
    var $0;
    $message_addr = $message;
    var $1 = HEAP[__PyIO_unsupported_operation];
    
    _PyErr_SetString($1, $message_addr);
    $0 = 0;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _iobase_seek($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = _iobase_unsupported(__str181);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _iobase_tell($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    
    var $2 = __PyObject_CallMethod_SizeT($self_addr, __str181, __str1182, allocate([ 0, 0, 0, 0, 1, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
    $0 = $2;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _iobase_truncate($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = _iobase_unsupported(__str2183);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _iobase_flush($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      var $2 = _PyObject_HasAttrString($self_addr, __str3184);
      
      if ($2 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $4 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($4, __str4185);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $6 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $6;
      $0 = __Py_NoneStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_closed($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $res;
      var $closed;
      $self_addr = $self;
      var $1 = HEAP[__PyIO_str_closed];
      
      var $3 = _PyObject_GetAttr($self_addr, $1);
      $res = $3;
      
      
      if ($res == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      var $7 = _PyObject_IsTrue($res);
      $closed = $7;
      
      
      
      var $11 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $11;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $22 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$22]($res);
      __label__ = 4;
      break;
     case 4:
      
      $0 = $closed;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_closed_get($self, $context) {
    
    var $self_addr;
    var $context_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $context_addr = $context;
    
    var $2 = _PyObject_HasAttrString($self_addr, __str3184);
    var $3 = _PyBool_FromLong($2);
    $0 = $3;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function __PyIOBase_check_closed($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      var $2 = _iobase_closed($self_addr);
      
      if ($2 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $4 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($4, __str4185);
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      if ($args_addr == __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 4:
      
      var $8 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $8;
      $0 = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_close($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      $self_addr = $self;
      $args_addr = $args;
      
      var $2 = _PyObject_HasAttrString($self_addr, __str3184);
      
      if ($2 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $5 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $5;
      $0 = __Py_NoneStruct;
      __label__ = 8;
      break;
     case 2:
      var $6 = HEAP[__PyIO_str_flush];
      
      var $8 = _PyObject_CallMethodObjArgs($self_addr, $6, allocate(4, "i8*", ALLOC_STACK));
      $res = $8;
      
      var $10 = _PyObject_SetAttrString($self_addr, __str3184, __Py_TrueStruct);
      
      
      if ($res == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 8;
      break;
     case 4:
      
      
      if ($res != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      
      var $18 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $18;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $29 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$29]($res);
      __label__ = 7;
      break;
     case 7:
      
      var $32 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $32;
      $0 = __Py_NoneStruct;
      __label__ = 8;
      break;
     case 8:
      
      $retval = $0;
      var $retval8 = $retval;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIOBase_finalize($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    _memset(__stackBase__, 0, 12);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $res;
      var $tp = __stackBase__;
      var $v = __stackBase__ + 4;
      var $tb = __stackBase__ + 8;
      var $closed;
      var $is_zombie;
      var $refcnt;
      $self_addr = $self;
      $closed = 1;
      
      
      
      
      
      $is_zombie = HEAP[$self_addr] == 0;
      
      
      if ($is_zombie != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      
      var $11 = HEAP[$self_addr] + 1;
      
      
      HEAP[$self_addr] = $11;
      __label__ = 2;
      break;
     case 2:
      _PyErr_Fetch($tp, $v, $tb);
      var $14 = HEAP[__PyIO_str_closed];
      
      var $16 = _PyObject_GetAttr($self_addr, $14);
      $res = $16;
      
      if ($16 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      _PyErr_Clear();
      __label__ = 8;
      break;
     case 4:
      
      var $19 = _PyObject_IsTrue($res);
      $closed = $19;
      
      
      
      var $23 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $23;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $34 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$34]($res);
      __label__ = 6;
      break;
     case 6:
      var $36 = $closed;
      var $37 = $36 == -1;
      if ($37) {
        __lastLabel__ = 6;
        __label__ = 7;
        break;
      } else {
        __lastLabel__ = 6;
        __label__ = 9;
        break;
      }
     case 7:
      _PyErr_Clear();
      __label__ = 8;
      break;
     case 8:
      var $_pr = $closed;
      __lastLabel__ = 8;
      __label__ = 9;
      break;
     case 9:
      var $38 = __lastLabel__ == 8 ? $_pr : $36;
      
      if ($38 == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 10:
      var $40 = HEAP[__PyIO_str_close];
      
      var $42 = _PyObject_CallMethodObjArgs($self_addr, $40, allocate(4, "i8*", ALLOC_STACK));
      $res = $42;
      
      
      if ($res == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      _PyErr_Clear();
      __label__ = 14;
      break;
     case 12:
      
      
      
      var $48 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $48;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $59 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$59]($res);
      __label__ = 14;
      break;
     case 14:
      var $61 = HEAP[$tb];
      var $62 = HEAP[$v];
      var $63 = HEAP[$tp];
      _PyErr_Restore($63, $62, $61);
      
      
      if ($is_zombie != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 15:
      
      
      
      var $69 = HEAP[$self_addr] - 1;
      
      
      HEAP[$self_addr] = $69;
      
      
      
      
      if (HEAP[$self_addr] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      $refcnt = HEAP[$self_addr];
      
      
      HEAP[$self_addr] = 1;
      
      
      
      HEAP[$self_addr] = $refcnt;
      $0 = -1;
      __label__ = 18;
      break;
     case 17:
      $0 = 0;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval17 = $retval;
      STACKTOP = __stackBase__;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_traverse($self, $visit, $arg) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $visit_addr;
      var $arg_addr;
      var $retval;
      var $0;
      var $vret;
      $self_addr = $self;
      $visit_addr = $visit;
      $arg_addr = $arg;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 8];
      var $8 = $visit_addr;
      
      var $10 = FUNCTION_TABLE[$8]($7, $arg_addr);
      $vret = $10;
      
      
      if ($vret != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      $0 = $vret;
      __label__ = 4;
      break;
     case 3:
      $0 = 0;
      __label__ = 4;
      break;
     case 4:
      
      $retval = $0;
      var $retval4 = $retval;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      $self_addr = $self;
      
      
      var $3 = __PyIOBase_finalize($self_addr);
      
      if ($3 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 6;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $17 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $17;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $28 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$28]($_py_tmp);
      __label__ = 5;
      break;
     case 5:
      $0 = 0;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $g;
      var $_py_tmp;
      $self_addr = $self;
      
      
      var $2 = __PyIOBase_finalize($self_addr);
      
      var $4 = $self_addr;
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$4 + 4] + 84] & 512) != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 2:
      
      
      
      
      
      
      
      var $19 = HEAP[HEAP[$self_addr + 4]] + 1;
      var $20 = HEAP[$self_addr + 4];
      HEAP[$20] = $19;
      __label__ = 11;
      break;
     case 3:
      
      var $22 = $4 + -12;
      $g = $22;
      
      
      
      
      var $27 = HEAP[$g + 8] == -2;
      if ($27) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      ___assert_fail(__str5186, __str6187, 291, ___PRETTY_FUNCTION___8634);
      throw "Reached an unreachable!";
     case 5:
      
      
      
      HEAP[$g + 8] = -2;
      
      
      
      
      
      
      
      var $38 = HEAP[$g];
      
      var $40 = HEAP[$g + 4];
      HEAP[$40] = $38;
      
      
      
      
      
      
      
      var $48 = HEAP[$g + 4];
      
      var $50 = HEAP[$g] + 4;
      HEAP[$50] = $48;
      
      
      
      HEAP[$g] = 0;
      
      
      
      
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      _PyObject_ClearWeakRefs($self_addr);
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $72 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $72;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $83 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$83]($_py_tmp);
      __label__ = 10;
      break;
     case 10:
      
      
      
      
      
      var $90 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$90]($self_addr);
      __label__ = 11;
      break;
     case 11:
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_seekable($self, $args) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    
    var $2 = HEAP[__Py_ZeroStruct] + 1;
    HEAP[__Py_ZeroStruct] = $2;
    $0 = __Py_ZeroStruct;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function __PyIOBase_check_seekable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      var $1 = HEAP[__PyIO_str_seekable];
      
      var $3 = _PyObject_CallMethodObjArgs($self_addr, $1, allocate(4, "i8*", ALLOC_STACK));
      $res = $3;
      
      
      if ($res == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      if ($res != __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if ($res != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $14 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $14;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $25 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$25]($_py_tmp);
      __label__ = 6;
      break;
     case 6:
      var $27 = HEAP[_PyExc_IOError];
      _PyErr_SetString($27, __str7188);
      $0 = 0;
      __label__ = 11;
      break;
     case 7:
      
      
      if ($args_addr == __Py_TrueStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      var $33 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $33;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $44 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$44]($res);
      __label__ = 10;
      break;
     case 10:
      
      $0 = $res;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval11 = $retval;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_readable($self, $args) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    
    var $2 = HEAP[__Py_ZeroStruct] + 1;
    HEAP[__Py_ZeroStruct] = $2;
    $0 = __Py_ZeroStruct;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function __PyIOBase_check_readable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      var $1 = HEAP[__PyIO_str_readable];
      
      var $3 = _PyObject_CallMethodObjArgs($self_addr, $1, allocate(4, "i8*", ALLOC_STACK));
      $res = $3;
      
      
      if ($res == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      if ($res != __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if ($res != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $14 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $14;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $25 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$25]($_py_tmp);
      __label__ = 6;
      break;
     case 6:
      var $27 = HEAP[_PyExc_IOError];
      _PyErr_SetString($27, __str8189);
      $0 = 0;
      __label__ = 11;
      break;
     case 7:
      
      
      if ($args_addr == __Py_TrueStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      var $33 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $33;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $44 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$44]($res);
      __label__ = 10;
      break;
     case 10:
      
      $0 = $res;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval11 = $retval;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_writable($self, $args) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    
    var $2 = HEAP[__Py_ZeroStruct] + 1;
    HEAP[__Py_ZeroStruct] = $2;
    $0 = __Py_ZeroStruct;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function __PyIOBase_check_writable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      var $1 = HEAP[__PyIO_str_writable];
      
      var $3 = _PyObject_CallMethodObjArgs($self_addr, $1, allocate(4, "i8*", ALLOC_STACK));
      $res = $3;
      
      
      if ($res == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      if ($res != __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if ($res != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      $_py_tmp = $res;
      $res = 0;
      
      
      
      var $14 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $14;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $25 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$25]($_py_tmp);
      __label__ = 6;
      break;
     case 6:
      var $27 = HEAP[_PyExc_IOError];
      _PyErr_SetString($27, __str9190);
      $0 = 0;
      __label__ = 11;
      break;
     case 7:
      
      
      if ($args_addr == __Py_TrueStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      var $33 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $33;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $44 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$44]($res);
      __label__ = 10;
      break;
     case 10:
      
      $0 = $res;
      __label__ = 11;
      break;
     case 11:
      
      $retval = $0;
      var $retval11 = $retval;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_enter($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      var $2 = __PyIOBase_check_closed($self_addr, __Py_TrueStruct);
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      
      var $7 = HEAP[$self_addr] + 1;
      
      
      HEAP[$self_addr] = $7;
      
      $0 = $self_addr;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_exit($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = HEAP[__PyIO_str_close];
    
    var $3 = _PyObject_CallMethodObjArgs($self_addr, $1, allocate(4, "i8*", ALLOC_STACK));
    $0 = $3;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _iobase_fileno($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = _iobase_unsupported(__str10191);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _iobase_isatty($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      var $2 = __PyIOBase_check_closed($self_addr, __Py_TrueStruct);
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $5 = HEAP[__Py_ZeroStruct] + 1;
      HEAP[__Py_ZeroStruct] = $5;
      $0 = __Py_ZeroStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $iftmp_62;
      var $iftmp_54;
      var $iftmp_51;
      var $0;
      var $limit = __stackBase__;
      var $has_peek;
      var $buffer;
      var $result;
      var $old_size;
      var $nreadahead;
      var $b;
      var $readahead;
      var $n;
      var $buf;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$limit] = -1;
      $has_peek = 0;
      $old_size = -1;
      
      var $2 = __PyArg_ParseTuple_SizeT($args_addr, __str27, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $limit, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 66;
      break;
     case 2:
      
      var $5 = _PyObject_HasAttrString($self_addr, __str47);
      
      if ($5 != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $has_peek = 1;
      __label__ = 4;
      break;
     case 4:
      var $7 = _PyByteArray_FromStringAndSize(0, 0);
      $buffer = $7;
      
      if ($7 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 66;
      break;
     case 6:
      $nreadahead = 1;
      
      
      if ($has_peek != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 7:
      
      var $12 = __PyObject_CallMethod_SizeT($self_addr, __str47, __str13194, allocate([ 1, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $readahead = $12;
      
      
      if ($readahead == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      var $22 = $readahead;
      if ((HEAP[HEAP[$readahead + 4] + 84] & 134217728) == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 9:
      
      
      
      var $26 = HEAP[HEAP[$22 + 4] + 12];
      var $27 = HEAP[_PyExc_IOError];
      var $28 = _PyErr_Format($27, __str14195, allocate([ $26, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $32 = HEAP[$readahead] - 1;
      
      
      HEAP[$readahead] = $32;
      
      
      
      
      if (HEAP[$readahead] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 10:
      
      
      
      
      var $43 = HEAP[HEAP[$readahead + 4] + 24];
      
      FUNCTION_TABLE[$43]($readahead);
      __label__ = 63;
      break;
     case 11:
      
      
      
      
      if (HEAP[$22 + 8] > 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 12:
      $n = 0;
      
      
      
      
      $buf = $readahead + 20;
      
      
      if (HEAP[$limit] >= 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 13:
      
      
      
      
      
      
      if (HEAP[$readahead + 8] <= $n) {
        __label__ = 18;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      
      if ($n >= HEAP[$limit]) {
        __label__ = 18;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      
      
      var $69 = HEAP[$buf + $n] == 10;
      
      var $71 = $n + 1;
      $n = $71;
      
      if ($69 != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 16:
      
      
      
      
      
      
      if (HEAP[$readahead + 8] <= $n) {
        __label__ = 18;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      
      var $83 = HEAP[$buf + $n] == 10;
      
      var $85 = $n + 1;
      $n = $85;
      
      if ($83 != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 18:
      
      $nreadahead = $n;
      __label__ = 19;
      break;
     case 19:
      
      
      
      var $90 = HEAP[$readahead] - 1;
      
      
      HEAP[$readahead] = $90;
      
      
      
      
      if (HEAP[$readahead] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $101 = HEAP[HEAP[$readahead + 4] + 24];
      
      FUNCTION_TABLE[$101]($readahead);
      __label__ = 21;
      break;
     case 21:
      
      
      var $105 = __PyObject_CallMethod_SizeT($self_addr, __str15196, __str2, allocate([ $nreadahead, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $b = $105;
      
      if ($105 == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      
      
      
      
      
      
      var $114 = $b;
      if ((HEAP[HEAP[$b + 4] + 84] & 134217728) == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 23:
      
      
      
      var $118 = HEAP[HEAP[$114 + 4] + 12];
      var $119 = HEAP[_PyExc_IOError];
      var $120 = _PyErr_Format($119, __str17198, allocate([ $118, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $124 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $124;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 24:
      
      
      
      
      var $135 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$135]($b);
      __label__ = 63;
      break;
     case 25:
      
      
      
      
      if (HEAP[$114 + 8] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 26:
      
      
      
      var $144 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $144;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 27:
      
      
      
      
      var $155 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$155]($b);
      __label__ = 51;
      break;
     case 28:
      
      
      
      
      if (HEAP[$buffer + 4] != _PyByteArray_Type) {
        __label__ = 29;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 29:
      
      
      var $163 = HEAP[$buffer + 4];
      var $164 = _PyType_IsSubtype($163, _PyByteArray_Type);
      
      if ($164 == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      ___assert_fail(__str18199, __str6187, 519, ___PRETTY_FUNCTION___8875);
      throw "Reached an unreachable!";
     case 31:
      
      
      
      
      $old_size = HEAP[$buffer + 8];
      
      
      
      
      
      var $175 = $old_size + HEAP[$b + 8];
      
      var $177 = _PyByteArray_Resize($buffer, $175);
      
      
      
      var $181 = HEAP[$b + 8];
      
      
      
      var $185 = $b + 20;
      
      
      
      
      if (HEAP[$buffer + 4] != _PyByteArray_Type) {
        __label__ = 32;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 32:
      
      
      var $192 = HEAP[$buffer + 4];
      var $193 = _PyType_IsSubtype($192, _PyByteArray_Type);
      
      if ($193 == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      ___assert_fail(__str18199, __str6187, 521, ___PRETTY_FUNCTION___8875);
      throw "Reached an unreachable!";
     case 34:
      
      
      
      
      
      if (HEAP[$buffer + 8] != 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      
      
      
      
      $iftmp_51 = HEAP[$buffer + 20];
      __label__ = 37;
      break;
     case 36:
      $iftmp_51 = __PyByteArray_empty_string;
      __label__ = 37;
      break;
     case 37:
      
      
      
      _llvm_memcpy_p0i8_p0i8_i32($iftmp_51 + $old_size, $185, $181, 1, 0);
      
      
      
      var $210 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $210;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      
      var $221 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$221]($b);
      __label__ = 39;
      break;
     case 39:
      
      
      
      
      if (HEAP[$buffer + 4] != _PyByteArray_Type) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      
      
      var $229 = HEAP[$buffer + 4];
      var $230 = _PyType_IsSubtype($229, _PyByteArray_Type);
      
      if ($230 == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      ___assert_fail(__str18199, __str6187, 526, ___PRETTY_FUNCTION___8875);
      throw "Reached an unreachable!";
     case 42:
      
      
      
      
      
      if (HEAP[$buffer + 8] != 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      
      
      
      
      $iftmp_54 = HEAP[$buffer + 20];
      __label__ = 45;
      break;
     case 44:
      $iftmp_54 = __PyByteArray_empty_string;
      __label__ = 45;
      break;
     case 45:
      
      
      
      
      if (HEAP[$buffer + 4] != _PyByteArray_Type) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      
      
      var $247 = HEAP[$buffer + 4];
      var $248 = _PyType_IsSubtype($247, _PyByteArray_Type);
      
      if ($248 == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      ___assert_fail(__str18199, __str6187, 526, ___PRETTY_FUNCTION___8875);
      throw "Reached an unreachable!";
     case 48:
      
      
      
      
      
      
      
      
      
      if (HEAP[$iftmp_54 + (HEAP[$buffer + 8] - 1)] == 10) {
        __label__ = 51;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 49:
      
      
      if (HEAP[$limit] < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      
      
      
      
      
      if (HEAP[$buffer + 8] < HEAP[$limit]) {
        __label__ = 6;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 51:
      
      
      
      
      if (HEAP[$buffer + 4] != _PyByteArray_Type) {
        __label__ = 52;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 52:
      
      
      var $273 = HEAP[$buffer + 4];
      var $274 = _PyType_IsSubtype($273, _PyByteArray_Type);
      
      if ($274 == 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 53:
      ___assert_fail(__str18199, __str6187, 531, ___PRETTY_FUNCTION___8875);
      throw "Reached an unreachable!";
     case 54:
      
      
      
      var $279 = HEAP[$buffer + 8];
      
      
      
      
      if (HEAP[$buffer + 4] != _PyByteArray_Type) {
        __label__ = 55;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 55:
      
      
      var $286 = HEAP[$buffer + 4];
      var $287 = _PyType_IsSubtype($286, _PyByteArray_Type);
      
      if ($287 == 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 56:
      ___assert_fail(__str18199, __str6187, 530, ___PRETTY_FUNCTION___8875);
      throw "Reached an unreachable!";
     case 57:
      
      
      
      
      
      if (HEAP[$buffer + 8] != 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 58:
      
      
      
      
      $iftmp_62 = HEAP[$buffer + 20];
      __label__ = 60;
      break;
     case 59:
      $iftmp_62 = __PyByteArray_empty_string;
      __label__ = 60;
      break;
     case 60:
      
      var $299 = _PyString_FromStringAndSize($iftmp_62, $279);
      $result = $299;
      
      
      
      var $303 = HEAP[$buffer] - 1;
      
      
      HEAP[$buffer] = $303;
      
      
      
      
      if (HEAP[$buffer] == 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 61:
      
      
      
      
      var $314 = HEAP[HEAP[$buffer + 4] + 24];
      
      FUNCTION_TABLE[$314]($buffer);
      __label__ = 62;
      break;
     case 62:
      
      $0 = $result;
      __label__ = 66;
      break;
     case 63:
      
      
      
      var $320 = HEAP[$buffer] - 1;
      
      
      HEAP[$buffer] = $320;
      
      
      
      
      if (HEAP[$buffer] == 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 64:
      
      
      
      
      var $331 = HEAP[HEAP[$buffer + 4] + 24];
      
      FUNCTION_TABLE[$331]($buffer);
      __label__ = 65;
      break;
     case 65:
      $0 = 0;
      __label__ = 66;
      break;
     case 66:
      
      $retval = $0;
      var $retval73 = $retval;
      STACKTOP = __stackBase__;
      return $retval73;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_iter($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      var $2 = __PyIOBase_check_closed($self_addr, __Py_TrueStruct);
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      
      var $7 = HEAP[$self_addr] + 1;
      
      
      HEAP[$self_addr] = $7;
      
      $0 = $self_addr;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_iternext($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $line;
      $self_addr = $self;
      var $1 = HEAP[__PyIO_str_readline];
      
      var $3 = _PyObject_CallMethodObjArgs($self_addr, $1, allocate(4, "i8*", ALLOC_STACK));
      $line = $3;
      
      
      if ($line == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 7;
      break;
     case 2:
      
      var $7 = _PyObject_Size($line);
      
      var $9 = $line;
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      
      
      var $12 = HEAP[$9] - 1;
      
      
      HEAP[$line] = $12;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $23 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$23]($line);
      __label__ = 5;
      break;
     case 5:
      $0 = 0;
      __label__ = 7;
      break;
     case 6:
      $0 = $9;
      __label__ = 7;
      break;
     case 7:
      
      $retval = $0;
      var $retval7 = $retval;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_readlines($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $hint = __stackBase__;
      var $length;
      var $result;
      var $ret;
      var $line;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$hint] = -1;
      $length = 0;
      
      var $2 = __PyArg_ParseTuple_SizeT($args_addr, __str19200, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $hint, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 27;
      break;
     case 2:
      var $4 = _PyList_New(0);
      $result = $4;
      
      
      if ($result == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 27;
      break;
     case 4:
      
      
      if (HEAP[$hint] <= 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 5:
      
      
      var $11 = __PyObject_CallMethod_SizeT($result, __str20201, __str21202, allocate([ $self_addr, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      $ret = $11;
      
      
      if ($ret == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      
      var $17 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $17;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $28 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$28]($result);
      __label__ = 8;
      break;
     case 8:
      $0 = 0;
      __label__ = 27;
      break;
     case 9:
      
      
      
      var $33 = HEAP[$ret] - 1;
      
      
      HEAP[$ret] = $33;
      
      
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $44 = HEAP[HEAP[$ret + 4] + 24];
      
      FUNCTION_TABLE[$44]($ret);
      __label__ = 11;
      break;
     case 11:
      
      $0 = $result;
      __label__ = 27;
      break;
     case 12:
      
      var $48 = _PyIter_Next($self_addr);
      $line = $48;
      
      if ($48 == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 13:
      var $50 = _PyErr_Occurred();
      
      if ($50 != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 14:
      
      
      
      var $55 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $55;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $66 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$66]($result);
      __label__ = 16;
      break;
     case 16:
      $0 = 0;
      __label__ = 27;
      break;
     case 17:
      
      
      var $70 = _PyList_Append($result, $line);
      
      var $72 = $line;
      if ($70 < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 18:
      
      
      var $75 = HEAP[$72] - 1;
      
      
      HEAP[$line] = $75;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $86 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$86]($line);
      __label__ = 20;
      break;
     case 20:
      
      
      
      var $91 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $91;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $102 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$102]($result);
      __label__ = 22;
      break;
     case 22:
      $0 = 0;
      __label__ = 27;
      break;
     case 23:
      var $104 = _PyObject_Size($72);
      
      var $106 = $length + $104;
      $length = $106;
      
      
      
      var $110 = HEAP[$line] - 1;
      
      
      HEAP[$line] = $110;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      
      
      var $121 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$121]($line);
      __label__ = 25;
      break;
     case 25:
      
      
      
      if ($length > HEAP[$hint]) {
        __label__ = 26;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 26:
      
      $0 = $result;
      __label__ = 27;
      break;
     case 27:
      
      $retval = $0;
      var $retval28 = $retval;
      STACKTOP = __stackBase__;
      return $retval28;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_writelines($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $lines = __stackBase__;
      var $iter;
      var $res;
      var $line;
      $self_addr = $self;
      $args_addr = $args;
      
      var $2 = __PyArg_ParseTuple_SizeT($args_addr, __str22203, allocate([ $lines, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 22;
      break;
     case 2:
      
      var $5 = __PyIOBase_check_closed($self_addr, __Py_TrueStruct);
      
      if ($5 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 22;
      break;
     case 4:
      var $7 = HEAP[$lines];
      var $8 = _PyObject_GetIter($7);
      $iter = $8;
      
      
      if ($iter == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 22;
      break;
     case 6:
      
      var $12 = _PyIter_Next($iter);
      $line = $12;
      
      if ($12 == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      var $14 = _PyErr_Occurred();
      var $15 = $14 != 0;
      
      
      
      var $19 = HEAP[$iter] - 1;
      
      
      HEAP[$iter] = $19;
      
      
      
      var $25 = HEAP[$iter] == 0;
      if ($15) {
        __label__ = 8;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 8:
      if ($25) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $30 = HEAP[HEAP[$iter + 4] + 24];
      
      FUNCTION_TABLE[$30]($iter);
      __label__ = 10;
      break;
     case 10:
      $0 = 0;
      __label__ = 22;
      break;
     case 11:
      var $32 = HEAP[__PyIO_str_write];
      
      
      var $35 = _PyObject_CallMethodObjArgs($self_addr, $32, allocate([ $line, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $35;
      
      
      
      var $39 = HEAP[$line] - 1;
      
      
      HEAP[$line] = $39;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $50 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$50]($line);
      __label__ = 13;
      break;
     case 13:
      
      
      if ($res == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      var $57 = HEAP[$iter] - 1;
      
      
      HEAP[$iter] = $57;
      
      
      
      
      if (HEAP[$iter] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $68 = HEAP[HEAP[$iter + 4] + 24];
      
      FUNCTION_TABLE[$68]($iter);
      __label__ = 16;
      break;
     case 16:
      $0 = 0;
      __label__ = 22;
      break;
     case 17:
      
      
      
      var $73 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $73;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 18:
      
      
      
      
      var $84 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$84]($res);
      __label__ = 6;
      break;
     case 19:
      if ($25) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $90 = HEAP[HEAP[$iter + 4] + 24];
      
      FUNCTION_TABLE[$90]($iter);
      __label__ = 21;
      break;
     case 21:
      
      var $93 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $93;
      $0 = __Py_NoneStruct;
      __label__ = 22;
      break;
     case 22:
      
      $retval = $0;
      var $retval23 = $retval;
      STACKTOP = __stackBase__;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _rawiobase_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $n = __stackBase__;
      var $b;
      var $res;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$n] = -1;
      
      var $2 = __PyArg_ParseTuple_SizeT($args_addr, __str41223, allocate([ $n, 0, 0, 0 ], [ "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 20;
      break;
     case 2:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      var $7 = __PyObject_CallMethod_SizeT($self_addr, __str42224, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $7;
      __label__ = 20;
      break;
     case 4:
      var $8 = HEAP[$n];
      var $9 = _PyByteArray_FromStringAndSize(0, $8);
      $b = $9;
      
      
      if ($b == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 20;
      break;
     case 6:
      var $12 = HEAP[__PyIO_str_readinto];
      
      
      var $15 = _PyObject_CallMethodObjArgs($self_addr, $12, allocate([ $b, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $15;
      
      
      
      
      
      if ($res == 0 | $res == __Py_NoneStruct) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      
      
      
      var $23 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $23;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $34 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$34]($b);
      __label__ = 9;
      break;
     case 9:
      
      $0 = $res;
      __label__ = 20;
      break;
     case 10:
      var $37 = HEAP[_PyExc_ValueError];
      
      var $39 = _PyNumber_AsSsize_t($res, $37);
      HEAP[$n] = $39;
      
      
      
      var $43 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $43;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $54 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$54]($res);
      __label__ = 12;
      break;
     case 12:
      
      var $57 = HEAP[$n] == -1;
      if ($57) {
        __label__ = 13;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 13:
      var $58 = _PyErr_Occurred();
      
      if ($58 != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      var $63 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $63;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $74 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$74]($b);
      __label__ = 16;
      break;
     case 16:
      $0 = 0;
      __label__ = 20;
      break;
     case 17:
      var $76 = HEAP[$n];
      
      var $78 = _PyByteArray_AsString($b);
      var $79 = _PyString_FromStringAndSize($78, $76);
      $res = $79;
      
      
      
      var $83 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $83;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $94 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$94]($b);
      __label__ = 19;
      break;
     case 19:
      
      $0 = $res;
      __label__ = 20;
      break;
     case 20:
      
      $retval = $0;
      var $retval21 = $retval;
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _rawiobase_readall($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $r;
      var $chunks;
      var $result;
      var $data;
      $self_addr = $self;
      $args_addr = $args;
      var $1 = _PyList_New(0);
      $chunks = $1;
      
      
      if ($chunks == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 31;
      break;
     case 2:
      
      var $5 = __PyObject_CallMethod_SizeT($self_addr, __str15196, __str13194, allocate([ 8192, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $data = $5;
      
      if ($5 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      
      
      
      var $10 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $10;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $21 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$21]($chunks);
      __label__ = 5;
      break;
     case 5:
      $0 = 0;
      __label__ = 31;
      break;
     case 6:
      
      
      if ($data == __Py_NoneStruct) {
        __label__ = 7;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 7:
      
      
      
      
      
      if (HEAP[$chunks + 8] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      
      var $33 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $33;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $44 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$44]($chunks);
      __label__ = 10;
      break;
     case 10:
      
      $0 = $data;
      __label__ = 31;
      break;
     case 11:
      
      
      
      var $50 = HEAP[$data] - 1;
      
      
      HEAP[$data] = $50;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 12:
      
      
      
      
      var $61 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$61]($data);
      __label__ = 28;
      break;
     case 13:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$data + 4] + 84] & 134217728) == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 14:
      
      
      
      var $73 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $73;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $84 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$84]($chunks);
      __label__ = 16;
      break;
     case 16:
      
      
      
      var $89 = HEAP[$data] - 1;
      
      
      HEAP[$data] = $89;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $100 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$100]($data);
      __label__ = 18;
      break;
     case 18:
      var $102 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($102, __str3);
      $0 = 0;
      __label__ = 31;
      break;
     case 19:
      
      
      
      
      
      if (HEAP[$data + 8] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 20:
      
      
      
      var $111 = HEAP[$data] - 1;
      
      
      HEAP[$data] = $111;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 21:
      
      
      
      
      var $122 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$122]($data);
      __label__ = 28;
      break;
     case 22:
      
      
      var $126 = _PyList_Append($chunks, $data);
      $r = $126;
      
      
      
      var $130 = HEAP[$data] - 1;
      
      
      HEAP[$data] = $130;
      
      
      
      
      if (HEAP[$data] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $141 = HEAP[HEAP[$data + 4] + 24];
      
      FUNCTION_TABLE[$141]($data);
      __label__ = 24;
      break;
     case 24:
      
      
      if ($r < 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 25:
      
      
      
      var $148 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $148;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $159 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$159]($chunks);
      __label__ = 27;
      break;
     case 27:
      $0 = 0;
      __label__ = 31;
      break;
     case 28:
      var $161 = HEAP[__PyIO_empty_bytes];
      
      var $163 = __PyString_Join($161, $chunks);
      $result = $163;
      
      
      
      var $167 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $167;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $178 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$178]($chunks);
      __label__ = 30;
      break;
     case 30:
      
      $0 = $result;
      __label__ = 31;
      break;
     case 31:
      
      $retval = $0;
      var $retval34 = $retval;
      return $retval34;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _blockingioerror_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $myerrno = __stackBase__;
      var $strerror = __stackBase__ + 4;
      var $baseargs;
      var $written = __stackBase__ + 8;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      HEAP[$myerrno] = 0;
      HEAP[$strerror] = 0;
      $baseargs = 0;
      HEAP[$written] = 0;
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$args_addr + 4] + 84] & 67108864) == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str232, __str1233, 104, ___PRETTY_FUNCTION___8454);
      throw "Reached an unreachable!";
     case 2:
      
      
      HEAP[$self_addr + 32] = 0;
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str2234, allocate([ $myerrno, 0, 0, 0, $strerror, 0, 0, 0, $written, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = -1;
      __label__ = 13;
      break;
     case 4:
      var $13 = HEAP[$strerror];
      var $14 = HEAP[$myerrno];
      var $15 = _PyTuple_Pack(2, allocate([ $14, 0, 0, 0, $13, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      $baseargs = $15;
      
      
      if ($baseargs == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = -1;
      __label__ = 13;
      break;
     case 6:
      
      
      
      var $21 = HEAP[HEAP[_PyExc_IOError] + 148];
      
      
      
      
      var $26 = FUNCTION_TABLE[$21]($self_addr, $baseargs, $kwds_addr);
      var $27 = $26 == -1;
      
      
      
      var $31 = HEAP[$baseargs] - 1;
      
      
      HEAP[$baseargs] = $31;
      
      
      
      var $37 = HEAP[$baseargs] == 0;
      if ($27) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      if ($37) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $42 = HEAP[HEAP[$baseargs + 4] + 24];
      
      FUNCTION_TABLE[$42]($baseargs);
      __label__ = 9;
      break;
     case 9:
      $0 = -1;
      __label__ = 13;
      break;
     case 10:
      if ($37) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $48 = HEAP[HEAP[$baseargs + 4] + 24];
      
      FUNCTION_TABLE[$48]($baseargs);
      __label__ = 12;
      break;
     case 12:
      var $50 = HEAP[$written];
      
      
      HEAP[$self_addr + 32] = $50;
      $0 = 0;
      __label__ = 13;
      break;
     case 13:
      
      $retval = $0;
      var $retval13 = $retval;
      STACKTOP = __stackBase__;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _io_open($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 161;
    _memset(__stackBase__, 0, 161);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $kwlist = __stackBase__;
      var $file = __stackBase__ + 32;
      var $mode = __stackBase__ + 36;
      var $buffering = __stackBase__ + 40;
      var $closefd = __stackBase__ + 44;
      var $encoding = __stackBase__ + 48;
      var $errors = __stackBase__ + 52;
      var $newline = __stackBase__ + 56;
      var $i;
      var $reading;
      var $writing;
      var $appending;
      var $updating;
      var $text;
      var $binary;
      var $universal;
      var $rawmode = __stackBase__ + 60;
      var $m;
      var $line_buffering;
      var $isatty;
      var $raw;
      var $modeobj;
      var $buffer;
      var $wrapper;
      var $repr;
      var $c;
      var $res;
      var $st = __stackBase__ + 65;
      var $fileno;
      var $res66;
      var $Buffered_class;
      var $_py_tmp;
      var $_py_tmp100;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str6239;
      
      HEAP[$kwlist + 4] = __str7240;
      
      HEAP[$kwlist + 8] = __str8241;
      
      HEAP[$kwlist + 12] = __str9242;
      
      HEAP[$kwlist + 16] = __str10243;
      
      HEAP[$kwlist + 20] = __str11244;
      
      HEAP[$kwlist + 24] = __str12245;
      
      HEAP[$kwlist + 28] = 0;
      HEAP[$mode] = __str13246;
      HEAP[$buffering] = -1;
      HEAP[$closefd] = 1;
      HEAP[$encoding] = 0;
      HEAP[$errors] = 0;
      HEAP[$newline] = 0;
      $reading = 0;
      $writing = 0;
      $appending = 0;
      $updating = 0;
      $text = 0;
      $binary = 0;
      $universal = 0;
      $modeobj = 0;
      $buffer = 0;
      $wrapper = 0;
      
      
      var $kwlist1 = $kwlist;
      var $11 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str14247, $kwlist1, allocate([ $file, 0, 0, 0, $mode, 0, 0, 0, $buffering, 0, 0, 0, $encoding, 0, 0, 0, $errors, 0, 0, 0, $newline, 0, 0, 0, $closefd, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 120;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$file] + 4] + 84] & 268435456) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$file] + 4] + 84] & 134217728) == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 4:
      var $27 = HEAP[$file];
      var $28 = _PyNumber_Check($27);
      
      if ($28 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 5:
      var $30 = HEAP[$file];
      var $31 = _PyObject_Repr($30);
      $repr = $31;
      
      
      if ($repr != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      
      
      var $38 = HEAP[_PyExc_TypeError];
      var $39 = _PyErr_Format($38, __str15248, allocate([ $repr + 20, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $43 = HEAP[$repr] - 1;
      
      
      HEAP[$repr] = $43;
      
      
      
      
      if (HEAP[$repr] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $54 = HEAP[HEAP[$repr + 4] + 24];
      
      FUNCTION_TABLE[$54]($repr);
      __label__ = 8;
      break;
     case 8:
      $0 = 0;
      __label__ = 120;
      break;
     case 9:
      $i = 0;
      __label__ = 21;
      break;
     case 10:
      
      
      
      
      $c = HEAP[HEAP[$mode] + $i];
      
      var $61 = $c;
      if ($61 == 43) {
        __label__ = 14;
        break;
      } else if ($61 == 85) {
        __label__ = 17;
        break;
      } else if ($61 == 97) {
        __label__ = 13;
        break;
      } else if ($61 == 98) {
        __label__ = 16;
        break;
      } else if ($61 == 114) {
        __label__ = 11;
        break;
      } else if ($61 == 116) {
        __label__ = 15;
        break;
      } else if ($61 == 119) {
        __label__ = 12;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 11:
      $reading = 1;
      __label__ = 18;
      break;
     case 12:
      $writing = 1;
      __label__ = 18;
      break;
     case 13:
      $appending = 1;
      __label__ = 18;
      break;
     case 14:
      $updating = 1;
      __label__ = 18;
      break;
     case 15:
      $text = 1;
      __label__ = 18;
      break;
     case 16:
      $binary = 1;
      __label__ = 18;
      break;
     case 17:
      $universal = 1;
      $reading = 1;
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      
      var $67 = HEAP[$mode] + $i + 1;
      var $68 = _strchr($67, $c);
      
      if ($68 != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      var $70 = HEAP[$mode];
      var $71 = HEAP[_PyExc_ValueError];
      var $72 = _PyErr_Format($71, __str16249, allocate([ $70, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 120;
      break;
     case 20:
      
      var $74 = $i + 1;
      $i = $74;
      __label__ = 21;
      break;
     case 21:
      var $75 = HEAP[$mode];
      var $76 = _strlen($75);
      
      
      if ($76 > $i) {
        __label__ = 10;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      $m = $rawmode;
      
      
      if ($reading != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      HEAP[$m] = 114;
      
      var $83 = $m + 1;
      $m = $83;
      __label__ = 24;
      break;
     case 24:
      
      
      if ($writing != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      HEAP[$m] = 119;
      
      var $88 = $m + 1;
      $m = $88;
      __label__ = 26;
      break;
     case 26:
      
      
      if ($appending != 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      HEAP[$m] = 97;
      
      var $93 = $m + 1;
      $m = $93;
      __label__ = 28;
      break;
     case 28:
      
      
      if ($updating != 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      HEAP[$m] = 43;
      
      var $98 = $m + 1;
      $m = $98;
      __label__ = 30;
      break;
     case 30:
      
      HEAP[$m] = 0;
      
      
      if ($universal != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 31:
      
      
      if ($writing != 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 32:
      
      
      if ($appending != 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      var $106 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($106, __str17250);
      $0 = 0;
      __label__ = 120;
      break;
     case 34:
      $reading = 1;
      __label__ = 35;
      break;
     case 35:
      
      
      if ($text != 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 36:
      
      
      if ($binary != 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      var $111 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($111, __str18251);
      $0 = 0;
      __label__ = 120;
      break;
     case 38:
      
      
      
      
      
      
      if ($writing + $reading + $appending > 1) {
        __label__ = 39;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 39:
      var $118 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($118, __str19252);
      $0 = 0;
      __label__ = 120;
      break;
     case 40:
      
      
      if ($binary != 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 41:
      
      
      if (HEAP[$encoding] != 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 42:
      var $123 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($123, __str20253);
      $0 = 0;
      __label__ = 120;
      break;
     case 43:
      
      
      if ($binary != 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 44:
      
      
      if (HEAP[$errors] != 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 45:
      var $127 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($127, __str21254);
      $0 = 0;
      __label__ = 120;
      break;
     case 46:
      
      
      if ($binary != 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 47:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      var $131 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($131, __str22255);
      $0 = 0;
      __label__ = 120;
      break;
     case 49:
      var $132 = HEAP[$closefd];
      var $133 = HEAP[$file];
      var $rawmode51 = $rawmode;
      var $134 = __PyObject_CallFunction_SizeT(_PyFileIO_Type, __str23256, allocate([ $133, 0, 0, 0, $rawmode51, 0, 0, 0, $132, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $raw = $134;
      
      if ($134 == 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      $0 = 0;
      __label__ = 120;
      break;
     case 51:
      var $136 = HEAP[$mode];
      var $137 = _PyUnicodeUCS2_FromString($136);
      $modeobj = $137;
      
      
      if ($modeobj == 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 52:
      
      var $141 = __PyObject_CallMethod_SizeT($raw, __str24257, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $141;
      
      
      if ($res == 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 53:
      
      var $145 = _PyLong_AsLong($res);
      $isatty = $145;
      
      
      
      var $149 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $149;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      
      
      
      var $160 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$160]($res);
      __label__ = 55;
      break;
     case 55:
      
      var $163 = $isatty == -1;
      if ($163) {
        __label__ = 56;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 56:
      var $164 = _PyErr_Occurred();
      
      if ($164 != 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 57:
      
      
      if (HEAP[$buffering] == 1) {
        __label__ = 61;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      
      if (HEAP[$buffering] >= 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 59:
      $line_buffering = 0;
      __label__ = 71;
      break;
     case 60:
      
      
      if ($isatty != 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 61:
      HEAP[$buffering] = -1;
      $line_buffering = 1;
      __label__ = 63;
      break;
     case 62:
      var $_pr2_pr = HEAP[$buffering];
      $line_buffering = 0;
      
      if ($_pr2_pr < 0) {
        __lastLabel__ = 62;
        __label__ = 63;
        break;
      } else {
        __lastLabel__ = 62;
        __label__ = 75;
        break;
      }
     case 63:
      HEAP[$buffering] = 8192;
      
      var $174 = __PyObject_CallMethod_SizeT($raw, __str25258, 0, allocate(1, "i32", ALLOC_STACK));
      $res66 = $174;
      
      if ($174 == 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 64:
      
      var $177 = _PyInt_AsLong($res66);
      $fileno = $177;
      
      
      
      var $181 = HEAP[$res66] - 1;
      
      
      HEAP[$res66] = $181;
      
      
      
      
      if (HEAP[$res66] == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 65:
      
      
      
      
      var $192 = HEAP[HEAP[$res66 + 4] + 24];
      
      FUNCTION_TABLE[$192]($res66);
      __label__ = 66;
      break;
     case 66:
      
      var $195 = $fileno == -1;
      if ($195) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      var $196 = _PyErr_Occurred();
      
      if ($196 != 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 68:
      
      var $199 = ___01fstat64_($fileno, $st);
      
      if ($199 >= 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 69:
      
      
      
      if (HEAP[$st + 52] > 1) {
        __label__ = 70;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 70:
      
      var $205 = HEAP[$st + 52];
      HEAP[$buffering] = $205;
      __lastLabel__ = 70;
      __label__ = 72;
      break;
     case 71:
      var $_pr4 = HEAP[$buffering];
      __lastLabel__ = 71;
      __label__ = 72;
      break;
     case 72:
      var $206 = __lastLabel__ == 71 ? $_pr4 : $205;
      
      if ($206 < 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 73:
      var $208 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($208, __str26259);
      __label__ = 107;
      break;
     case 74:
      var $_pr7 = HEAP[$buffering];
      __lastLabel__ = 74;
      __label__ = 75;
      break;
     case 75:
      var $209 = __lastLabel__ == 74 ? $_pr7 : $_pr2_pr;
      
      if ($209 == 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 76:
      
      
      if ($binary == 0) {
        __label__ = 77;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 77:
      var $213 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($213, __str27260);
      __label__ = 107;
      break;
     case 78:
      
      
      
      var $217 = HEAP[$modeobj] - 1;
      
      
      HEAP[$modeobj] = $217;
      
      
      
      
      if (HEAP[$modeobj] == 0) {
        __label__ = 79;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 79:
      
      
      
      
      var $228 = HEAP[HEAP[$modeobj + 4] + 24];
      
      FUNCTION_TABLE[$228]($modeobj);
      __label__ = 80;
      break;
     case 80:
      
      $0 = $raw;
      __label__ = 120;
      break;
     case 81:
      
      
      if ($updating != 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 82:
      $Buffered_class = _PyBufferedRandom_Type;
      __label__ = 89;
      break;
     case 83:
      
      
      if ($writing != 0) {
        __label__ = 85;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 84:
      
      
      if ($appending != 0) {
        __label__ = 85;
        break;
      } else {
        __label__ = 86;
        break;
      }
     case 85:
      $Buffered_class = _PyBufferedWriter_Type;
      __label__ = 89;
      break;
     case 86:
      
      
      if ($reading != 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 87:
      $Buffered_class = _PyBufferedReader_Type;
      __label__ = 89;
      break;
     case 88:
      var $239 = HEAP[$mode];
      var $240 = HEAP[_PyExc_ValueError];
      var $241 = _PyErr_Format($240, __str28261, allocate([ $239, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 107;
      break;
     case 89:
      var $242 = HEAP[$buffering];
      
      
      var $245 = __PyObject_CallFunction_SizeT($Buffered_class, __str29262, allocate([ $raw, 0, 0, 0, $242, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $buffer = $245;
      
      
      if ($raw != 0) {
        __lastLabel__ = 89;
        __label__ = 90;
        break;
      } else {
        __lastLabel__ = 89;
        __label__ = 93;
        break;
      }
     case 90:
      
      $_py_tmp = $raw;
      $raw = 0;
      
      
      
      var $252 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $252;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 91;
        break;
      } else {
        __label__ = 92;
        break;
      }
     case 91:
      
      
      
      
      var $263 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$263]($_py_tmp);
      __label__ = 92;
      break;
     case 92:
      var $_pr5 = $buffer;
      __lastLabel__ = 92;
      __label__ = 93;
      break;
     case 93:
      var $265 = __lastLabel__ == 92 ? $_pr5 : $245;
      
      if ($265 == 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 94;
        break;
      }
     case 94:
      
      
      if ($binary != 0) {
        __label__ = 95;
        break;
      } else {
        __label__ = 98;
        break;
      }
     case 95:
      
      
      
      var $272 = HEAP[$modeobj] - 1;
      
      
      HEAP[$modeobj] = $272;
      
      
      
      
      if (HEAP[$modeobj] == 0) {
        __label__ = 96;
        break;
      } else {
        __label__ = 97;
        break;
      }
     case 96:
      
      
      
      
      var $283 = HEAP[HEAP[$modeobj + 4] + 24];
      
      FUNCTION_TABLE[$283]($modeobj);
      __label__ = 97;
      break;
     case 97:
      
      $0 = $buffer;
      __label__ = 120;
      break;
     case 98:
      var $286 = HEAP[$newline];
      var $287 = HEAP[$errors];
      var $288 = HEAP[$encoding];
      
      
      var $291 = __PyObject_CallFunction_SizeT(_PyTextIOWrapper_Type, __str30263, allocate([ $buffer, 0, 0, 0, $288, 0, 0, 0, $287, 0, 0, 0, $286, 0, 0, 0, $line_buffering, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $wrapper = $291;
      
      
      if ($buffer != 0) {
        __lastLabel__ = 98;
        __label__ = 99;
        break;
      } else {
        __lastLabel__ = 98;
        __label__ = 102;
        break;
      }
     case 99:
      
      $_py_tmp100 = $buffer;
      $buffer = 0;
      
      
      
      var $298 = HEAP[$_py_tmp100] - 1;
      
      
      HEAP[$_py_tmp100] = $298;
      
      
      
      
      if (HEAP[$_py_tmp100] == 0) {
        __label__ = 100;
        break;
      } else {
        __label__ = 101;
        break;
      }
     case 100:
      
      
      
      
      var $309 = HEAP[HEAP[$_py_tmp100 + 4] + 24];
      
      FUNCTION_TABLE[$309]($_py_tmp100);
      __label__ = 101;
      break;
     case 101:
      var $_pr6 = $wrapper;
      __lastLabel__ = 101;
      __label__ = 102;
      break;
     case 102:
      var $311 = __lastLabel__ == 101 ? $_pr6 : $291;
      
      if ($311 == 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 103;
        break;
      }
     case 103:
      
      
      var $315 = _PyObject_SetAttrString($wrapper, __str7240, $modeobj);
      
      if ($315 < 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 104;
        break;
      }
     case 104:
      
      
      
      var $320 = HEAP[$modeobj] - 1;
      
      
      HEAP[$modeobj] = $320;
      
      
      
      
      if (HEAP[$modeobj] == 0) {
        __label__ = 105;
        break;
      } else {
        __label__ = 106;
        break;
      }
     case 105:
      
      
      
      
      var $331 = HEAP[HEAP[$modeobj + 4] + 24];
      
      FUNCTION_TABLE[$331]($modeobj);
      __label__ = 106;
      break;
     case 106:
      
      $0 = $wrapper;
      __label__ = 120;
      break;
     case 107:
      
      
      if ($raw != 0) {
        __label__ = 108;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 108:
      
      
      
      var $339 = HEAP[$raw] - 1;
      
      
      HEAP[$raw] = $339;
      
      
      
      
      if (HEAP[$raw] == 0) {
        __label__ = 109;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 109:
      
      
      
      
      var $350 = HEAP[HEAP[$raw + 4] + 24];
      
      FUNCTION_TABLE[$350]($raw);
      __label__ = 110;
      break;
     case 110:
      
      
      if ($modeobj != 0) {
        __label__ = 111;
        break;
      } else {
        __label__ = 113;
        break;
      }
     case 111:
      
      
      
      var $357 = HEAP[$modeobj] - 1;
      
      
      HEAP[$modeobj] = $357;
      
      
      
      
      if (HEAP[$modeobj] == 0) {
        __label__ = 112;
        break;
      } else {
        __label__ = 113;
        break;
      }
     case 112:
      
      
      
      
      var $368 = HEAP[HEAP[$modeobj + 4] + 24];
      
      FUNCTION_TABLE[$368]($modeobj);
      __label__ = 113;
      break;
     case 113:
      
      
      if ($buffer != 0) {
        __label__ = 114;
        break;
      } else {
        __label__ = 116;
        break;
      }
     case 114:
      
      
      
      var $375 = HEAP[$buffer] - 1;
      
      
      HEAP[$buffer] = $375;
      
      
      
      
      if (HEAP[$buffer] == 0) {
        __label__ = 115;
        break;
      } else {
        __label__ = 116;
        break;
      }
     case 115:
      
      
      
      
      var $386 = HEAP[HEAP[$buffer + 4] + 24];
      
      FUNCTION_TABLE[$386]($buffer);
      __label__ = 116;
      break;
     case 116:
      
      
      if ($wrapper != 0) {
        __label__ = 117;
        break;
      } else {
        __label__ = 119;
        break;
      }
     case 117:
      
      
      
      var $393 = HEAP[$wrapper] - 1;
      
      
      HEAP[$wrapper] = $393;
      
      
      
      
      if (HEAP[$wrapper] == 0) {
        __label__ = 118;
        break;
      } else {
        __label__ = 119;
        break;
      }
     case 118:
      
      
      
      
      var $404 = HEAP[HEAP[$wrapper + 4] + 24];
      
      FUNCTION_TABLE[$404]($wrapper);
      __label__ = 119;
      break;
     case 119:
      $0 = 0;
      __label__ = 120;
      break;
     case 120:
      
      $retval = $0;
      var $retval120 = $retval;
      STACKTOP = __stackBase__;
      return $retval120;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _PyNumber_AsOff_t($item, $err) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $item_addr;
      var $err_addr;
      var $retval;
      var $0;
      var $result;
      var $runerr;
      var $value;
      $item_addr = $item;
      $err_addr = $err;
      
      var $2 = _PyNumber_Index($item_addr);
      $value = $2;
      
      
      if ($value == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 17;
      break;
     case 2:
      
      
      
      
      
      
      
      var $12 = $value;
      if ((HEAP[HEAP[$value + 4] + 84] & 8388608) != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      $result = HEAP[$12 + 8];
      __label__ = 14;
      break;
     case 4:
      var $17 = _PyLong_AsLongLong($12);
      $result = $17;
      
      var $19 = $result != -1;
      if ($19) {
        __label__ = 14;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      var $20 = _PyErr_Occurred();
      $runerr = $20;
      
      
      if ($runerr == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      var $23 = HEAP[_PyExc_OverflowError];
      
      var $25 = _PyErr_GivenExceptionMatches($runerr, $23);
      
      if ($25 == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      _PyErr_Clear();
      
      
      if ($err_addr == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$value + 4] + 84] & 16777216) == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      ___assert_fail(__str31264, __str1233, 564, ___PRETTY_FUNCTION___8811);
      throw "Reached an unreachable!";
     case 10:
      
      var $37 = __PyLong_Sign($value);
      
      if ($37 < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      $result = -0x8000000000000000;
      __label__ = 14;
      break;
     case 12:
      $result = 0x8000000000000000;
      __label__ = 14;
      break;
     case 13:
      
      
      
      
      var $43 = HEAP[HEAP[$item_addr + 4] + 12];
      
      var $45 = _PyErr_Format($err_addr, __str32265, allocate([ $43, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 14;
      break;
     case 14:
      
      
      
      var $49 = HEAP[$value] - 1;
      
      
      HEAP[$value] = $49;
      
      
      
      
      if (HEAP[$value] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $60 = HEAP[HEAP[$value + 4] + 24];
      
      FUNCTION_TABLE[$60]($value);
      __label__ = 16;
      break;
     case 16:
      
      $0 = $result;
      __label__ = 17;
      break;
     case 17:
      
      $retval = $0;
      var $retval17 = $retval;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIO_ConvertSsize_t($obj, $result) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $obj_addr;
      var $result_addr;
      var $retval;
      var $0;
      var $limit;
      $obj_addr = $obj;
      $result_addr = $result;
      
      
      if ($obj_addr == __Py_NoneStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $limit = -1;
      __label__ = 7;
      break;
     case 2:
      
      var $4 = _PyNumber_Check($obj_addr);
      
      if ($4 != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      var $6 = HEAP[_PyExc_OverflowError];
      
      var $8 = _PyNumber_AsSsize_t($obj_addr, $6);
      $limit = $8;
      
      var $10 = $limit == -1;
      if ($10) {
        __label__ = 4;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 4:
      var $11 = _PyErr_Occurred();
      
      if ($11 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 8;
      break;
     case 6:
      
      
      
      
      var $17 = HEAP[HEAP[$obj_addr + 4] + 12];
      var $18 = HEAP[_PyExc_TypeError];
      var $19 = _PyErr_Format($18, __str33266, allocate([ $17, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 8;
      break;
     case 7:
      
      
      
      HEAP[$result_addr] = $limit;
      $0 = 1;
      __label__ = 8;
      break;
     case 8:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _init_io() {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $m;
      var $_py_tmp;
      var $_py_tmp105;
      var $0 = _Py_InitModule4(__str35269, _module_methods, _module_doc, 0, 1013);
      $m = $0;
      
      
      if ($m == 0) {
        __label__ = 95;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      var $3 = _PyImport_ImportModule(__str36270);
      HEAP[__PyIO_os_module] = $3;
      
      
      if (HEAP[__PyIO_os_module] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      var $7 = _PyModule_AddIntConstant($m, __str37271, 8192);
      
      if ($7 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      var $9 = HEAP[_PyExc_IOError];
      var $10 = HEAP[_PyExc_ValueError];
      var $11 = __PyObject_CallFunction_SizeT(_PyType_Type, __str38272, allocate([ __str39273, 0, 0, 0, $10, 0, 0, 0, $9, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[__PyIO_unsupported_operation] = $11;
      
      
      if (HEAP[__PyIO_unsupported_operation] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 4:
      
      
      
      var $17 = HEAP[HEAP[__PyIO_unsupported_operation]] + 1;
      var $18 = HEAP[__PyIO_unsupported_operation];
      HEAP[$18] = $17;
      var $19 = HEAP[__PyIO_unsupported_operation];
      
      var $21 = _PyModule_AddObject($m, __str39273, $19);
      
      if ($21 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      var $24 = HEAP[_PyExc_IOError];
      HEAP[__PyExc_BlockingIOError + 128] = $24;
      var $25 = _PyType_Ready(__PyExc_BlockingIOError);
      
      if ($25 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      var $28 = HEAP[__PyExc_BlockingIOError] + 1;
      HEAP[__PyExc_BlockingIOError] = $28;
      
      var $30 = _PyModule_AddObject($m, __str4236, __PyExc_BlockingIOError);
      
      if ($30 < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      var $33 = HEAP[__PyExc_BlockingIOError] - 1;
      HEAP[__PyExc_BlockingIOError] = $33;
      
      
      if (HEAP[__PyExc_BlockingIOError] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 8:
      
      
      var $38 = HEAP[HEAP[__PyExc_BlockingIOError + 4] + 24];
      FUNCTION_TABLE[$38](__PyExc_BlockingIOError);
      __label__ = 87;
      break;
     case 9:
      var $39 = _PyType_Ready(_PyIOBase_Type);
      
      if ($39 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      var $42 = HEAP[_PyIOBase_Type] + 1;
      HEAP[_PyIOBase_Type] = $42;
      
      var $44 = _PyModule_AddObject($m, __str40274, _PyIOBase_Type);
      
      if ($44 < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      var $47 = HEAP[_PyIOBase_Type] - 1;
      HEAP[_PyIOBase_Type] = $47;
      
      
      if (HEAP[_PyIOBase_Type] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 12:
      
      
      var $52 = HEAP[HEAP[_PyIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$52](_PyIOBase_Type);
      __label__ = 87;
      break;
     case 13:
      var $53 = _PyType_Ready(_PyRawIOBase_Type);
      
      if ($53 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      var $56 = HEAP[_PyRawIOBase_Type] + 1;
      HEAP[_PyRawIOBase_Type] = $56;
      
      var $58 = _PyModule_AddObject($m, __str41275, _PyRawIOBase_Type);
      
      if ($58 < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 15:
      
      var $61 = HEAP[_PyRawIOBase_Type] - 1;
      HEAP[_PyRawIOBase_Type] = $61;
      
      
      if (HEAP[_PyRawIOBase_Type] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 16:
      
      
      var $66 = HEAP[HEAP[_PyRawIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$66](_PyRawIOBase_Type);
      __label__ = 87;
      break;
     case 17:
      var $67 = _PyType_Ready(_PyBufferedIOBase_Type);
      
      if ($67 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      var $70 = HEAP[_PyBufferedIOBase_Type] + 1;
      HEAP[_PyBufferedIOBase_Type] = $70;
      
      var $72 = _PyModule_AddObject($m, __str42276, _PyBufferedIOBase_Type);
      
      if ($72 < 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      var $75 = HEAP[_PyBufferedIOBase_Type] - 1;
      HEAP[_PyBufferedIOBase_Type] = $75;
      
      
      if (HEAP[_PyBufferedIOBase_Type] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 20:
      
      
      var $80 = HEAP[HEAP[_PyBufferedIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$80](_PyBufferedIOBase_Type);
      __label__ = 87;
      break;
     case 21:
      var $81 = _PyType_Ready(_PyTextIOBase_Type);
      
      if ($81 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      var $84 = HEAP[_PyTextIOBase_Type] + 1;
      HEAP[_PyTextIOBase_Type] = $84;
      
      var $86 = _PyModule_AddObject($m, __str43277, _PyTextIOBase_Type);
      
      if ($86 < 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 23:
      
      var $89 = HEAP[_PyTextIOBase_Type] - 1;
      HEAP[_PyTextIOBase_Type] = $89;
      
      
      if (HEAP[_PyTextIOBase_Type] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 24:
      
      
      var $94 = HEAP[HEAP[_PyTextIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$94](_PyTextIOBase_Type);
      __label__ = 87;
      break;
     case 25:
      HEAP[_PyFileIO_Type + 128] = _PyRawIOBase_Type;
      var $95 = _PyType_Ready(_PyFileIO_Type);
      
      if ($95 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      var $98 = HEAP[_PyFileIO_Type] + 1;
      HEAP[_PyFileIO_Type] = $98;
      
      var $100 = _PyModule_AddObject($m, __str44278, _PyFileIO_Type);
      
      if ($100 < 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 27:
      
      var $103 = HEAP[_PyFileIO_Type] - 1;
      HEAP[_PyFileIO_Type] = $103;
      
      
      if (HEAP[_PyFileIO_Type] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 28:
      
      
      var $108 = HEAP[HEAP[_PyFileIO_Type + 4] + 24];
      FUNCTION_TABLE[$108](_PyFileIO_Type);
      __label__ = 87;
      break;
     case 29:
      HEAP[_PyBytesIO_Type + 128] = _PyBufferedIOBase_Type;
      var $109 = _PyType_Ready(_PyBytesIO_Type);
      
      if ($109 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 30:
      
      var $112 = HEAP[_PyBytesIO_Type] + 1;
      HEAP[_PyBytesIO_Type] = $112;
      
      var $114 = _PyModule_AddObject($m, __str45279, _PyBytesIO_Type);
      
      if ($114 < 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      var $117 = HEAP[_PyBytesIO_Type] - 1;
      HEAP[_PyBytesIO_Type] = $117;
      
      
      if (HEAP[_PyBytesIO_Type] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 32:
      
      
      var $122 = HEAP[HEAP[_PyBytesIO_Type + 4] + 24];
      FUNCTION_TABLE[$122](_PyBytesIO_Type);
      __label__ = 87;
      break;
     case 33:
      HEAP[_PyStringIO_Type + 128] = _PyTextIOBase_Type;
      var $123 = _PyType_Ready(_PyStringIO_Type);
      
      if ($123 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 34:
      
      var $126 = HEAP[_PyStringIO_Type] + 1;
      HEAP[_PyStringIO_Type] = $126;
      
      var $128 = _PyModule_AddObject($m, __str46280, _PyStringIO_Type);
      
      if ($128 < 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 35:
      
      var $131 = HEAP[_PyStringIO_Type] - 1;
      HEAP[_PyStringIO_Type] = $131;
      
      
      if (HEAP[_PyStringIO_Type] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 36:
      
      
      var $136 = HEAP[HEAP[_PyStringIO_Type + 4] + 24];
      FUNCTION_TABLE[$136](_PyStringIO_Type);
      __label__ = 87;
      break;
     case 37:
      HEAP[_PyBufferedReader_Type + 128] = _PyBufferedIOBase_Type;
      var $137 = _PyType_Ready(_PyBufferedReader_Type);
      
      if ($137 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 38:
      
      var $140 = HEAP[_PyBufferedReader_Type] + 1;
      HEAP[_PyBufferedReader_Type] = $140;
      
      var $142 = _PyModule_AddObject($m, __str47281, _PyBufferedReader_Type);
      
      if ($142 < 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 39:
      
      var $145 = HEAP[_PyBufferedReader_Type] - 1;
      HEAP[_PyBufferedReader_Type] = $145;
      
      
      if (HEAP[_PyBufferedReader_Type] == 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 40:
      
      
      var $150 = HEAP[HEAP[_PyBufferedReader_Type + 4] + 24];
      FUNCTION_TABLE[$150](_PyBufferedReader_Type);
      __label__ = 87;
      break;
     case 41:
      HEAP[_PyBufferedWriter_Type + 128] = _PyBufferedIOBase_Type;
      var $151 = _PyType_Ready(_PyBufferedWriter_Type);
      
      if ($151 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 42:
      
      var $154 = HEAP[_PyBufferedWriter_Type] + 1;
      HEAP[_PyBufferedWriter_Type] = $154;
      
      var $156 = _PyModule_AddObject($m, __str48282, _PyBufferedWriter_Type);
      
      if ($156 < 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 43:
      
      var $159 = HEAP[_PyBufferedWriter_Type] - 1;
      HEAP[_PyBufferedWriter_Type] = $159;
      
      
      if (HEAP[_PyBufferedWriter_Type] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 44:
      
      
      var $164 = HEAP[HEAP[_PyBufferedWriter_Type + 4] + 24];
      FUNCTION_TABLE[$164](_PyBufferedWriter_Type);
      __label__ = 87;
      break;
     case 45:
      HEAP[_PyBufferedRWPair_Type + 128] = _PyBufferedIOBase_Type;
      var $165 = _PyType_Ready(_PyBufferedRWPair_Type);
      
      if ($165 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      var $168 = HEAP[_PyBufferedRWPair_Type] + 1;
      HEAP[_PyBufferedRWPair_Type] = $168;
      
      var $170 = _PyModule_AddObject($m, __str49283, _PyBufferedRWPair_Type);
      
      if ($170 < 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 47:
      
      var $173 = HEAP[_PyBufferedRWPair_Type] - 1;
      HEAP[_PyBufferedRWPair_Type] = $173;
      
      
      if (HEAP[_PyBufferedRWPair_Type] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 48:
      
      
      var $178 = HEAP[HEAP[_PyBufferedRWPair_Type + 4] + 24];
      FUNCTION_TABLE[$178](_PyBufferedRWPair_Type);
      __label__ = 87;
      break;
     case 49:
      HEAP[_PyBufferedRandom_Type + 128] = _PyBufferedIOBase_Type;
      var $179 = _PyType_Ready(_PyBufferedRandom_Type);
      
      if ($179 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      var $182 = HEAP[_PyBufferedRandom_Type] + 1;
      HEAP[_PyBufferedRandom_Type] = $182;
      
      var $184 = _PyModule_AddObject($m, __str50284, _PyBufferedRandom_Type);
      
      if ($184 < 0) {
        __label__ = 51;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 51:
      
      var $187 = HEAP[_PyBufferedRandom_Type] - 1;
      HEAP[_PyBufferedRandom_Type] = $187;
      
      
      if (HEAP[_PyBufferedRandom_Type] == 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 52:
      
      
      var $192 = HEAP[HEAP[_PyBufferedRandom_Type + 4] + 24];
      FUNCTION_TABLE[$192](_PyBufferedRandom_Type);
      __label__ = 87;
      break;
     case 53:
      HEAP[_PyTextIOWrapper_Type + 128] = _PyTextIOBase_Type;
      var $193 = _PyType_Ready(_PyTextIOWrapper_Type);
      
      if ($193 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 54:
      
      var $196 = HEAP[_PyTextIOWrapper_Type] + 1;
      HEAP[_PyTextIOWrapper_Type] = $196;
      
      var $198 = _PyModule_AddObject($m, __str51285, _PyTextIOWrapper_Type);
      
      if ($198 < 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 55:
      
      var $201 = HEAP[_PyTextIOWrapper_Type] - 1;
      HEAP[_PyTextIOWrapper_Type] = $201;
      
      
      if (HEAP[_PyTextIOWrapper_Type] == 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 56:
      
      
      var $206 = HEAP[HEAP[_PyTextIOWrapper_Type + 4] + 24];
      FUNCTION_TABLE[$206](_PyTextIOWrapper_Type);
      __label__ = 87;
      break;
     case 57:
      var $207 = _PyType_Ready(_PyIncrementalNewlineDecoder_Type);
      
      if ($207 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      var $210 = HEAP[_PyIncrementalNewlineDecoder_Type] + 1;
      HEAP[_PyIncrementalNewlineDecoder_Type] = $210;
      
      var $212 = _PyModule_AddObject($m, __str52286, _PyIncrementalNewlineDecoder_Type);
      
      if ($212 < 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 59:
      
      var $215 = HEAP[_PyIncrementalNewlineDecoder_Type] - 1;
      HEAP[_PyIncrementalNewlineDecoder_Type] = $215;
      
      
      if (HEAP[_PyIncrementalNewlineDecoder_Type] == 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 60:
      
      
      var $220 = HEAP[HEAP[_PyIncrementalNewlineDecoder_Type + 4] + 24];
      FUNCTION_TABLE[$220](_PyIncrementalNewlineDecoder_Type);
      __label__ = 87;
      break;
     case 61:
      var $221 = _PyString_InternFromString(__str53287);
      HEAP[__PyIO_str_close] = $221;
      
      
      if (HEAP[__PyIO_str_close] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      var $224 = _PyString_InternFromString(__str54289);
      HEAP[__PyIO_str_closed] = $224;
      
      
      if (HEAP[__PyIO_str_closed] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 63:
      var $227 = _PyString_InternFromString(__str55291);
      HEAP[__PyIO_str_decode] = $227;
      
      
      if (HEAP[__PyIO_str_decode] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 64:
      var $230 = _PyString_InternFromString(__str56292);
      HEAP[__PyIO_str_encode] = $230;
      
      
      if (HEAP[__PyIO_str_encode] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 65:
      var $233 = _PyString_InternFromString(__str25258);
      HEAP[__PyIO_str_fileno] = $233;
      
      
      if (HEAP[__PyIO_str_fileno] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 66:
      var $236 = _PyString_InternFromString(__str57294);
      HEAP[__PyIO_str_flush] = $236;
      
      
      if (HEAP[__PyIO_str_flush] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 67:
      var $239 = _PyString_InternFromString(__str58296);
      HEAP[__PyIO_str_getstate] = $239;
      
      
      if (HEAP[__PyIO_str_getstate] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 68:
      var $242 = _PyString_InternFromString(__str24257);
      HEAP[__PyIO_str_isatty] = $242;
      
      
      if (HEAP[__PyIO_str_isatty] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 69:
      var $245 = _PyString_InternFromString(__str59298);
      HEAP[__PyIO_str_newlines] = $245;
      
      
      if (HEAP[__PyIO_str_newlines] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 70:
      var $248 = _PyString_InternFromString(__str60299);
      HEAP[__PyIO_str_nl] = $248;
      
      
      if (HEAP[__PyIO_str_nl] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 71:
      var $251 = _PyString_InternFromString(__str61300);
      HEAP[__PyIO_str_read] = $251;
      
      
      if (HEAP[__PyIO_str_read] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 72:
      var $254 = _PyString_InternFromString(__str62302);
      HEAP[__PyIO_str_read1] = $254;
      
      
      if (HEAP[__PyIO_str_read1] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 73;
        break;
      }
     case 73:
      var $257 = _PyString_InternFromString(__str63303);
      HEAP[__PyIO_str_readable] = $257;
      
      
      if (HEAP[__PyIO_str_readable] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 74:
      var $260 = _PyString_InternFromString(__str64305);
      HEAP[__PyIO_str_readinto] = $260;
      
      
      if (HEAP[__PyIO_str_readinto] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 75:
      var $263 = _PyString_InternFromString(__str65307);
      HEAP[__PyIO_str_readline] = $263;
      
      
      if (HEAP[__PyIO_str_readline] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 76:
      var $266 = _PyString_InternFromString(__str66309);
      HEAP[__PyIO_str_reset] = $266;
      
      
      if (HEAP[__PyIO_str_reset] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 77:
      var $269 = _PyString_InternFromString(__str67);
      HEAP[__PyIO_str_seek] = $269;
      
      
      if (HEAP[__PyIO_str_seek] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 78:
      var $272 = _PyString_InternFromString(__str68);
      HEAP[__PyIO_str_seekable] = $272;
      
      
      if (HEAP[__PyIO_str_seekable] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 79:
      var $275 = _PyString_InternFromString(__str69);
      HEAP[__PyIO_str_setstate] = $275;
      
      
      if (HEAP[__PyIO_str_setstate] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 80:
      var $278 = _PyString_InternFromString(__str70);
      HEAP[__PyIO_str_tell] = $278;
      
      
      if (HEAP[__PyIO_str_tell] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 81:
      var $281 = _PyString_InternFromString(__str71);
      HEAP[__PyIO_str_truncate] = $281;
      
      
      if (HEAP[__PyIO_str_truncate] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 82;
        break;
      }
     case 82:
      var $284 = _PyString_InternFromString(__str72);
      HEAP[__PyIO_str_write] = $284;
      
      
      if (HEAP[__PyIO_str_write] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 83:
      var $287 = _PyString_InternFromString(__str73);
      HEAP[__PyIO_str_writable] = $287;
      
      
      if (HEAP[__PyIO_str_writable] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 84:
      var $290 = _PyUnicodeUCS2_FromStringAndSize(0, 0);
      HEAP[__PyIO_empty_str] = $290;
      
      
      if (HEAP[__PyIO_empty_str] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 85:
      var $293 = _PyString_FromStringAndSize(0, 0);
      HEAP[__PyIO_empty_bytes] = $293;
      
      
      if (HEAP[__PyIO_empty_bytes] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 86;
        break;
      }
     case 86:
      var $296 = _PyLong_FromLong(0);
      HEAP[__PyIO_zero] = $296;
      
      
      if (HEAP[__PyIO_zero] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 95;
        break;
      }
     case 87:
      
      
      if (HEAP[__PyIO_os_module] != 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 88:
      
      $_py_tmp = HEAP[__PyIO_os_module];
      HEAP[__PyIO_os_module] = 0;
      
      
      
      var $304 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $304;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 89;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 89:
      
      
      
      
      var $315 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$315]($_py_tmp);
      __label__ = 90;
      break;
     case 90:
      
      
      if (HEAP[__PyIO_unsupported_operation] != 0) {
        __label__ = 91;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 91:
      
      $_py_tmp105 = HEAP[__PyIO_unsupported_operation];
      HEAP[__PyIO_unsupported_operation] = 0;
      
      
      
      var $323 = HEAP[$_py_tmp105] - 1;
      
      
      HEAP[$_py_tmp105] = $323;
      
      
      
      
      if (HEAP[$_py_tmp105] == 0) {
        __label__ = 92;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 92:
      
      
      
      
      var $334 = HEAP[HEAP[$_py_tmp105 + 4] + 24];
      
      FUNCTION_TABLE[$334]($_py_tmp105);
      __label__ = 93;
      break;
     case 93:
      
      
      
      var $339 = HEAP[$m] - 1;
      
      
      HEAP[$m] = $339;
      
      
      
      
      if (HEAP[$m] == 0) {
        __label__ = 94;
        break;
      } else {
        __label__ = 95;
        break;
      }
     case 94:
      
      
      
      
      var $350 = HEAP[HEAP[$m + 4] + 24];
      
      FUNCTION_TABLE[$350]($m);
      __label__ = 95;
      break;
     case 95:
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  Module["_init_io"] = _init_io;
  function _resize_buffer373($self, $size) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $size_addr;
      var $retval;
      var $iftmp_1;
      var $0;
      var $alloc;
      var $new_buf;
      $self_addr = $self;
      $size_addr = $size;
      
      
      
      $alloc = HEAP[$self_addr + 20];
      $new_buf = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str319, __str1320, 61, ___PRETTY_FUNCTION___8442);
      throw "Reached an unreachable!";
     case 2:
      
      var $9 = $size_addr + 1;
      $size_addr = $9;
      
      
      if ($size_addr < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      var $13 = Math.floor($alloc / 2);
      
      
      var $16 = $size_addr;
      if ($13 > $size_addr) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      var $17 = $16 + 1;
      $alloc = $17;
      __lastLabel__ = 4;
      __label__ = 13;
      break;
     case 5:
      
      
      if ($16 < $alloc) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 18;
      break;
     case 7:
      
      
      
      
      
      
      var $26 = $size_addr;
      if ($size_addr <= $alloc * 1.125) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      var $27 = $26 >>> 3;
      var $28 = $size_addr;
      
      
      if ($size_addr <= 8) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $iftmp_1 = 3;
      __label__ = 11;
      break;
     case 10:
      $iftmp_1 = 6;
      __label__ = 11;
      break;
     case 11:
      
      
      var $33 = $28 + $27 + $iftmp_1;
      $alloc = $33;
      __lastLabel__ = 11;
      __label__ = 13;
      break;
     case 12:
      var $34 = $26 + 1;
      $alloc = $34;
      __lastLabel__ = 12;
      __label__ = 13;
      break;
     case 13:
      var $35 = __lastLabel__ == 12 ? $34 : __lastLabel__ == 11 ? $33 : $17;
      
      if ($35 < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      
      
      
      var $42 = HEAP[$self_addr + 8];
      var $43 = _PyMem_Realloc($42, $alloc * 2);
      
      $new_buf = $43;
      
      
      if ($new_buf == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      var $47 = _PyErr_NoMemory();
      $0 = -1;
      __label__ = 18;
      break;
     case 16:
      
      
      
      HEAP[$self_addr + 20] = $alloc;
      
      
      
      HEAP[$self_addr + 8] = $new_buf;
      $0 = 0;
      __label__ = 18;
      break;
     case 17:
      var $54 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($54, __str2321);
      $0 = -1;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval17 = $retval;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _write_str($self, $obj) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $obj_addr;
      var $retval;
      var $0;
      var $str;
      var $len;
      var $decoded;
      var $translated;
      $self_addr = $self;
      $obj_addr = $obj;
      $decoded = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str319, __str1320, 114, ___PRETTY_FUNCTION___8484);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 12] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str3322, __str1320, 115, ___PRETTY_FUNCTION___8484);
      throw "Reached an unreachable!";
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      var $15 = HEAP[$self_addr + 28];
      
      var $17 = __PyIncrementalNewlineDecoder_decode($15, $obj_addr, 1);
      $decoded = $17;
      __label__ = 7;
      break;
     case 6:
      
      $decoded = $obj_addr;
      
      
      
      var $22 = HEAP[$decoded] + 1;
      
      
      HEAP[$decoded] = $22;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 36] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      var $31 = HEAP[$self_addr + 36];
      var $32 = HEAP[__PyIO_str_nl];
      
      var $34 = _PyUnicodeUCS2_Replace($decoded, $32, $31, -1);
      $translated = $34;
      
      
      
      var $38 = HEAP[$decoded] - 1;
      
      
      HEAP[$decoded] = $38;
      
      
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $49 = HEAP[HEAP[$decoded + 4] + 24];
      
      FUNCTION_TABLE[$49]($decoded);
      __label__ = 10;
      break;
     case 10:
      var $51 = $translated;
      $decoded = $51;
      __lastLabel__ = 10;
      __label__ = 12;
      break;
     case 11:
      var $_pr = $decoded;
      __lastLabel__ = 11;
      __label__ = 12;
      break;
     case 12:
      var $52 = __lastLabel__ == 11 ? $_pr : $51;
      
      if ($52 == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      $0 = -1;
      __label__ = 33;
      break;
     case 14:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$decoded + 4] + 84] & 268435456) == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      ___assert_fail(__str4323, __str1320, 134, ___PRETTY_FUNCTION___8484);
      throw "Reached an unreachable!";
     case 16:
      
      
      
      
      $str = HEAP[$decoded + 12];
      
      
      
      
      $len = HEAP[$decoded + 8];
      
      
      if ($len < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      ___assert_fail(__str5324, __str1320, 138, ___PRETTY_FUNCTION___8484);
      throw "Reached an unreachable!";
     case 18:
      
      
      
      
      
      
      if (HEAP[$self_addr + 12] > 2147483647 - $len) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      var $77 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($77, __str6325);
      __label__ = 29;
      break;
     case 20:
      
      
      
      
      
      
      
      
      
      if ($len + HEAP[$self_addr + 12] > HEAP[$self_addr + 16]) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $91 = $len + HEAP[$self_addr + 12];
      
      var $93 = _resize_buffer373($self_addr, $91);
      
      if ($93 < 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 12] > HEAP[$self_addr + 16]) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      
      
      
      var $109 = (HEAP[$self_addr + 12] - HEAP[$self_addr + 16]) * 2;
      
      
      
      
      
      
      
      var $117 = HEAP[$self_addr + 8] + 2 * HEAP[$self_addr + 16];
      _llvm_memset_p0i8_i32($117, 0, $109, 1, 0);
      __label__ = 24;
      break;
     case 24:
      
      
      
      
      
      
      
      
      
      
      var $128 = HEAP[$self_addr + 8] + 2 * HEAP[$self_addr + 12];
      
      _llvm_memcpy_p0i8_p0i8_i32($128, $str, $len * 2, 1, 0);
      
      
      
      
      var $134 = $len + HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = $134;
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 16] < HEAP[$self_addr + 12]) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      var $146 = HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 16] = $146;
      __label__ = 26;
      break;
     case 26:
      
      
      
      var $152 = HEAP[$decoded] - 1;
      
      
      HEAP[$decoded] = $152;
      
      
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      
      
      var $163 = HEAP[HEAP[$decoded + 4] + 24];
      
      FUNCTION_TABLE[$163]($decoded);
      __label__ = 28;
      break;
     case 28:
      $0 = 0;
      __label__ = 33;
      break;
     case 29:
      
      
      if ($decoded != 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 30:
      
      
      
      var $170 = HEAP[$decoded] - 1;
      
      
      HEAP[$decoded] = $170;
      
      
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      
      
      
      
      var $181 = HEAP[HEAP[$decoded + 4] + 24];
      
      FUNCTION_TABLE[$181]($decoded);
      __label__ = 32;
      break;
     case 32:
      $0 = -1;
      __label__ = 33;
      break;
     case 33:
      
      $retval = $0;
      var $retval31 = $retval;
      return $retval31;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_getvalue($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      $0 = 0;
      __label__ = 5;
      break;
     case 4:
      
      
      var $13 = HEAP[$self_addr + 16];
      
      
      var $16 = HEAP[$self_addr + 8];
      var $17 = _PyUnicodeUCS2_FromUnicode($16, $13);
      $0 = $17;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_tell($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      $0 = 0;
      __label__ = 5;
      break;
     case 4:
      
      
      var $13 = HEAP[$self_addr + 12];
      var $14 = _PyLong_FromSsize_t($13);
      $0 = $14;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $size;
      var $n;
      var $output;
      var $arg = __stackBase__;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 18;
      break;
     case 2:
      
      var $7 = __PyArg_ParseTuple_SizeT($args_addr, __str9328, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 18;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $13 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($13, __str8327);
      $0 = 0;
      __label__ = 18;
      break;
     case 6:
      var $14 = HEAP[$arg];
      var $15 = _PyNumber_Check($14);
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      var $17 = HEAP[_PyExc_OverflowError];
      var $18 = HEAP[$arg];
      var $19 = _PyNumber_AsSsize_t($18, $17);
      $size = $19;
      
      var $21 = $size == -1;
      if ($21) {
        __label__ = 8;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 8:
      var $22 = _PyErr_Occurred();
      
      if ($22 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 18;
      break;
     case 10:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      $size = -1;
      __label__ = 13;
      break;
     case 12:
      
      
      
      
      var $30 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $31 = HEAP[_PyExc_TypeError];
      var $32 = _PyErr_Format($31, __str10329, allocate([ $30, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 18;
      break;
     case 13:
      
      
      
      
      
      
      var $39 = HEAP[$self_addr + 16] - HEAP[$self_addr + 12];
      $n = $39;
      
      
      if ($size < 0) {
        __lastLabel__ = 13;
        __label__ = 15;
        break;
      } else {
        __lastLabel__ = 13;
        __label__ = 14;
        break;
      }
     case 14:
      
      var $43 = $n;
      
      if ($size > $43) {
        __lastLabel__ = 14;
        __label__ = 15;
        break;
      } else {
        __lastLabel__ = 14;
        __label__ = 17;
        break;
      }
     case 15:
      var $45 = __lastLabel__ == 14 ? $43 : $39;
      $size = $45;
      
      if ($45 < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      $size = 0;
      __label__ = 17;
      break;
     case 17:
      
      
      
      
      
      
      
      $output = HEAP[$self_addr + 8] + 2 * HEAP[$self_addr + 12];
      
      
      
      
      var $58 = $size + HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = $58;
      
      
      var $63 = _PyUnicodeUCS2_FromUnicode($output, $size);
      $0 = $63;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval19 = $retval;
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __stringio_readline($self, $limit) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $limit_addr;
      var $retval;
      var $0;
      var $start;
      var $end;
      var $old_char;
      var $len;
      var $consumed = __stackBase__;
      $self_addr = $self;
      $limit_addr = $limit;
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 12] >= HEAP[$self_addr + 16]) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $8 = _PyUnicodeUCS2_FromString(__str11330);
      $0 = $8;
      __label__ = 8;
      break;
     case 2:
      
      
      
      
      
      
      
      $start = HEAP[$self_addr + 8] + 2 * HEAP[$self_addr + 12];
      
      
      if ($limit_addr < 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 16] - HEAP[$self_addr + 12] < $limit_addr) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      
      
      
      $limit_addr = HEAP[$self_addr + 16] - HEAP[$self_addr + 12];
      __label__ = 5;
      break;
     case 5:
      
      
      
      $end = $start + 2 * $limit_addr;
      
      
      $old_char = HEAP[$end];
      
      HEAP[$end] = 0;
      
      
      var $42 = HEAP[$self_addr + 32];
      
      
      
      var $46 = HEAP[$self_addr + 26];
      
      
      
      var $50 = HEAP[$self_addr + 27];
      
      
      var $53 = __PyIO_find_line_ending($50, $46, $42, $start, $end, $consumed);
      $len = $53;
      
      
      HEAP[$end] = $old_char;
      
      
      if ($len < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      $len = $limit_addr;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      var $63 = $len + HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = $63;
      
      
      var $68 = _PyUnicodeUCS2_FromUnicode($start, $len);
      $0 = $68;
      __label__ = 8;
      break;
     case 8:
      
      $retval = $0;
      var $retval8 = $retval;
      STACKTOP = __stackBase__;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $arg = __stackBase__;
      var $limit;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$arg] = __Py_NoneStruct;
      $limit = -1;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 13;
      break;
     case 2:
      
      var $7 = __PyArg_ParseTuple_SizeT($args_addr, __str12331, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 13;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $13 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($13, __str8327);
      $0 = 0;
      __label__ = 13;
      break;
     case 6:
      var $14 = HEAP[$arg];
      var $15 = _PyNumber_Check($14);
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      var $17 = HEAP[_PyExc_OverflowError];
      var $18 = HEAP[$arg];
      var $19 = _PyNumber_AsSsize_t($18, $17);
      $limit = $19;
      
      var $21 = $limit == -1;
      if ($21) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      var $22 = _PyErr_Occurred();
      
      if ($22 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 13;
      break;
     case 10:
      
      
      if (HEAP[$arg] != __Py_NoneStruct) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $30 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $31 = HEAP[_PyExc_TypeError];
      var $32 = _PyErr_Format($31, __str10329, allocate([ $30, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 13;
      break;
     case 12:
      
      
      var $35 = __stringio_readline($self_addr, $limit);
      $0 = $35;
      __label__ = 13;
      break;
     case 13:
      
      $retval = $0;
      var $retval14 = $retval;
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_iternext($self) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $line;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 18;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      $0 = 0;
      __label__ = 18;
      break;
     case 4:
      
      
      
      
      
      if (HEAP[$self_addr + 4] == _PyStringIO_Type) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      var $17 = __stringio_readline($self_addr, -1);
      $line = $17;
      __lastLabel__ = 5;
      __label__ = 11;
      break;
     case 6:
      var $18 = HEAP[__PyIO_str_readline];
      
      
      var $21 = _PyObject_CallMethodObjArgs($self_addr, $18, allocate(4, "i8*", ALLOC_STACK));
      $line = $21;
      
      
      if ($line != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 7:
      
      
      
      
      
      
      
      var $31 = $line;
      if ((HEAP[HEAP[$line + 4] + 84] & 268435456) == 0) {
        __lastLabel__ = 7;
        __label__ = 8;
        break;
      } else {
        __lastLabel__ = 7;
        __label__ = 11;
        break;
      }
     case 8:
      
      
      
      var $35 = HEAP[HEAP[$31 + 4] + 12];
      var $36 = HEAP[_PyExc_IOError];
      var $37 = _PyErr_Format($36, __str13332, allocate([ $35, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $41 = HEAP[$line] - 1;
      
      
      HEAP[$line] = $41;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $52 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$52]($line);
      __label__ = 10;
      break;
     case 10:
      $0 = 0;
      __label__ = 18;
      break;
     case 11:
      var $54 = __lastLabel__ == 5 ? $17 : $31;
      
      if ($54 == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      $0 = 0;
      __label__ = 18;
      break;
     case 13:
      
      
      
      
      
      var $61 = $line;
      if (HEAP[$line + 8] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      var $64 = HEAP[$61] - 1;
      
      
      HEAP[$line] = $64;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $75 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$75]($line);
      __label__ = 16;
      break;
     case 16:
      $0 = 0;
      __label__ = 18;
      break;
     case 17:
      $0 = $61;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval18 = $retval;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $size;
      var $arg = __stackBase__;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 21;
      break;
     case 2:
      
      var $7 = __PyArg_ParseTuple_SizeT($args_addr, __str14333, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 21;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $13 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($13, __str8327);
      $0 = 0;
      __label__ = 21;
      break;
     case 6:
      var $14 = HEAP[$arg];
      var $15 = _PyNumber_Check($14);
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      var $17 = HEAP[_PyExc_OverflowError];
      var $18 = HEAP[$arg];
      var $19 = _PyNumber_AsSsize_t($18, $17);
      $size = $19;
      var $20 = $size;
      var $21 = $20 == -1;
      if ($21) {
        __lastLabel__ = 7;
        __label__ = 8;
        break;
      } else {
        __lastLabel__ = 7;
        __label__ = 14;
        break;
      }
     case 8:
      var $22 = _PyErr_Occurred();
      
      if ($22 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 21;
      break;
     case 10:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      var $28 = HEAP[$self_addr + 12];
      $size = $28;
      __lastLabel__ = 11;
      __label__ = 14;
      break;
     case 12:
      
      
      
      
      var $33 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $34 = HEAP[_PyExc_TypeError];
      var $35 = _PyErr_Format($34, __str10329, allocate([ $33, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 21;
      break;
     case 13:
      var $_pr = $size;
      __lastLabel__ = 13;
      __label__ = 14;
      break;
     case 14:
      var $36 = __lastLabel__ == 13 ? $_pr : __lastLabel__ == 7 ? $20 : $28;
      
      if ($36 < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      var $38 = HEAP[_PyExc_ValueError];
      
      var $40 = _PyErr_Format($38, __str15334, allocate([ $size, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 21;
      break;
     case 16:
      
      
      
      
      
      if (HEAP[$self_addr + 16] > $size) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      
      
      var $48 = _resize_buffer373($self_addr, $size);
      
      if ($48 < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      $0 = 0;
      __label__ = 21;
      break;
     case 19:
      
      
      
      HEAP[$self_addr + 16] = $size;
      __label__ = 20;
      break;
     case 20:
      
      var $54 = _PyLong_FromSsize_t($size);
      $0 = $54;
      __label__ = 21;
      break;
     case 21:
      
      $retval = $0;
      var $retval21 = $retval;
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $posobj = __stackBase__;
      var $pos;
      var $mode = __stackBase__ + 4;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$mode] = 0;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 23;
      break;
     case 2:
      
      var $7 = __PyArg_ParseTuple_SizeT($args_addr, __str16335, allocate([ $posobj, 0, 0, 0, $mode, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      $0 = 0;
      __label__ = 23;
      break;
     case 4:
      var $9 = HEAP[_PyExc_OverflowError];
      var $10 = HEAP[$posobj];
      var $11 = _PyNumber_AsSsize_t($10, $9);
      $pos = $11;
      
      var $13 = $pos == -1;
      if ($13) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      var $14 = _PyErr_Occurred();
      
      if ($14 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 23;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $20 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($20, __str8327);
      $0 = 0;
      __label__ = 23;
      break;
     case 9:
      
      
      
      
      
      
      
      
      if (HEAP[$mode] == 0 | HEAP[$mode] == 1 | HEAP[$mode] == 2) {
        __label__ = 11;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      var $27 = HEAP[$mode];
      var $28 = HEAP[_PyExc_ValueError];
      var $29 = _PyErr_Format($28, __str17336, allocate([ $27, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 23;
      break;
     case 11:
      
      
      
      var $32 = HEAP[$mode] != 0;
      if ($pos >= 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      if ($32) {
        __label__ = 16;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      var $33 = HEAP[_PyExc_ValueError];
      
      var $35 = _PyErr_Format($33, __str18337, allocate([ $pos, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 23;
      break;
     case 14:
      if ($32) {
        __label__ = 16;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      var $_pr5 = HEAP[$mode];
      __lastLabel__ = 15;
      __label__ = 20;
      break;
     case 16:
      
      
      if ($pos != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      var $38 = HEAP[_PyExc_IOError];
      _PyErr_SetString($38, __str19338);
      $0 = 0;
      __label__ = 23;
      break;
     case 18:
      var $_pr4 = HEAP[$mode];
      
      if ($_pr4 == 1) {
        __lastLabel__ = 18;
        __label__ = 19;
        break;
      } else {
        __lastLabel__ = 18;
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      $pos = HEAP[$self_addr + 12];
      __label__ = 22;
      break;
     case 20:
      var $43 = __lastLabel__ == 15 ? $_pr5 : $_pr4;
      
      if ($43 == 2) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      $pos = HEAP[$self_addr + 16];
      __label__ = 22;
      break;
     case 22:
      
      
      
      HEAP[$self_addr + 12] = $pos;
      
      
      var $53 = HEAP[$self_addr + 12];
      var $54 = _PyLong_FromSsize_t($53);
      $0 = $54;
      __label__ = 23;
      break;
     case 23:
      
      $retval = $0;
      var $retval24 = $retval;
      STACKTOP = __stackBase__;
      return $retval24;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_write($self, $obj) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $obj_addr;
      var $retval;
      var $0;
      var $size;
      $self_addr = $self;
      $obj_addr = $obj;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 10;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$obj_addr + 4] + 84] & 268435456) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $17 = HEAP[HEAP[$obj_addr + 4] + 12];
      var $18 = HEAP[_PyExc_TypeError];
      var $19 = _PyErr_Format($18, __str20339, allocate([ $17, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 10;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $24 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($24, __str8327);
      $0 = 0;
      __label__ = 10;
      break;
     case 6:
      
      
      
      
      $size = HEAP[$obj_addr + 8];
      
      
      if ($size > 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      var $33 = _write_str($self_addr, $obj_addr);
      
      if ($33 < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = 0;
      __label__ = 10;
      break;
     case 9:
      
      var $36 = _PyLong_FromSsize_t($size);
      $0 = $36;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_close($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      var $_py_tmp6;
      var $_py_tmp10;
      $self_addr = $self;
      
      
      HEAP[$self_addr + 25] = 1;
      
      var $4 = _resize_buffer373($self_addr, 0);
      
      if ($4 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 12;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      $_py_tmp = HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = 0;
      
      
      
      var $18 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $18;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $29 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$29]($_py_tmp);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[$self_addr + 36] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      
      $_py_tmp6 = HEAP[$self_addr + 36];
      
      
      HEAP[$self_addr + 36] = 0;
      
      
      
      var $43 = HEAP[$_py_tmp6] - 1;
      
      
      HEAP[$_py_tmp6] = $43;
      
      
      
      
      if (HEAP[$_py_tmp6] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $54 = HEAP[HEAP[$_py_tmp6 + 4] + 24];
      
      FUNCTION_TABLE[$54]($_py_tmp6);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 9:
      
      
      
      $_py_tmp10 = HEAP[$self_addr + 28];
      
      
      HEAP[$self_addr + 28] = 0;
      
      
      
      var $68 = HEAP[$_py_tmp10] - 1;
      
      
      HEAP[$_py_tmp10] = $68;
      
      
      
      
      if (HEAP[$_py_tmp10] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $79 = HEAP[HEAP[$_py_tmp10 + 4] + 24];
      
      FUNCTION_TABLE[$79]($_py_tmp10);
      __label__ = 11;
      break;
     case 11:
      
      var $82 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $82;
      $0 = __Py_NoneStruct;
      __label__ = 12;
      break;
     case 12:
      
      $retval = $0;
      var $retval14 = $retval;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_traverse($self, $visit, $arg) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $visit_addr;
      var $arg_addr;
      var $retval;
      var $0;
      var $vret;
      $self_addr = $self;
      $visit_addr = $visit;
      $arg_addr = $arg;
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 40];
      var $8 = $visit_addr;
      
      var $10 = FUNCTION_TABLE[$8]($7, $arg_addr);
      $vret = $10;
      
      
      if ($vret != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      $0 = $vret;
      __label__ = 4;
      break;
     case 3:
      $0 = 0;
      __label__ = 4;
      break;
     case 4:
      
      $retval = $0;
      var $retval4 = $retval;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      $_py_tmp = HEAP[$self_addr + 40];
      
      
      HEAP[$self_addr + 40] = 0;
      
      
      
      var $13 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $13;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $24 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$24]($_py_tmp);
      __label__ = 3;
      break;
     case 3:
      $0 = 0;
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $g;
      var $_py_tmp;
      var $_py_tmp8;
      var $_py_tmp12;
      var $_py_tmp16;
      $self_addr = $self;
      
      
      var $2 = $self_addr + -12;
      $g = $2;
      
      
      
      
      var $7 = HEAP[$g + 8] == -2;
      if ($7) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str21340, __str1320, 516, ___PRETTY_FUNCTION___9021);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      HEAP[$g + 8] = -2;
      
      
      
      
      
      
      
      var $18 = HEAP[$g];
      
      var $20 = HEAP[$g + 4];
      HEAP[$20] = $18;
      
      
      
      
      
      
      
      var $28 = HEAP[$g + 4];
      
      var $30 = HEAP[$g] + 4;
      HEAP[$30] = $28;
      
      
      
      HEAP[$g] = 0;
      
      
      HEAP[$self_addr + 24] = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      var $43 = HEAP[$self_addr + 8];
      _PyMem_Free($43);
      
      
      HEAP[$self_addr + 8] = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      
      $_py_tmp = HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = 0;
      
      
      
      var $58 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $58;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $69 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$69]($_py_tmp);
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 36] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      $_py_tmp8 = HEAP[$self_addr + 36];
      
      
      HEAP[$self_addr + 36] = 0;
      
      
      
      var $83 = HEAP[$_py_tmp8] - 1;
      
      
      HEAP[$_py_tmp8] = $83;
      
      
      
      
      if (HEAP[$_py_tmp8] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $94 = HEAP[HEAP[$_py_tmp8 + 4] + 24];
      
      FUNCTION_TABLE[$94]($_py_tmp8);
      __label__ = 10;
      break;
     case 10:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      
      $_py_tmp12 = HEAP[$self_addr + 28];
      
      
      HEAP[$self_addr + 28] = 0;
      
      
      
      var $108 = HEAP[$_py_tmp12] - 1;
      
      
      HEAP[$_py_tmp12] = $108;
      
      
      
      
      if (HEAP[$_py_tmp12] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $119 = HEAP[HEAP[$_py_tmp12 + 4] + 24];
      
      FUNCTION_TABLE[$119]($_py_tmp12);
      __label__ = 13;
      break;
     case 13:
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      
      
      $_py_tmp16 = HEAP[$self_addr + 40];
      
      
      HEAP[$self_addr + 40] = 0;
      
      
      
      var $133 = HEAP[$_py_tmp16] - 1;
      
      
      HEAP[$_py_tmp16] = $133;
      
      
      
      
      if (HEAP[$_py_tmp16] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $144 = HEAP[HEAP[$_py_tmp16 + 4] + 24];
      
      FUNCTION_TABLE[$144]($_py_tmp16);
      __label__ = 16;
      break;
     case 16:
      
      
      
      
      if (HEAP[$self_addr + 44] != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      _PyObject_ClearWeakRefs($self_addr);
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      
      var $157 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$157]($self_addr);
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_new($type, $args, $kwds) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $type_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $self;
      $type_addr = $type;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      
      if ($type_addr == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$type_addr + 152] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str22341, __str1320, 536, ___PRETTY_FUNCTION___9091);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $9 = HEAP[$type_addr + 152];
      
      var $11 = FUNCTION_TABLE[$9]($type_addr, 0);
      
      $self = $11;
      
      
      if ($self == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = 0;
      __label__ = 10;
      break;
     case 5:
      var $15 = _PyMem_Malloc(0);
      
      
      
      HEAP[$self + 8] = $15;
      
      
      
      
      
      var $24 = $self;
      if (HEAP[$self + 8] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      var $27 = HEAP[$24] - 1;
      
      HEAP[$24] = $27;
      
      
      
      if (HEAP[$24] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $37 = HEAP[HEAP[$self + 4] + 24];
      
      
      FUNCTION_TABLE[$37]($self);
      __label__ = 8;
      break;
     case 8:
      var $40 = _PyErr_NoMemory();
      $0 = $40;
      __label__ = 10;
      break;
     case 9:
      $0 = $24;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $iftmp_90;
      var $0;
      var $kwlist = __stackBase__;
      var $value = __stackBase__ + 12;
      var $newline = __stackBase__ + 16;
      var $_py_tmp;
      var $_py_tmp21;
      var $_py_tmp25;
      var $len;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str23342;
      
      HEAP[$kwlist + 4] = __str24343;
      
      HEAP[$kwlist + 8] = 0;
      HEAP[$value] = 0;
      HEAP[$newline] = __str25344;
      
      
      var $kwlist1 = $kwlist;
      var $6 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str26345, $kwlist1, allocate([ $value, 0, 0, 0, $newline, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($6 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 45;
      break;
     case 2:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 4:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 10) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 8;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 11;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 10) {
        __label__ = 11;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      if (HEAP[HEAP[$newline] + 2] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $42 = HEAP[$newline];
      var $43 = HEAP[_PyExc_ValueError];
      var $44 = _PyErr_Format($43, __str27346, allocate([ $42, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = -1;
      __label__ = 45;
      break;
     case 12:
      
      
      
      
      
      if (HEAP[$value] != 0 & HEAP[$value] != __Py_NoneStruct) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$value] + 4] + 84] & 268435456) == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $60 = HEAP[HEAP[HEAP[$value] + 4] + 12];
      var $61 = HEAP[_PyExc_TypeError];
      var $62 = _PyErr_Format($61, __str28347, allocate([ $60, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = -1;
      __label__ = 45;
      break;
     case 15:
      
      
      HEAP[$self_addr + 24] = 0;
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      
      $_py_tmp = HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = 0;
      
      
      
      var $77 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $77;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $88 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$88]($_py_tmp);
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      if (HEAP[$self_addr + 36] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      
      
      $_py_tmp21 = HEAP[$self_addr + 36];
      
      
      HEAP[$self_addr + 36] = 0;
      
      
      
      var $102 = HEAP[$_py_tmp21] - 1;
      
      
      HEAP[$_py_tmp21] = $102;
      
      
      
      
      if (HEAP[$_py_tmp21] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $113 = HEAP[HEAP[$_py_tmp21 + 4] + 24];
      
      FUNCTION_TABLE[$113]($_py_tmp21);
      __label__ = 21;
      break;
     case 21:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      
      
      $_py_tmp25 = HEAP[$self_addr + 28];
      
      
      HEAP[$self_addr + 28] = 0;
      
      
      
      var $127 = HEAP[$_py_tmp25] - 1;
      
      
      HEAP[$_py_tmp25] = $127;
      
      
      
      
      if (HEAP[$_py_tmp25] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $138 = HEAP[HEAP[$_py_tmp25 + 4] + 24];
      
      FUNCTION_TABLE[$138]($_py_tmp25);
      __label__ = 24;
      break;
     case 24:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 25:
      var $142 = HEAP[$newline];
      var $143 = _PyString_FromString($142);
      
      
      HEAP[$self_addr + 32] = $143;
      
      
      
      
      if (HEAP[$self_addr + 32] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      $0 = -1;
      __label__ = 45;
      break;
     case 27:
      
      
      if (HEAP[$newline] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 28:
      
      
      
      
      if (HEAP[HEAP[$newline]] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      $iftmp_90 = 1;
      __label__ = 31;
      break;
     case 30:
      $iftmp_90 = 0;
      __label__ = 31;
      break;
     case 31:
      
      
      
      
      HEAP[$self_addr + 26] = $iftmp_90 & 255;
      
      
      var $161 = HEAP[$newline] == 0;
      
      
      HEAP[$self_addr + 27] = $161;
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 32:
      
      
      
      
      if (HEAP[HEAP[$newline]] == 13) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      var $170 = HEAP[$newline];
      var $171 = _PyUnicodeUCS2_FromString($170);
      
      
      HEAP[$self_addr + 36] = $171;
      __label__ = 34;
      break;
     case 34:
      
      
      
      
      if (HEAP[$self_addr + 26] != 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 35:
      
      
      
      var $181 = HEAP[$self_addr + 27];
      var $182 = __PyObject_CallFunction_SizeT(_PyIncrementalNewlineDecoder_Type, __str29348, allocate([ __Py_NoneStruct, 0, 0, 0, $181, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      
      
      HEAP[$self_addr + 28] = $182;
      
      
      
      
      if (HEAP[$self_addr + 28] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 36:
      $0 = -1;
      __label__ = 45;
      break;
     case 37:
      
      
      HEAP[$self_addr + 16] = 0;
      
      
      
      
      
      if (HEAP[$value] == 0 | HEAP[$value] == __Py_NoneStruct) {
        __label__ = 42;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 38:
      var $195 = HEAP[$value];
      var $196 = _PyUnicodeUCS2_GetSize($195);
      $len = $196;
      
      
      var $199 = _resize_buffer373($self_addr, $len);
      
      if ($199 < 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 39:
      $0 = -1;
      __label__ = 45;
      break;
     case 40:
      
      
      HEAP[$self_addr + 12] = 0;
      var $203 = HEAP[$value];
      
      var $205 = _write_str($self_addr, $203);
      
      if ($205 < 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 41:
      $0 = -1;
      __label__ = 45;
      break;
     case 42:
      
      var $208 = _resize_buffer373($self_addr, 0);
      
      if ($208 < 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      $0 = -1;
      __label__ = 45;
      break;
     case 44:
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      HEAP[$self_addr + 25] = 0;
      
      
      HEAP[$self_addr + 24] = 1;
      $0 = 0;
      __label__ = 45;
      break;
     case 45:
      
      $retval = $0;
      var $retval51 = $retval;
      STACKTOP = __stackBase__;
      return $retval51;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_seekable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $7 = HEAP[__Py_TrueStruct] + 1;
      HEAP[__Py_TrueStruct] = $7;
      $0 = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_readable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $7 = HEAP[__Py_TrueStruct] + 1;
      HEAP[__Py_TrueStruct] = $7;
      $0 = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_writable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $7 = HEAP[__Py_TrueStruct] + 1;
      HEAP[__Py_TrueStruct] = $7;
      $0 = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_getstate($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $iftmp_109;
      var $0;
      var $initvalue;
      var $dict;
      var $state;
      $self_addr = $self;
      
      var $2 = _stringio_getvalue($self_addr);
      $initvalue = $2;
      
      
      if ($initvalue == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 12;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 40] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      var $10 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $10;
      $dict = __Py_NoneStruct;
      __label__ = 6;
      break;
     case 4:
      
      
      var $13 = HEAP[$self_addr + 40];
      var $14 = _PyDict_Copy($13);
      $dict = $14;
      
      
      if ($dict == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 12;
      break;
     case 6:
      
      
      var $19 = HEAP[$self_addr + 12];
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      $iftmp_109 = HEAP[$self_addr + 32];
      __label__ = 9;
      break;
     case 8:
      $iftmp_109 = __Py_NoneStruct;
      __label__ = 9;
      break;
     case 9:
      
      
      
      var $30 = __Py_BuildValue_SizeT(__str30349, allocate([ $initvalue, 0, 0, 0, $iftmp_109, 0, 0, 0, $19, 0, 0, 0, $dict, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      $state = $30;
      
      
      
      var $34 = HEAP[$initvalue] - 1;
      
      
      HEAP[$initvalue] = $34;
      
      
      
      
      if (HEAP[$initvalue] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $45 = HEAP[HEAP[$initvalue + 4] + 24];
      
      FUNCTION_TABLE[$45]($initvalue);
      __label__ = 11;
      break;
     case 11:
      
      $0 = $state;
      __label__ = 12;
      break;
     case 12:
      
      $retval = $0;
      var $retval12 = $retval;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_setstate($self, $state) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $state_addr;
      var $retval;
      var $0;
      var $initarg;
      var $position_obj;
      var $dict;
      var $pos;
      var $buf;
      var $bufsize;
      $self_addr = $self;
      $state_addr = $state;
      
      
      if ($state_addr == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str31350, __str1320, 702, ___PRETTY_FUNCTION___9352);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $7 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($7, __str8327);
      $0 = 0;
      __label__ = 35;
      break;
     case 4:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$state_addr + 4] + 84] & 67108864) == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      
      if (HEAP[$state_addr + 8] <= 3) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $24 = HEAP[HEAP[$state_addr + 4] + 12];
      
      
      
      
      
      var $30 = HEAP[HEAP[$self_addr + 4] + 12];
      var $31 = HEAP[_PyExc_TypeError];
      var $32 = _PyErr_Format($31, __str32351, allocate([ $30, 0, 0, 0, $24, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 35;
      break;
     case 7:
      
      var $34 = _PyTuple_GetSlice($state_addr, 0, 2);
      $initarg = $34;
      
      
      if ($initarg == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = 0;
      __label__ = 35;
      break;
     case 9:
      
      
      var $39 = _stringio_init($self_addr, $initarg, 0);
      var $40 = $39 < 0;
      
      
      
      var $44 = HEAP[$initarg] - 1;
      
      
      HEAP[$initarg] = $44;
      
      
      
      var $50 = HEAP[$initarg] == 0;
      if ($40) {
        __label__ = 10;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 10:
      if ($50) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $55 = HEAP[HEAP[$initarg + 4] + 24];
      
      FUNCTION_TABLE[$55]($initarg);
      __label__ = 12;
      break;
     case 12:
      $0 = 0;
      __label__ = 35;
      break;
     case 13:
      if ($50) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $61 = HEAP[HEAP[$initarg + 4] + 24];
      
      FUNCTION_TABLE[$61]($initarg);
      __label__ = 15;
      break;
     case 15:
      
      
      
      
      
      
      
      
      $buf = HEAP[HEAP[$state_addr + 12] + 12];
      
      
      
      
      
      
      
      
      $bufsize = HEAP[HEAP[$state_addr + 12] + 8];
      
      
      var $81 = _resize_buffer373($self_addr, $bufsize);
      
      if ($81 < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      $0 = 0;
      __label__ = 35;
      break;
     case 17:
      
      
      
      
      
      
      var $89 = HEAP[$self_addr + 8];
      
      _llvm_memcpy_p0i8_p0i8_i32($89, $buf, $bufsize * 2, 1, 0);
      
      
      
      HEAP[$self_addr + 16] = $bufsize;
      
      
      
      
      
      $position_obj = HEAP[$state_addr + 12 + 8];
      
      
      
      
      
      
      if (HEAP[HEAP[$position_obj + 4] + 48] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$position_obj + 4] + 84] & 131072) == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$position_obj + 4] + 48] + 152] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $124 = HEAP[HEAP[$position_obj + 4] + 12];
      var $125 = HEAP[_PyExc_TypeError];
      var $126 = _PyErr_Format($125, __str33352, allocate([ $124, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 35;
      break;
     case 21:
      var $127 = HEAP[_PyExc_OverflowError];
      
      var $129 = _PyNumber_AsSsize_t($position_obj, $127);
      $pos = $129;
      var $130 = $pos;
      var $131 = $130 == -1;
      if ($131) {
        __lastLabel__ = 21;
        __label__ = 22;
        break;
      } else {
        __lastLabel__ = 21;
        __label__ = 25;
        break;
      }
     case 22:
      var $132 = _PyErr_Occurred();
      
      if ($132 != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      $0 = 0;
      __label__ = 35;
      break;
     case 24:
      var $_pr = $pos;
      __lastLabel__ = 24;
      __label__ = 25;
      break;
     case 25:
      var $134 = __lastLabel__ == 24 ? $_pr : $130;
      
      if ($134 < 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      var $136 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($136, __str34353);
      $0 = 0;
      __label__ = 35;
      break;
     case 27:
      
      
      
      HEAP[$self_addr + 12] = $pos;
      
      
      
      
      
      $dict = HEAP[$state_addr + 12 + 12];
      
      
      if ($dict != __Py_NoneStruct) {
        __label__ = 28;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 28:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$dict + 4] + 84] & 536870912) == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $158 = HEAP[HEAP[$dict + 4] + 12];
      var $159 = HEAP[_PyExc_TypeError];
      var $160 = _PyErr_Format($159, __str35354, allocate([ $158, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 35;
      break;
     case 30:
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      var $167 = HEAP[$self_addr + 40];
      
      var $169 = _PyDict_Update($167, $dict);
      
      if ($169 < 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 32:
      $0 = 0;
      __label__ = 35;
      break;
     case 33:
      
      
      
      var $174 = HEAP[$dict] + 1;
      
      
      HEAP[$dict] = $174;
      
      
      
      HEAP[$self_addr + 40] = $dict;
      __label__ = 34;
      break;
     case 34:
      
      var $181 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $181;
      $0 = __Py_NoneStruct;
      __label__ = 35;
      break;
     case 35:
      
      $retval = $0;
      var $retval35 = $retval;
      return $retval35;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_closed($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      
      var $9 = HEAP[$self_addr + 25];
      var $10 = _PyBool_FromLong($9);
      $0 = $10;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_line_buffering($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      $0 = 0;
      __label__ = 5;
      break;
     case 4:
      
      var $12 = HEAP[__Py_ZeroStruct] + 1;
      HEAP[__Py_ZeroStruct] = $12;
      $0 = __Py_ZeroStruct;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_newlines($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      if (HEAP[$self_addr + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str12);
      $0 = 0;
      __label__ = 7;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      $0 = 0;
      __label__ = 7;
      break;
     case 4:
      
      
      
      
      if (HEAP[$self_addr + 28] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      var $16 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $16;
      $0 = __Py_NoneStruct;
      __label__ = 7;
      break;
     case 6:
      var $17 = HEAP[__PyIO_str_newlines];
      
      
      var $20 = HEAP[$self_addr + 28];
      var $21 = _PyObject_GetAttr($20, $17);
      $0 = $21;
      __label__ = 7;
      break;
     case 7:
      
      $retval = $0;
      var $retval7 = $retval;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __unsupported($message) {
    
    var $message_addr;
    var $retval;
    var $0;
    $message_addr = $message;
    var $1 = HEAP[__PyIO_unsupported_operation];
    
    _PyErr_SetString($1, $message_addr);
    $0 = 0;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiobase_detach($self) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    var $1 = __unsupported(__str4);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiobase_read($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = __unsupported(__str1375);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiobase_readline($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = __unsupported(__str2376);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiobase_write($self, $args) {
    
    var $self_addr;
    var $args_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $args_addr = $args;
    var $1 = __unsupported(__str3377);
    $0 = $1;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiobase_encoding_get($self, $context) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    
    var $2 = HEAP[__Py_NoneStruct] + 1;
    HEAP[__Py_NoneStruct] = $2;
    $0 = __Py_NoneStruct;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiobase_newlines_get($self, $context) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    
    var $2 = HEAP[__Py_NoneStruct] + 1;
    HEAP[__Py_NoneStruct] = $2;
    $0 = __Py_NoneStruct;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiobase_errors_get($self, $context) {
    
    var $self_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    
    var $2 = HEAP[__Py_NoneStruct] + 1;
    HEAP[__Py_NoneStruct] = $2;
    $0 = __Py_NoneStruct;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _incrementalnewlinedecoder_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $decoder = __stackBase__;
      var $translate = __stackBase__ + 4;
      var $errors = __stackBase__ + 8;
      var $kwlist = __stackBase__ + 12;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      HEAP[$errors] = 0;
      
      HEAP[$kwlist] = __str8383;
      
      HEAP[$kwlist + 4] = __str9384;
      
      HEAP[$kwlist + 8] = __str6380;
      
      HEAP[$kwlist + 12] = 0;
      
      
      var $kwlist1 = $kwlist;
      var $7 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str10385, $kwlist1, allocate([ $decoder, 0, 0, 0, $translate, 0, 0, 0, $errors, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 7;
      break;
     case 2:
      var $9 = HEAP[$decoder];
      
      
      HEAP[$self_addr + 8] = $9;
      
      
      
      var $15 = HEAP[HEAP[$decoder]] + 1;
      var $16 = HEAP[$decoder];
      HEAP[$16] = $15;
      
      
      if (HEAP[$errors] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      var $19 = _PyUnicodeUCS2_FromString(__str11386);
      
      
      HEAP[$self_addr + 12] = $19;
      
      
      
      
      if (HEAP[$self_addr + 12] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      $0 = -1;
      __label__ = 7;
      break;
     case 5:
      
      
      
      var $29 = HEAP[HEAP[$errors]] + 1;
      var $30 = HEAP[$errors];
      HEAP[$30] = $29;
      var $31 = HEAP[$errors];
      
      
      HEAP[$self_addr + 12] = $31;
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      
      
      
      
      
      var $43 = HEAP[$self_addr + 16] & -3;
      var $44 = (HEAP[$translate] & 255 & 1) << 1 & 2 | $43;
      HEAP[$self_addr + 16] = $44;
      
      
      
      var $48 = HEAP[$self_addr + 16] & -29;
      HEAP[$self_addr + 16] = $48;
      
      
      
      var $52 = HEAP[$self_addr + 16] & -2;
      HEAP[$self_addr + 16] = $52;
      $0 = 0;
      __label__ = 7;
      break;
     case 7:
      
      $retval = $0;
      var $retval9 = $retval;
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $_py_tmp;
      var $_py_tmp4;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      $_py_tmp = HEAP[$self_addr + 8];
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      var $12 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $12;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $23 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$23]($_py_tmp);
      __label__ = 3;
      break;
     case 3:
      
      
      
      
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      
      $_py_tmp4 = HEAP[$self_addr + 12];
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      
      var $37 = HEAP[$_py_tmp4] - 1;
      
      
      HEAP[$_py_tmp4] = $37;
      
      
      
      
      if (HEAP[$_py_tmp4] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $48 = HEAP[HEAP[$_py_tmp4 + 4] + 24];
      
      FUNCTION_TABLE[$48]($_py_tmp4);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      
      var $55 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$55]($self_addr);
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIncrementalNewlineDecoder_decode($_self, $input, $final) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $_self_addr;
      var $input_addr;
      var $final_addr;
      var $retval;
      var $iftmp_10;
      var $0;
      var $output = __stackBase__;
      var $output_len;
      var $self;
      var $out;
      var $modified;
      var $modified25;
      var $in_str;
      var $len;
      var $seennl;
      var $only_lf;
      var $s;
      var $end;
      var $c;
      var $s49;
      var $end50;
      var $c54;
      var $translated;
      var $out_str;
      var $in;
      var $out66;
      var $end67;
      var $c76;
      $_self_addr = $_self;
      $input_addr = $input;
      $final_addr = $final;
      
      
      $self = $_self_addr;
      
      
      
      
      if (HEAP[$self + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $7 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($7, __str12387);
      $0 = 0;
      __label__ = 84;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self + 8] != __Py_NoneStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if ($final_addr != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $iftmp_10 = __Py_TrueStruct;
      __label__ = 6;
      break;
     case 5:
      $iftmp_10 = __Py_ZeroStruct;
      __label__ = 6;
      break;
     case 6:
      var $14 = HEAP[__PyIO_str_decode];
      
      
      var $17 = HEAP[$self + 8];
      
      
      var $20 = _PyObject_CallMethodObjArgs($17, $14, allocate([ $input_addr, 0, 0, 0, $iftmp_10, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$output] = $20;
      __lastLabel__ = 6;
      __label__ = 8;
      break;
     case 7:
      
      HEAP[$output] = $input_addr;
      
      
      
      var $25 = HEAP[HEAP[$output]] + 1;
      var $26 = HEAP[$output];
      HEAP[$26] = $25;
      var $_pr = HEAP[$output];
      __lastLabel__ = 7;
      __label__ = 8;
      break;
     case 8:
      var $27 = __lastLabel__ == 7 ? $_pr : $20;
      
      if ($27 == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 84;
      break;
     case 10:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$output] + 4] + 84] & 268435456) == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $36 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($36, __str13388);
      __label__ = 81;
      break;
     case 12:
      
      
      
      
      $output_len = HEAP[HEAP[$output] + 8];
      
      
      
      
      
      
      
      if ((HEAP[$self + 16] << 7 >> 7 & 1) != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 13:
      
      
      if ($final_addr != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      if ($output_len > 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 15:
      
      
      var $54 = _PyUnicodeUCS2_FromUnicode(0, $output_len + 1);
      $modified = $54;
      
      if ($54 == 0) {
        __label__ = 81;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      
      $out = HEAP[$modified + 12];
      
      
      HEAP[$out] = 13;
      
      
      
      
      
      
      
      
      
      var $71 = HEAP[HEAP[$output] + 12];
      _llvm_memcpy_p0i8_p0i8_i32($out + 2, $71, $output_len * 2, 1, 0);
      var $72 = HEAP[$output];
      
      
      var $75 = HEAP[$72] - 1;
      var $76 = $72;
      HEAP[$76] = $75;
      
      
      
      if (HEAP[$72] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $84 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $85 = HEAP[$output];
      FUNCTION_TABLE[$84]($85);
      __label__ = 18;
      break;
     case 18:
      
      HEAP[$output] = $modified;
      
      
      
      var $90 = HEAP[$self + 16] & -2;
      HEAP[$self + 16] = $90;
      
      var $92 = $output_len + 1;
      $output_len = $92;
      __label__ = 19;
      break;
     case 19:
      
      
      if ($final_addr == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 20:
      
      
      if ($output_len > 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 21:
      
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$output] + 12] + 2 * ($output_len - 1)] == 13) {
        __label__ = 22;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 22:
      
      
      
      
      
      var $111 = $output_len - 1;
      if (HEAP[HEAP[$output]] == 1) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      var $112 = _PyUnicodeUCS2_Resize($output, $111);
      
      if ($112 < 0) {
        __label__ = 81;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 24:
      
      
      
      var $117 = HEAP[HEAP[$output] + 12];
      var $118 = _PyUnicodeUCS2_FromUnicode($117, $111);
      $modified25 = $118;
      
      
      if ($modified25 == 0) {
        __label__ = 81;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      var $121 = HEAP[$output];
      
      
      var $124 = HEAP[$121] - 1;
      var $125 = $121;
      HEAP[$125] = $124;
      
      
      
      if (HEAP[$121] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $133 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $134 = HEAP[$output];
      FUNCTION_TABLE[$133]($134);
      __label__ = 27;
      break;
     case 27:
      
      HEAP[$output] = $modified25;
      __label__ = 28;
      break;
     case 28:
      
      
      
      var $139 = HEAP[$self + 16] & -2;
      var $140 = $139 | 1;
      HEAP[$self + 16] = $140;
      __label__ = 29;
      break;
     case 29:
      
      
      
      
      
      
      
      $seennl = HEAP[$self + 16] << 3 >>> 5 & 7;
      $only_lf = 0;
      
      
      
      
      $in_str = HEAP[HEAP[$output] + 12];
      
      
      
      
      $len = HEAP[HEAP[$output] + 8];
      
      if (HEAP[HEAP[$output] + 8] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      
      $0 = HEAP[$output];
      __label__ = 84;
      break;
     case 31:
      
      
      
      
      
      if ($seennl == 2 | $seennl == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $166 = _memchr($in_str, 13, $len * 2);
      
      var $168 = $166 == 0;
      $only_lf = $168;
      __lastLabel__ = 32;
      __label__ = 34;
      break;
     case 33:
      var $_pr2 = $only_lf;
      __lastLabel__ = 33;
      __label__ = 34;
      break;
     case 34:
      var $169 = __lastLabel__ == 33 ? $_pr2 : $168;
      
      if ($169 != 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 35:
      
      
      if ($seennl == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 36:
      
      
      
      
      var $177 = _memchr($in_str, 10, $len * 2);
      
      if ($177 != 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 37:
      
      $s = $in_str;
      
      
      
      $end = $in_str + 2 * $len;
      __label__ = 39;
      break;
     case 38:
      
      $s = $187 + 2;
      __label__ = 39;
      break;
     case 39:
      
      
      
      var $187 = $s;
      if (HEAP[$s] > 10) {
        __label__ = 38;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 40:
      
      $c = HEAP[$187];
      
      var $190 = $s + 2;
      $s = $190;
      
      
      if ($c == 10) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      var $194 = $seennl | 2;
      $seennl = $194;
      __label__ = 80;
      break;
     case 42:
      
      
      
      if ($s > $end) {
        __label__ = 80;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 43:
      
      
      
      
      
      
      
      if ((HEAP[$self + 16] << 6 >> 7 & 1) == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 44:
      
      
      if ($seennl == 7) {
        __label__ = 80;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      $s49 = $in_str;
      
      
      
      $end50 = $in_str + 2 * $len;
      __label__ = 47;
      break;
     case 46:
      
      $s49 = $215 + 2;
      __label__ = 47;
      break;
     case 47:
      
      
      
      var $215 = $s49;
      if (HEAP[$s49] > 13) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 48:
      
      $c54 = HEAP[$215];
      
      var $218 = $s49 + 2;
      $s49 = $218;
      
      
      if ($c54 == 10) {
        __label__ = 49;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 49:
      
      var $222 = $seennl | 2;
      $seennl = $222;
      __label__ = 54;
      break;
     case 50:
      
      
      if ($c54 == 13) {
        __label__ = 51;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 51:
      
      
      
      var $228 = $seennl;
      if (HEAP[$s49] == 10) {
        __label__ = 52;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 52:
      var $229 = $228 | 4;
      $seennl = $229;
      
      var $231 = $s49 + 2;
      $s49 = $231;
      __label__ = 54;
      break;
     case 53:
      var $232 = $228 | 1;
      $seennl = $232;
      __label__ = 54;
      break;
     case 54:
      
      
      
      if ($s49 > $end50) {
        __label__ = 80;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 55:
      
      
      if ($seennl == 7) {
        __label__ = 80;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 56:
      $translated = 0;
      
      
      
      
      if (HEAP[HEAP[$output]] != 1) {
        __label__ = 57;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 57:
      
      var $243 = _PyUnicodeUCS2_FromUnicode(0, $len);
      $translated = $243;
      
      
      if ($translated == 0) {
        __label__ = 81;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      
      
      
      if (HEAP[$translated] != 1) {
        __label__ = 59;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 59:
      ___assert_fail(__str14389, __str15390, 407, ___PRETTY_FUNCTION___8596);
      throw "Reached an unreachable!";
     case 60:
      
      
      
      
      
      
      
      
      
      
      var $260 = HEAP[$translated + 12];
      var $261 = HEAP[HEAP[$output] + 12];
      _llvm_memcpy_p0i8_p0i8_i32($260, $261, $len * 2, 1, 0);
      __label__ = 62;
      break;
     case 61:
      
      $translated = HEAP[$output];
      __label__ = 62;
      break;
     case 62:
      
      
      
      
      $out_str = HEAP[$translated + 12];
      
      $in = $in_str;
      
      $out66 = $out_str;
      
      
      
      $end67 = $in_str + 2 * $len;
      __label__ = 64;
      break;
     case 63:
      
      
      HEAP[$out66] = $c76;
      
      var $275 = $out66 + 2;
      $out66 = $275;
      __label__ = 64;
      break;
     case 64:
      
      
      $c76 = HEAP[$in];
      
      
      
      
      var $282 = $in + 2;
      $in = $282;
      
      if ($c76 > 13 != 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 65:
      
      
      if ($c76 == 10) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      
      
      HEAP[$out66] = $c76;
      
      var $288 = $out66 + 2;
      $out66 = $288;
      
      var $290 = $seennl | 2;
      $seennl = $290;
      __label__ = 64;
      break;
     case 67:
      
      
      var $293 = $in;
      if ($c76 == 13) {
        __label__ = 68;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 68:
      
      
      if (HEAP[$293] == 10) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      
      var $297 = $in + 2;
      $in = $297;
      
      var $299 = $seennl | 4;
      $seennl = $299;
      __label__ = 71;
      break;
     case 70:
      
      var $301 = $seennl | 1;
      $seennl = $301;
      __label__ = 71;
      break;
     case 71:
      
      HEAP[$out66] = 10;
      
      var $304 = $out66 + 2;
      $out66 = $304;
      __label__ = 64;
      break;
     case 72:
      
      
      if ($293 > $end67) {
        __label__ = 74;
        break;
      } else {
        __label__ = 73;
        break;
      }
     case 73:
      
      
      HEAP[$out66] = $c76;
      
      var $310 = $out66 + 2;
      $out66 = $310;
      __label__ = 64;
      break;
     case 74:
      
      
      
      if ($translated != HEAP[$output]) {
        __label__ = 75;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 75:
      var $314 = HEAP[$output];
      
      
      var $317 = HEAP[$314] - 1;
      var $318 = $314;
      HEAP[$318] = $317;
      
      
      
      if (HEAP[$314] == 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 76:
      
      
      
      
      var $326 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $327 = HEAP[$output];
      FUNCTION_TABLE[$326]($327);
      __label__ = 77;
      break;
     case 77:
      
      HEAP[$output] = $translated;
      __label__ = 78;
      break;
     case 78:
      
      
      
      
      
      
      
      
      if ((($out66 - $out_str) / 2 | 0) != $len) {
        __label__ = 79;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 79:
      
      
      
      
      
      
      var $343 = _PyUnicodeUCS2_Resize($output, ($out66 - $out_str) / 2 | 0);
      
      if ($343 < 0) {
        __label__ = 81;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 80:
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      var $362 = HEAP[$self + 16] & -29;
      var $363 = ((HEAP[$self + 16] << 3 >>> 5 & 7 | $seennl & 255) & 7) << 2 & 28 | $362;
      HEAP[$self + 16] = $363;
      
      $0 = HEAP[$output];
      __label__ = 84;
      break;
     case 81:
      var $365 = HEAP[$output];
      
      
      var $368 = HEAP[$365] - 1;
      var $369 = $365;
      HEAP[$369] = $368;
      
      
      
      if (HEAP[$365] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 82:
      
      
      
      
      var $377 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $378 = HEAP[$output];
      FUNCTION_TABLE[$377]($378);
      __label__ = 83;
      break;
     case 83:
      $0 = 0;
      __label__ = 84;
      break;
     case 84:
      
      $retval = $0;
      var $retval98 = $retval;
      STACKTOP = __stackBase__;
      return $retval98;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_decode($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $0;
      var $kwlist = __stackBase__;
      var $input = __stackBase__ + 12;
      var $final = __stackBase__ + 16;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str16391;
      
      HEAP[$kwlist + 4] = __str17392;
      
      HEAP[$kwlist + 8] = 0;
      HEAP[$final] = 0;
      
      
      var $kwlist1 = $kwlist;
      var $6 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str18393, $kwlist1, allocate([ $input, 0, 0, 0, $final, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($6 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 3;
      break;
     case 2:
      var $8 = HEAP[$final];
      var $9 = HEAP[$input];
      
      
      var $12 = __PyIncrementalNewlineDecoder_decode($self_addr, $9, $8);
      $0 = $12;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval4 = $retval;
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_getstate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $buffer = __stackBase__;
      var $flag = __stackBase__ + 4;
      var $state;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      if (HEAP[$self_addr + 8] != __Py_NoneStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 1:
      var $5 = HEAP[__PyIO_str_getstate];
      
      
      var $8 = HEAP[$self_addr + 8];
      var $9 = _PyObject_CallMethodObjArgs($8, $5, allocate(4, "i8*", ALLOC_STACK));
      $state = $9;
      
      
      if ($state == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      $0 = 0;
      __label__ = 13;
      break;
     case 3:
      
      var $13 = __PyArg_Parse_SizeT($state, __str19394, allocate([ $buffer, 0, 0, 0, $flag, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i64*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($13 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 4:
      
      
      
      var $18 = HEAP[$state] - 1;
      
      
      HEAP[$state] = $18;
      
      
      
      
      if (HEAP[$state] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $29 = HEAP[HEAP[$state + 4] + 24];
      
      FUNCTION_TABLE[$29]($state);
      __label__ = 6;
      break;
     case 6:
      $0 = 0;
      __label__ = 13;
      break;
     case 7:
      
      
      
      var $34 = HEAP[HEAP[$buffer]] + 1;
      var $35 = HEAP[$buffer];
      HEAP[$35] = $34;
      
      
      
      var $39 = HEAP[$state] - 1;
      
      
      HEAP[$state] = $39;
      
      
      
      
      if (HEAP[$state] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      
      var $50 = HEAP[HEAP[$state + 4] + 24];
      
      FUNCTION_TABLE[$50]($state);
      __label__ = 10;
      break;
     case 9:
      var $52 = _PyString_FromString(__str20395);
      HEAP[$buffer] = $52;
      HEAP[$flag] = 0;
      __label__ = 10;
      break;
     case 10:
      
      var $54 = HEAP[$flag] * Math.pow(2, 1);
      HEAP[$flag] = $54;
      
      
      
      
      
      
      
      if ((HEAP[$self_addr + 16] << 7 >> 7 & 1) != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $62 = HEAP[$flag];
      var $63 = Runtime.or64($62, 1);
      HEAP[$flag] = $63;
      __label__ = 12;
      break;
     case 12:
      var $64 = HEAP[$flag];
      var $65 = HEAP[$buffer];
      var $66 = __Py_BuildValue_SizeT(__str21396, allocate([ $65, 0, 0, 0, $64, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      $0 = $66;
      __label__ = 13;
      break;
     case 13:
      
      $retval = $0;
      var $retval14 = $retval;
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_setstate($self, $state) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $state_addr;
      var $retval;
      var $0;
      var $buffer = __stackBase__;
      var $flag = __stackBase__ + 4;
      $self_addr = $self;
      $state_addr = $state;
      
      var $2 = __PyArg_Parse_SizeT($state_addr, __str19394, allocate([ $buffer, 0, 0, 0, $flag, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i64*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      
      
      
      
      var $12 = HEAP[$self_addr + 16] & -2;
      var $13 = HEAP[$flag] & 255 & 1 & 1 | $12;
      HEAP[$self_addr + 16] = $13;
      
      var $15 = HEAP[$flag] / Math.pow(2, 1);
      HEAP[$flag] = $15;
      
      
      
      
      if (HEAP[$self_addr + 8] != __Py_NoneStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $20 = HEAP[$flag];
      var $21 = HEAP[$buffer];
      
      
      var $24 = HEAP[$self_addr + 8];
      var $25 = __PyObject_CallMethod_SizeT($24, __str22397, __str23398, allocate([ $21, 0, 0, 0, $20, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      $0 = $25;
      __label__ = 5;
      break;
     case 4:
      
      var $27 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $27;
      $0 = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 5:
      
      $retval = $0;
      var $retval5 = $retval;
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_reset($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      var $4 = HEAP[$self_addr + 16] & -29;
      HEAP[$self_addr + 16] = $4;
      
      
      
      var $8 = HEAP[$self_addr + 16] & -2;
      HEAP[$self_addr + 16] = $8;
      
      
      
      
      if (HEAP[$self_addr + 8] != __Py_NoneStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $13 = HEAP[__PyIO_str_reset];
      
      
      var $16 = HEAP[$self_addr + 8];
      var $17 = _PyObject_CallMethodObjArgs($16, $13, allocate(4, "i8*", ALLOC_STACK));
      $0 = $17;
      __label__ = 3;
      break;
     case 2:
      
      var $19 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $19;
      $0 = __Py_NoneStruct;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_newlines_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      
      
      var $7 = HEAP[$self_addr + 16] << 3 >>> 5 & 7;
      if ($7 == 1) {
        __label__ = 1;
        break;
      } else if ($7 == 2) {
        __label__ = 2;
        break;
      } else if ($7 == 3) {
        __label__ = 4;
        break;
      } else if ($7 == 4) {
        __label__ = 3;
        break;
      } else if ($7 == 5) {
        __label__ = 5;
        break;
      } else if ($7 == 6) {
        __label__ = 6;
        break;
      } else if ($7 == 7) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 1:
      var $8 = _PyUnicodeUCS2_FromString(__str24399);
      $0 = $8;
      __label__ = 9;
      break;
     case 2:
      var $9 = _PyUnicodeUCS2_FromString(__str25400);
      $0 = $9;
      __label__ = 9;
      break;
     case 3:
      var $10 = _PyUnicodeUCS2_FromString(__str26401);
      $0 = $10;
      __label__ = 9;
      break;
     case 4:
      var $11 = __Py_BuildValue_SizeT(__str27402, allocate([ __str24399, 0, 0, 0, __str25400, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = $11;
      __label__ = 9;
      break;
     case 5:
      var $12 = __Py_BuildValue_SizeT(__str27402, allocate([ __str24399, 0, 0, 0, __str26401, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = $12;
      __label__ = 9;
      break;
     case 6:
      var $13 = __Py_BuildValue_SizeT(__str27402, allocate([ __str25400, 0, 0, 0, __str26401, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = $13;
      __label__ = 9;
      break;
     case 7:
      var $14 = __Py_BuildValue_SizeT(__str28403, allocate([ __str24399, 0, 0, 0, __str25400, 0, 0, 0, __str26401, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = $14;
      __label__ = 9;
      break;
     case 8:
      
      var $16 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $16;
      $0 = __Py_NoneStruct;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _ascii_encode($self, $text) {
    
    var $self_addr;
    var $text_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $text_addr = $text;
    
    
    
    
    
    var $6 = HEAP[$self_addr + 40] + 20;
    
    
    
    var $10 = HEAP[$text_addr + 8];
    
    
    
    var $14 = HEAP[$text_addr + 12];
    var $15 = _PyUnicodeUCS2_EncodeASCII($14, $10, $6);
    $0 = $15;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _utf16be_encode($self, $text) {
    
    var $self_addr;
    var $text_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $text_addr = $text;
    
    
    
    
    
    var $6 = HEAP[$self_addr + 40] + 20;
    
    
    
    var $10 = HEAP[$text_addr + 8];
    
    
    
    var $14 = HEAP[$text_addr + 12];
    var $15 = _PyUnicodeUCS2_EncodeUTF16($14, $10, $6, 1);
    $0 = $15;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _utf16le_encode($self, $text) {
    
    var $self_addr;
    var $text_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $text_addr = $text;
    
    
    
    
    
    var $6 = HEAP[$self_addr + 40] + 20;
    
    
    
    var $10 = HEAP[$text_addr + 8];
    
    
    
    var $14 = HEAP[$text_addr + 12];
    var $15 = _PyUnicodeUCS2_EncodeUTF16($14, $10, $6, -1);
    $0 = $15;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _utf16_encode($self, $text) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $text_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $text_addr = $text;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 60] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $7 = _utf16le_encode($5, $text_addr);
      $0 = $7;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      var $12 = HEAP[$5 + 40] + 20;
      
      
      
      var $16 = HEAP[$text_addr + 8];
      
      
      
      var $20 = HEAP[$text_addr + 12];
      var $21 = _PyUnicodeUCS2_EncodeUTF16($20, $16, $12, 0);
      $0 = $21;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf32be_encode($self, $text) {
    
    var $self_addr;
    var $text_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $text_addr = $text;
    
    
    
    
    
    var $6 = HEAP[$self_addr + 40] + 20;
    
    
    
    var $10 = HEAP[$text_addr + 8];
    
    
    
    var $14 = HEAP[$text_addr + 12];
    var $15 = _PyUnicodeUCS2_EncodeUTF32($14, $10, $6, 1);
    $0 = $15;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _utf32le_encode($self, $text) {
    
    var $self_addr;
    var $text_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $text_addr = $text;
    
    
    
    
    
    var $6 = HEAP[$self_addr + 40] + 20;
    
    
    
    var $10 = HEAP[$text_addr + 8];
    
    
    
    var $14 = HEAP[$text_addr + 12];
    var $15 = _PyUnicodeUCS2_EncodeUTF32($14, $10, $6, -1);
    $0 = $15;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _utf32_encode($self, $text) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $text_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $text_addr = $text;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 60] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $7 = _utf32le_encode($5, $text_addr);
      $0 = $7;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      var $12 = HEAP[$5 + 40] + 20;
      
      
      
      var $16 = HEAP[$text_addr + 8];
      
      
      
      var $20 = HEAP[$text_addr + 12];
      var $21 = _PyUnicodeUCS2_EncodeUTF32($20, $16, $12, 0);
      $0 = $21;
      __label__ = 3;
      break;
     case 3:
      
      $retval = $0;
      var $retval3 = $retval;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf8_encode($self, $text) {
    
    var $self_addr;
    var $text_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $text_addr = $text;
    
    
    
    
    
    var $6 = HEAP[$self_addr + 40] + 20;
    
    
    
    var $10 = HEAP[$text_addr + 8];
    
    
    
    var $14 = HEAP[$text_addr + 12];
    var $15 = _PyUnicodeUCS2_EncodeUTF8($14, $10, $6);
    $0 = $15;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _latin1_encode($self, $text) {
    
    var $self_addr;
    var $text_addr;
    var $retval;
    var $0;
    $self_addr = $self;
    $text_addr = $text;
    
    
    
    
    
    var $6 = HEAP[$self_addr + 40] + 20;
    
    
    
    var $10 = HEAP[$text_addr + 8];
    
    
    
    var $14 = HEAP[$text_addr + 12];
    var $15 = _PyUnicodeUCS2_EncodeLatin1($14, $10, $6);
    $0 = $15;
    
    $retval = $0;
    var $retval1 = $retval;
    return $retval1;
  }
  function _textiowrapper_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 44;
    _memset(__stackBase__, 0, 44);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $kwds_addr;
      var $retval;
      var $iftmp_118;
      var $iftmp_111;
      var $0;
      var $kwlist = __stackBase__;
      var $buffer = __stackBase__ + 24;
      var $raw;
      var $encoding = __stackBase__ + 28;
      var $errors = __stackBase__ + 32;
      var $newline = __stackBase__ + 36;
      var $line_buffering = __stackBase__ + 40;
      var $res;
      var $r;
      var $_py_tmp;
      var $_py_tmp17;
      var $_py_tmp21;
      var $_py_tmp25;
      var $_py_tmp29;
      var $_py_tmp33;
      var $_py_tmp37;
      var $_py_tmp41;
      var $_py_tmp45;
      var $_py_tmp49;
      var $_py_tmp59;
      var $incrementalDecoder;
      var $_py_tmp95;
      var $ci;
      var $e;
      var $cookieObj;
      var $cmp;
      $self_addr = $self;
      $args_addr = $args;
      $kwds_addr = $kwds;
      
      HEAP[$kwlist] = __str42418;
      
      HEAP[$kwlist + 4] = __str4378;
      
      HEAP[$kwlist + 8] = __str6380;
      
      HEAP[$kwlist + 12] = __str43419;
      
      HEAP[$kwlist + 16] = __str44420;
      
      HEAP[$kwlist + 20] = 0;
      HEAP[$encoding] = 0;
      HEAP[$errors] = 0;
      HEAP[$newline] = 0;
      HEAP[$line_buffering] = 0;
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      HEAP[$self_addr + 12] = 0;
      
      
      var $kwlist1 = $kwlist;
      var $13 = __PyArg_ParseTupleAndKeywords_SizeT($args_addr, $kwds_addr, __str45421, $kwlist1, allocate([ $buffer, 0, 0, 0, $encoding, 0, 0, 0, $errors, 0, 0, 0, $newline, 0, 0, 0, $line_buffering, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($13 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 134;
      break;
     case 2:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 4:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 10) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 8;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 11;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 10) {
        __label__ = 11;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      if (HEAP[HEAP[$newline] + 2] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $49 = HEAP[$newline];
      var $50 = HEAP[_PyExc_ValueError];
      var $51 = _PyErr_Format($50, __str46422, allocate([ $49, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = -1;
      __label__ = 134;
      break;
     case 12:
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      
      $_py_tmp = HEAP[$self_addr + 20];
      
      
      HEAP[$self_addr + 20] = 0;
      
      
      
      var $64 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $64;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $75 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$75]($_py_tmp);
      __label__ = 15;
      break;
     case 15:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      
      $_py_tmp17 = HEAP[$self_addr + 24];
      
      
      HEAP[$self_addr + 24] = 0;
      
      
      
      var $89 = HEAP[$_py_tmp17] - 1;
      
      
      HEAP[$_py_tmp17] = $89;
      
      
      
      
      if (HEAP[$_py_tmp17] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $100 = HEAP[HEAP[$_py_tmp17 + 4] + 24];
      
      FUNCTION_TABLE[$100]($_py_tmp17);
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      
      
      $_py_tmp21 = HEAP[$self_addr + 28];
      
      
      HEAP[$self_addr + 28] = 0;
      
      
      
      var $114 = HEAP[$_py_tmp21] - 1;
      
      
      HEAP[$_py_tmp21] = $114;
      
      
      
      
      if (HEAP[$_py_tmp21] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $125 = HEAP[HEAP[$_py_tmp21 + 4] + 24];
      
      FUNCTION_TABLE[$125]($_py_tmp21);
      __label__ = 21;
      break;
     case 21:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      
      
      $_py_tmp25 = HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = 0;
      
      
      
      var $139 = HEAP[$_py_tmp25] - 1;
      
      
      HEAP[$_py_tmp25] = $139;
      
      
      
      
      if (HEAP[$_py_tmp25] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $150 = HEAP[HEAP[$_py_tmp25 + 4] + 24];
      
      FUNCTION_TABLE[$150]($_py_tmp25);
      __label__ = 24;
      break;
     case 24:
      
      
      
      
      if (HEAP[$self_addr + 36] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 25:
      
      
      
      $_py_tmp29 = HEAP[$self_addr + 36];
      
      
      HEAP[$self_addr + 36] = 0;
      
      
      
      var $164 = HEAP[$_py_tmp29] - 1;
      
      
      HEAP[$_py_tmp29] = $164;
      
      
      
      
      if (HEAP[$_py_tmp29] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $175 = HEAP[HEAP[$_py_tmp29 + 4] + 24];
      
      FUNCTION_TABLE[$175]($_py_tmp29);
      __label__ = 27;
      break;
     case 27:
      
      
      
      
      if (HEAP[$self_addr + 64] != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 28:
      
      
      
      $_py_tmp33 = HEAP[$self_addr + 64];
      
      
      HEAP[$self_addr + 64] = 0;
      
      
      
      var $189 = HEAP[$_py_tmp33] - 1;
      
      
      HEAP[$_py_tmp33] = $189;
      
      
      
      
      if (HEAP[$_py_tmp33] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $200 = HEAP[HEAP[$_py_tmp33 + 4] + 24];
      
      FUNCTION_TABLE[$200]($_py_tmp33);
      __label__ = 30;
      break;
     case 30:
      
      
      
      
      if (HEAP[$self_addr + 72] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      
      $_py_tmp37 = HEAP[$self_addr + 72];
      
      
      HEAP[$self_addr + 72] = 0;
      
      
      
      var $214 = HEAP[$_py_tmp37] - 1;
      
      
      HEAP[$_py_tmp37] = $214;
      
      
      
      
      if (HEAP[$_py_tmp37] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $225 = HEAP[HEAP[$_py_tmp37 + 4] + 24];
      
      FUNCTION_TABLE[$225]($_py_tmp37);
      __label__ = 33;
      break;
     case 33:
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 34:
      
      
      
      $_py_tmp41 = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $239 = HEAP[$_py_tmp41] - 1;
      
      
      HEAP[$_py_tmp41] = $239;
      
      
      
      
      if (HEAP[$_py_tmp41] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      
      
      
      
      var $250 = HEAP[HEAP[$_py_tmp41 + 4] + 24];
      
      FUNCTION_TABLE[$250]($_py_tmp41);
      __label__ = 36;
      break;
     case 36:
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 37:
      
      
      
      $_py_tmp45 = HEAP[$self_addr + 40];
      
      
      HEAP[$self_addr + 40] = 0;
      
      
      
      var $264 = HEAP[$_py_tmp45] - 1;
      
      
      HEAP[$_py_tmp45] = $264;
      
      
      
      
      if (HEAP[$_py_tmp45] == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      
      var $275 = HEAP[HEAP[$_py_tmp45 + 4] + 24];
      
      FUNCTION_TABLE[$275]($_py_tmp45);
      __label__ = 39;
      break;
     case 39:
      
      
      
      
      if (HEAP[$self_addr + 84] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      
      
      
      $_py_tmp49 = HEAP[$self_addr + 84];
      
      
      HEAP[$self_addr + 84] = 0;
      
      
      
      var $289 = HEAP[$_py_tmp49] - 1;
      
      
      HEAP[$_py_tmp49] = $289;
      
      
      
      
      if (HEAP[$_py_tmp49] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $300 = HEAP[HEAP[$_py_tmp49 + 4] + 24];
      
      FUNCTION_TABLE[$300]($_py_tmp49);
      __label__ = 42;
      break;
     case 42:
      
      
      HEAP[$self_addr + 68] = 0;
      
      
      HEAP[$self_addr + 76] = 0;
      
      
      HEAP[$self_addr + 56] = 0;
      
      
      HEAP[$self_addr + 44] = 0;
      
      
      if (HEAP[$encoding] == 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 43:
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 44:
      
      
      if (HEAP[__PyIO_locale_module] == 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 45:
      var $318 = _PyImport_ImportModule(__str47423);
      HEAP[__PyIO_locale_module] = $318;
      
      
      if (HEAP[__PyIO_locale_module] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      var $321 = HEAP[__PyIO_locale_module];
      var $322 = __PyObject_CallMethod_SizeT($321, __str48424, 0, allocate(1, "i32", ALLOC_STACK));
      
      
      HEAP[$self_addr + 24] = $322;
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 47:
      var $329 = HEAP[_PyExc_ImportError];
      var $330 = _PyErr_ExceptionMatches($329);
      
      if ($330 != 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 133;
        break;
      }
     case 48:
      _PyErr_Clear();
      var $332 = _PyString_FromString(__str33409);
      
      
      HEAP[$self_addr + 24] = $332;
      __label__ = 53;
      break;
     case 49:
      
      
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$self_addr + 24] + 4] + 84] & 134217728) == 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 50:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 51;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 51:
      
      
      
      $_py_tmp59 = HEAP[$self_addr + 24];
      
      
      HEAP[$self_addr + 24] = 0;
      
      
      
      var $356 = HEAP[$_py_tmp59] - 1;
      
      
      HEAP[$_py_tmp59] = $356;
      
      
      
      
      if (HEAP[$_py_tmp59] == 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 52:
      
      
      
      
      var $367 = HEAP[HEAP[$_py_tmp59 + 4] + 24];
      
      FUNCTION_TABLE[$367]($_py_tmp59);
      __label__ = 53;
      break;
     case 53:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      
      var $375 = HEAP[$self_addr + 24];
      var $376 = _PyString_AsString($375);
      HEAP[$encoding] = $376;
      __label__ = 58;
      break;
     case 55:
      
      
      if (HEAP[$encoding] != 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 56:
      var $379 = HEAP[$encoding];
      var $380 = _PyString_FromString($379);
      
      
      HEAP[$self_addr + 24] = $380;
      
      
      
      
      if (HEAP[$self_addr + 24] == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      var $387 = HEAP[_PyExc_IOError];
      _PyErr_SetString($387, __str49425);
      __label__ = 58;
      break;
     case 58:
      
      
      if (HEAP[$errors] == 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 59:
      HEAP[$errors] = __str11386;
      __label__ = 60;
      break;
     case 60:
      var $390 = HEAP[$errors];
      var $391 = _PyString_FromString($390);
      
      
      HEAP[$self_addr + 40] = $391;
      
      
      
      
      if (HEAP[$self_addr + 40] == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 61:
      
      
      HEAP[$self_addr + 16] = 8192;
      
      
      if (HEAP[$newline] == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      
      
      
      
      if (HEAP[HEAP[$newline]] == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 63:
      $iftmp_111 = 1;
      __label__ = 65;
      break;
     case 64:
      $iftmp_111 = 0;
      __label__ = 65;
      break;
     case 65:
      
      
      
      
      HEAP[$self_addr + 49] = $iftmp_111 & 255;
      
      var $411 = HEAP[$line_buffering] & 255;
      
      
      HEAP[$self_addr + 48] = $411;
      
      
      var $416 = HEAP[$newline] == 0;
      
      
      HEAP[$self_addr + 50] = $416;
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 66:
      var $421 = HEAP[$newline];
      var $422 = _PyString_FromString($421);
      
      
      HEAP[$self_addr + 36] = $422;
      
      
      
      
      if (HEAP[$self_addr + 36] == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      $0 = -1;
      __label__ = 134;
      break;
     case 68:
      
      
      if (HEAP[$newline] == 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 69:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 70:
      $iftmp_118 = 1;
      __label__ = 72;
      break;
     case 71:
      $iftmp_118 = 0;
      __label__ = 72;
      break;
     case 72:
      
      
      
      
      HEAP[$self_addr + 51] = $iftmp_118 & 255;
      
      
      
      
      if (HEAP[$self_addr + 49] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 73:
      
      
      
      
      if (HEAP[$self_addr + 51] != 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 74:
      
      
      var $448 = HEAP[$self_addr + 36];
      var $449 = _PyString_AsString($448);
      
      
      HEAP[$self_addr + 44] = $449;
      
      
      var $454 = HEAP[$self_addr + 44];
      var $455 = _strcmp($454, __str25400);
      
      if ($455 == 0) {
        __label__ = 75;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 75:
      
      
      HEAP[$self_addr + 44] = 0;
      __label__ = 76;
      break;
     case 76:
      var $459 = HEAP[$buffer];
      var $460 = __PyObject_CallMethod_SizeT($459, __str50426, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $460;
      
      if ($460 == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 77:
      
      var $463 = _PyObject_IsTrue($res);
      $r = $463;
      
      
      
      var $467 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $467;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 78;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 78:
      
      
      
      
      var $478 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$478]($res);
      __label__ = 79;
      break;
     case 79:
      
      var $481 = $r == -1;
      if ($481) {
        __label__ = 133;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 80:
      
      
      if ($r == 1) {
        __label__ = 81;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 81:
      var $484 = HEAP[$errors];
      var $485 = HEAP[$encoding];
      var $486 = _PyCodec_IncrementalDecoder($485, $484);
      
      
      HEAP[$self_addr + 32] = $486;
      
      
      
      
      if (HEAP[$self_addr + 32] == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 82;
        break;
      }
     case 82:
      
      
      
      
      if (HEAP[$self_addr + 49] != 0) {
        __label__ = 83;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 83:
      
      
      
      var $500 = HEAP[$self_addr + 50];
      
      
      var $503 = HEAP[$self_addr + 32];
      var $504 = __PyObject_CallFunction_SizeT(_PyIncrementalNewlineDecoder_Type, __str51427, allocate([ $503, 0, 0, 0, $500, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $incrementalDecoder = $504;
      
      
      if ($incrementalDecoder == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 84:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 85;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 85:
      
      
      
      $_py_tmp95 = HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = 0;
      
      
      
      var $519 = HEAP[$_py_tmp95] - 1;
      
      
      HEAP[$_py_tmp95] = $519;
      
      
      
      
      if (HEAP[$_py_tmp95] == 0) {
        __label__ = 86;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 86:
      
      
      
      
      var $530 = HEAP[HEAP[$_py_tmp95 + 4] + 24];
      
      FUNCTION_TABLE[$530]($_py_tmp95);
      __label__ = 87;
      break;
     case 87:
      
      
      
      HEAP[$self_addr + 32] = $incrementalDecoder;
      __label__ = 88;
      break;
     case 88:
      var $535 = HEAP[$buffer];
      var $536 = __PyObject_CallMethod_SizeT($535, __str52428, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $536;
      
      if ($536 == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 89;
        break;
      }
     case 89:
      
      var $539 = _PyObject_IsTrue($res);
      $r = $539;
      
      
      
      var $543 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $543;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 91;
        break;
      }
     case 90:
      
      
      
      
      var $554 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$554]($res);
      __label__ = 91;
      break;
     case 91:
      
      var $557 = $r == -1;
      if ($557) {
        __label__ = 133;
        break;
      } else {
        __label__ = 92;
        break;
      }
     case 92:
      
      
      if ($r == 1) {
        __label__ = 93;
        break;
      } else {
        __label__ = 109;
        break;
      }
     case 93:
      var $560 = HEAP[$errors];
      var $561 = HEAP[$encoding];
      var $562 = _PyCodec_IncrementalEncoder($561, $560);
      
      
      HEAP[$self_addr + 28] = $562;
      
      
      
      
      if (HEAP[$self_addr + 28] == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 94;
        break;
      }
     case 94:
      var $569 = HEAP[$encoding];
      var $570 = __PyCodec_Lookup($569);
      $ci = $570;
      
      
      if ($ci == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 95;
        break;
      }
     case 95:
      
      var $574 = _PyObject_GetAttrString($ci, __str53429);
      $res = $574;
      
      
      
      var $578 = HEAP[$ci] - 1;
      
      
      HEAP[$ci] = $578;
      
      
      
      
      if (HEAP[$ci] == 0) {
        __label__ = 96;
        break;
      } else {
        __label__ = 97;
        break;
      }
     case 96:
      
      
      
      
      var $589 = HEAP[HEAP[$ci + 4] + 24];
      
      FUNCTION_TABLE[$589]($ci);
      __label__ = 97;
      break;
     case 97:
      
      
      if ($res == 0) {
        __label__ = 98;
        break;
      } else {
        __label__ = 100;
        break;
      }
     case 98:
      var $593 = HEAP[_PyExc_AttributeError];
      var $594 = _PyErr_ExceptionMatches($593);
      
      if ($594 != 0) {
        __label__ = 99;
        break;
      } else {
        __label__ = 133;
        break;
      }
     case 99:
      _PyErr_Clear();
      __label__ = 106;
      break;
     case 100:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$res + 4] + 84] & 134217728) != 0) {
        __label__ = 101;
        break;
      } else {
        __label__ = 106;
        break;
      }
     case 101:
      $e = _encodefuncs;
      __label__ = 105;
      break;
     case 102:
      
      
      var $605 = HEAP[$e];
      
      
      
      
      var $610 = _strcmp($res + 20, $605);
      
      var $612 = $e;
      if ($610 == 0) {
        __label__ = 103;
        break;
      } else {
        __label__ = 104;
        break;
      }
     case 103:
      
      var $614 = HEAP[$612 + 4];
      
      
      HEAP[$self_addr + 56] = $614;
      __label__ = 106;
      break;
     case 104:
      var $617 = $612 + 8;
      $e = $617;
      __label__ = 105;
      break;
     case 105:
      
      
      
      
      if (HEAP[$e] != 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 106;
        break;
      }
     case 106:
      
      
      if ($res != 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 109;
        break;
      }
     case 107:
      
      
      
      var $627 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $627;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 108;
        break;
      } else {
        __label__ = 109;
        break;
      }
     case 108:
      
      
      
      
      var $638 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$638]($res);
      __label__ = 109;
      break;
     case 109:
      var $640 = HEAP[$buffer];
      
      
      HEAP[$self_addr + 20] = $640;
      
      
      
      var $646 = HEAP[HEAP[$buffer]] + 1;
      var $647 = HEAP[$buffer];
      HEAP[$647] = $646;
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] == _PyBufferedReader_Type) {
        __label__ = 112;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 110:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] == _PyBufferedWriter_Type) {
        __label__ = 112;
        break;
      } else {
        __label__ = 111;
        break;
      }
     case 111:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] == _PyBufferedRandom_Type) {
        __label__ = 112;
        break;
      } else {
        __label__ = 119;
        break;
      }
     case 112:
      var $660 = HEAP[$buffer];
      var $661 = _PyObject_GetAttrString($660, __str35);
      $raw = $661;
      
      if ($661 == 0) {
        __label__ = 113;
        break;
      } else {
        __label__ = 115;
        break;
      }
     case 113:
      var $663 = HEAP[_PyExc_AttributeError];
      var $664 = _PyErr_ExceptionMatches($663);
      
      if ($664 != 0) {
        __label__ = 114;
        break;
      } else {
        __label__ = 133;
        break;
      }
     case 114:
      _PyErr_Clear();
      __label__ = 119;
      break;
     case 115:
      
      
      
      
      if (HEAP[$raw + 4] == _PyFileIO_Type) {
        __label__ = 116;
        break;
      } else {
        __label__ = 117;
        break;
      }
     case 116:
      
      
      
      HEAP[$self_addr + 84] = $raw;
      __label__ = 119;
      break;
     case 117:
      
      
      
      var $676 = HEAP[$raw] - 1;
      
      
      HEAP[$raw] = $676;
      
      
      
      
      if (HEAP[$raw] == 0) {
        __label__ = 118;
        break;
      } else {
        __label__ = 119;
        break;
      }
     case 118:
      
      
      
      
      var $687 = HEAP[HEAP[$raw + 4] + 24];
      
      FUNCTION_TABLE[$687]($raw);
      __label__ = 119;
      break;
     case 119:
      var $689 = HEAP[$buffer];
      var $690 = __PyObject_CallMethod_SizeT($689, __str55431, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $690;
      
      if ($690 == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 120;
        break;
      }
     case 120:
      
      var $693 = _PyObject_IsTrue($res);
      
      
      
      HEAP[$self_addr + 53] = $693 & 255;
      
      
      var $699 = HEAP[$self_addr + 53];
      
      
      HEAP[$self_addr + 52] = $699;
      
      
      
      var $705 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $705;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 121;
        break;
      } else {
        __label__ = 122;
        break;
      }
     case 121:
      
      
      
      
      var $716 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$716]($res);
      __label__ = 122;
      break;
     case 122:
      
      
      HEAP[$self_addr + 60] = 0;
      
      
      
      
      if (HEAP[$self_addr + 52] != 0) {
        __label__ = 123;
        break;
      } else {
        __label__ = 132;
        break;
      }
     case 123:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 124;
        break;
      } else {
        __label__ = 132;
        break;
      }
     case 124:
      
      
      HEAP[$self_addr + 60] = 1;
      var $730 = HEAP[__PyIO_str_tell];
      var $731 = HEAP[$buffer];
      var $732 = _PyObject_CallMethodObjArgs($731, $730, allocate(4, "i8*", ALLOC_STACK));
      $cookieObj = $732;
      
      
      if ($cookieObj == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 125;
        break;
      }
     case 125:
      var $735 = HEAP[__PyIO_zero];
      
      var $737 = _PyObject_RichCompareBool($cookieObj, $735, 2);
      $cmp = $737;
      
      
      
      var $741 = HEAP[$cookieObj] - 1;
      
      
      HEAP[$cookieObj] = $741;
      
      
      
      
      if (HEAP[$cookieObj] == 0) {
        __label__ = 126;
        break;
      } else {
        __label__ = 127;
        break;
      }
     case 126:
      
      
      
      
      var $752 = HEAP[HEAP[$cookieObj + 4] + 24];
      
      FUNCTION_TABLE[$752]($cookieObj);
      __label__ = 127;
      break;
     case 127:
      
      
      if ($cmp < 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 128;
        break;
      }
     case 128:
      
      
      if ($cmp == 0) {
        __label__ = 129;
        break;
      } else {
        __label__ = 132;
        break;
      }
     case 129:
      
      
      HEAP[$self_addr + 60] = 0;
      var $760 = HEAP[__PyIO_zero];
      var $761 = HEAP[__PyIO_str_setstate];
      
      
      var $764 = HEAP[$self_addr + 28];
      var $765 = _PyObject_CallMethodObjArgs($764, $761, allocate([ $760, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $765;
      
      
      if ($res == 0) {
        __label__ = 133;
        break;
      } else {
        __label__ = 130;
        break;
      }
     case 130:
      
      
      
      var $771 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $771;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 131;
        break;
      } else {
        __label__ = 132;
        break;
      }
     case 131:
      
      
      
      
      var $782 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$782]($res);
      __label__ = 132;
      break;
     case 132:
      
      
      HEAP[$self_addr + 8] = 1;
      $0 = 0;
      __label__ = 134;
      break;
     case 133:
      $0 = -1;
      __label__ = 134;
      break;
     case 134:
      
      $retval = $0;
      var $retval144 = $retval;
      STACKTOP = __stackBase__;
      return $retval144;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      var $_py_tmp7;
      var $_py_tmp11;
      var $_py_tmp15;
      var $_py_tmp19;
      var $_py_tmp23;
      var $_py_tmp27;
      var $_py_tmp31;
      var $_py_tmp35;
      var $_py_tmp39;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = __PyIOBase_finalize($self_addr);
      
      if ($7 < 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      $0 = -1;
      __label__ = 34;
      break;
     case 3:
      
      
      HEAP[$self_addr + 8] = 0;
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      
      $_py_tmp = HEAP[$self_addr + 20];
      
      
      HEAP[$self_addr + 20] = 0;
      
      
      
      var $23 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $23;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $34 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$34]($_py_tmp);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      $_py_tmp7 = HEAP[$self_addr + 24];
      
      
      HEAP[$self_addr + 24] = 0;
      
      
      
      var $48 = HEAP[$_py_tmp7] - 1;
      
      
      HEAP[$_py_tmp7] = $48;
      
      
      
      
      if (HEAP[$_py_tmp7] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $59 = HEAP[HEAP[$_py_tmp7 + 4] + 24];
      
      FUNCTION_TABLE[$59]($_py_tmp7);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      
      
      $_py_tmp11 = HEAP[$self_addr + 28];
      
      
      HEAP[$self_addr + 28] = 0;
      
      
      
      var $73 = HEAP[$_py_tmp11] - 1;
      
      
      HEAP[$_py_tmp11] = $73;
      
      
      
      
      if (HEAP[$_py_tmp11] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $84 = HEAP[HEAP[$_py_tmp11 + 4] + 24];
      
      FUNCTION_TABLE[$84]($_py_tmp11);
      __label__ = 12;
      break;
     case 12:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      
      $_py_tmp15 = HEAP[$self_addr + 32];
      
      
      HEAP[$self_addr + 32] = 0;
      
      
      
      var $98 = HEAP[$_py_tmp15] - 1;
      
      
      HEAP[$_py_tmp15] = $98;
      
      
      
      
      if (HEAP[$_py_tmp15] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $109 = HEAP[HEAP[$_py_tmp15 + 4] + 24];
      
      FUNCTION_TABLE[$109]($_py_tmp15);
      __label__ = 15;
      break;
     case 15:
      
      
      
      
      if (HEAP[$self_addr + 36] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      
      $_py_tmp19 = HEAP[$self_addr + 36];
      
      
      HEAP[$self_addr + 36] = 0;
      
      
      
      var $123 = HEAP[$_py_tmp19] - 1;
      
      
      HEAP[$_py_tmp19] = $123;
      
      
      
      
      if (HEAP[$_py_tmp19] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $134 = HEAP[HEAP[$_py_tmp19 + 4] + 24];
      
      FUNCTION_TABLE[$134]($_py_tmp19);
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      if (HEAP[$self_addr + 64] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      
      
      $_py_tmp23 = HEAP[$self_addr + 64];
      
      
      HEAP[$self_addr + 64] = 0;
      
      
      
      var $148 = HEAP[$_py_tmp23] - 1;
      
      
      HEAP[$_py_tmp23] = $148;
      
      
      
      
      if (HEAP[$_py_tmp23] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $159 = HEAP[HEAP[$_py_tmp23 + 4] + 24];
      
      FUNCTION_TABLE[$159]($_py_tmp23);
      __label__ = 21;
      break;
     case 21:
      
      
      
      
      if (HEAP[$self_addr + 72] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      
      
      $_py_tmp27 = HEAP[$self_addr + 72];
      
      
      HEAP[$self_addr + 72] = 0;
      
      
      
      var $173 = HEAP[$_py_tmp27] - 1;
      
      
      HEAP[$_py_tmp27] = $173;
      
      
      
      
      if (HEAP[$_py_tmp27] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $184 = HEAP[HEAP[$_py_tmp27 + 4] + 24];
      
      FUNCTION_TABLE[$184]($_py_tmp27);
      __label__ = 24;
      break;
     case 24:
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 25:
      
      
      
      $_py_tmp31 = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $198 = HEAP[$_py_tmp31] - 1;
      
      
      HEAP[$_py_tmp31] = $198;
      
      
      
      
      if (HEAP[$_py_tmp31] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $209 = HEAP[HEAP[$_py_tmp31 + 4] + 24];
      
      FUNCTION_TABLE[$209]($_py_tmp31);
      __label__ = 27;
      break;
     case 27:
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 28:
      
      
      
      $_py_tmp35 = HEAP[$self_addr + 40];
      
      
      HEAP[$self_addr + 40] = 0;
      
      
      
      var $223 = HEAP[$_py_tmp35] - 1;
      
      
      HEAP[$_py_tmp35] = $223;
      
      
      
      
      if (HEAP[$_py_tmp35] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $234 = HEAP[HEAP[$_py_tmp35 + 4] + 24];
      
      FUNCTION_TABLE[$234]($_py_tmp35);
      __label__ = 30;
      break;
     case 30:
      
      
      
      
      if (HEAP[$self_addr + 84] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      
      $_py_tmp39 = HEAP[$self_addr + 84];
      
      
      HEAP[$self_addr + 84] = 0;
      
      
      
      var $248 = HEAP[$_py_tmp39] - 1;
      
      
      HEAP[$_py_tmp39] = $248;
      
      
      
      
      if (HEAP[$_py_tmp39] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $259 = HEAP[HEAP[$_py_tmp39 + 4] + 24];
      
      FUNCTION_TABLE[$259]($_py_tmp39);
      __label__ = 33;
      break;
     case 33:
      $0 = 0;
      __label__ = 34;
      break;
     case 34:
      
      $retval = $0;
      var $retval43 = $retval;
      return $retval43;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_dealloc($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $g;
      var $_py_tmp;
      $self_addr = $self;
      
      var $1 = __textiowrapper_clear($self_addr);
      
      if ($1 < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      var $5 = $self_addr + -12;
      $g = $5;
      
      
      
      
      var $10 = HEAP[$g + 8] == -2;
      if ($10) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str56432, __str15390, 1070, ___PRETTY_FUNCTION___9695);
      throw "Reached an unreachable!";
     case 3:
      
      
      
      HEAP[$g + 8] = -2;
      
      
      
      
      
      
      
      var $21 = HEAP[$g];
      
      var $23 = HEAP[$g + 4];
      HEAP[$23] = $21;
      
      
      
      
      
      
      
      var $31 = HEAP[$g + 4];
      
      var $33 = HEAP[$g] + 4;
      HEAP[$33] = $31;
      
      
      
      HEAP[$g] = 0;
      
      
      
      
      if (HEAP[$self_addr + 88] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      _PyObject_ClearWeakRefs($self_addr);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[$self_addr + 92] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      
      $_py_tmp = HEAP[$self_addr + 92];
      
      
      HEAP[$self_addr + 92] = 0;
      
      
      
      var $55 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $55;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $66 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$66]($_py_tmp);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      var $73 = HEAP[HEAP[$self_addr + 4] + 160];
      
      
      FUNCTION_TABLE[$73]($self_addr);
      __label__ = 9;
      break;
     case 9:
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_traverse($self, $visit, $arg) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $visit_addr;
      var $arg_addr;
      var $retval;
      var $0;
      var $vret;
      var $vret4;
      var $vret8;
      var $vret12;
      var $vret16;
      var $vret20;
      var $vret24;
      var $vret28;
      var $vret32;
      var $vret36;
      var $vret40;
      $self_addr = $self;
      $visit_addr = $visit;
      $arg_addr = $arg;
      
      
      
      
      if (HEAP[$self_addr + 20] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[$self_addr + 20];
      var $8 = $visit_addr;
      
      var $10 = FUNCTION_TABLE[$8]($7, $arg_addr);
      $vret = $10;
      
      
      if ($vret != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      $0 = $vret;
      __label__ = 34;
      break;
     case 3:
      
      
      
      
      if (HEAP[$self_addr + 24] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      var $20 = HEAP[$self_addr + 24];
      var $21 = $visit_addr;
      
      var $23 = FUNCTION_TABLE[$21]($20, $arg_addr);
      $vret4 = $23;
      
      
      if ($vret4 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      $0 = $vret4;
      __label__ = 34;
      break;
     case 6:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      var $33 = HEAP[$self_addr + 28];
      var $34 = $visit_addr;
      
      var $36 = FUNCTION_TABLE[$34]($33, $arg_addr);
      $vret8 = $36;
      
      
      if ($vret8 != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      $0 = $vret8;
      __label__ = 34;
      break;
     case 9:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      
      var $46 = HEAP[$self_addr + 32];
      var $47 = $visit_addr;
      
      var $49 = FUNCTION_TABLE[$47]($46, $arg_addr);
      $vret12 = $49;
      
      
      if ($vret12 != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      $0 = $vret12;
      __label__ = 34;
      break;
     case 12:
      
      
      
      
      if (HEAP[$self_addr + 36] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      var $59 = HEAP[$self_addr + 36];
      var $60 = $visit_addr;
      
      var $62 = FUNCTION_TABLE[$60]($59, $arg_addr);
      $vret16 = $62;
      
      
      if ($vret16 != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      $0 = $vret16;
      __label__ = 34;
      break;
     case 15:
      
      
      
      
      if (HEAP[$self_addr + 64] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      var $72 = HEAP[$self_addr + 64];
      var $73 = $visit_addr;
      
      var $75 = FUNCTION_TABLE[$73]($72, $arg_addr);
      $vret20 = $75;
      
      
      if ($vret20 != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      $0 = $vret20;
      __label__ = 34;
      break;
     case 18:
      
      
      
      
      if (HEAP[$self_addr + 72] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      
      var $85 = HEAP[$self_addr + 72];
      var $86 = $visit_addr;
      
      var $88 = FUNCTION_TABLE[$86]($85, $arg_addr);
      $vret24 = $88;
      
      
      if ($vret24 != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      $0 = $vret24;
      __label__ = 34;
      break;
     case 21:
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      
      var $98 = HEAP[$self_addr + 80];
      var $99 = $visit_addr;
      
      var $101 = FUNCTION_TABLE[$99]($98, $arg_addr);
      $vret28 = $101;
      
      
      if ($vret28 != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      $0 = $vret28;
      __label__ = 34;
      break;
     case 24:
      
      
      
      
      if (HEAP[$self_addr + 40] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 25:
      
      
      var $111 = HEAP[$self_addr + 40];
      var $112 = $visit_addr;
      
      var $114 = FUNCTION_TABLE[$112]($111, $arg_addr);
      $vret32 = $114;
      
      
      if ($vret32 != 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      $0 = $vret32;
      __label__ = 34;
      break;
     case 27:
      
      
      
      
      if (HEAP[$self_addr + 84] != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 28:
      
      
      var $124 = HEAP[$self_addr + 84];
      var $125 = $visit_addr;
      
      var $127 = FUNCTION_TABLE[$125]($124, $arg_addr);
      $vret36 = $127;
      
      
      if ($vret36 != 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      $0 = $vret36;
      __label__ = 34;
      break;
     case 30:
      
      
      
      
      if (HEAP[$self_addr + 92] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      var $137 = HEAP[$self_addr + 92];
      var $138 = $visit_addr;
      
      var $140 = FUNCTION_TABLE[$138]($137, $arg_addr);
      $vret40 = $140;
      
      
      if ($vret40 != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      $0 = $vret40;
      __label__ = 34;
      break;
     case 33:
      $0 = 0;
      __label__ = 34;
      break;
     case 34:
      
      $retval = $0;
      var $retval44 = $retval;
      return $retval44;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_clear($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $_py_tmp;
      $self_addr = $self;
      
      var $2 = __textiowrapper_clear($self_addr);
      
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 6;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 92] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      $_py_tmp = HEAP[$self_addr + 92];
      
      
      HEAP[$self_addr + 92] = 0;
      
      
      
      var $16 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $16;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $27 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$27]($_py_tmp);
      __label__ = 5;
      break;
     case 5:
      $0 = 0;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_detach($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $buffer;
      var $res;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 10;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_flush];
      
      
      var $13 = _PyObject_CallMethodObjArgs($self_addr, $10, allocate(4, "i8*", ALLOC_STACK));
      $res = $13;
      
      
      if ($res == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 10;
      break;
     case 7:
      
      
      
      var $19 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $19;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $30 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$30]($res);
      __label__ = 9;
      break;
     case 9:
      
      
      
      $buffer = HEAP[$self_addr + 20];
      
      
      HEAP[$self_addr + 20] = 0;
      
      
      HEAP[$self_addr + 12] = 1;
      
      
      HEAP[$self_addr + 8] = 0;
      
      $0 = $buffer;
      __label__ = 10;
      break;
     case 10:
      
      $retval = $0;
      var $retval10 = $retval;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _findchar($s, $size, $ch) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $s_addr;
      var $size_addr;
      var $ch_addr;
      var $retval;
      var $0;
      $s_addr = $s;
      $size_addr = $size;
      $ch_addr = $ch;
      __label__ = 4;
      break;
     case 1:
      
      
      
      
      var $5 = $s_addr;
      if (HEAP[$s_addr] == $ch_addr) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      $0 = $5;
      __label__ = 6;
      break;
     case 3:
      var $6 = $5 + 2;
      $s_addr = $6;
      __label__ = 4;
      break;
     case 4:
      
      
      var $9 = $size_addr > 0;
      
      var $11 = $size_addr - 1;
      $size_addr = $11;
      
      if ($9 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      $0 = 0;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_writeflush($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $pending;
      var $b;
      var $ret;
      var $_py_tmp;
      $self_addr = $self;
      
      
      
      
      if (HEAP[$self_addr + 72] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = 0;
      __label__ = 16;
      break;
     case 2:
      
      
      
      $pending = HEAP[$self_addr + 72];
      
      
      
      var $11 = HEAP[$pending] + 1;
      
      
      HEAP[$pending] = $11;
      
      
      HEAP[$self_addr + 76] = 0;
      
      
      
      
      if (HEAP[$self_addr + 72] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      $_py_tmp = HEAP[$self_addr + 72];
      
      
      HEAP[$self_addr + 72] = 0;
      
      
      
      var $28 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $28;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $39 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$39]($_py_tmp);
      __label__ = 5;
      break;
     case 5:
      var $41 = HEAP[__PyIO_empty_bytes];
      
      var $43 = __PyString_Join($41, $pending);
      $b = $43;
      
      
      
      var $47 = HEAP[$pending] - 1;
      
      
      HEAP[$pending] = $47;
      
      
      
      
      if (HEAP[$pending] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $58 = HEAP[HEAP[$pending + 4] + 24];
      
      FUNCTION_TABLE[$58]($pending);
      __label__ = 7;
      break;
     case 7:
      
      
      if ($b == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = -1;
      __label__ = 16;
      break;
     case 9:
      var $62 = HEAP[__PyIO_str_write];
      
      
      var $65 = HEAP[$self_addr + 20];
      
      var $67 = _PyObject_CallMethodObjArgs($65, $62, allocate([ $b, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $ret = $67;
      
      
      
      var $71 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $71;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $82 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$82]($b);
      __label__ = 11;
      break;
     case 11:
      
      
      if ($ret == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      $0 = -1;
      __label__ = 16;
      break;
     case 13:
      
      
      
      var $89 = HEAP[$ret] - 1;
      
      
      HEAP[$ret] = $89;
      
      
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $100 = HEAP[HEAP[$ret + 4] + 24];
      
      FUNCTION_TABLE[$100]($ret);
      __label__ = 15;
      break;
     case 15:
      $0 = 0;
      __label__ = 16;
      break;
     case 16:
      
      $retval = $0;
      var $retval16 = $retval;
      return $retval16;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $ret;
      var $text = __stackBase__;
      var $b;
      var $textlen;
      var $haslf;
      var $needflush;
      var $r;
      var $_res;
      var $newtext;
      var $_py_tmp;
      $self_addr = $self;
      $args_addr = $args;
      $haslf = 0;
      $needflush = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 76;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str59435, allocate([ $text, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 76;
      break;
     case 7:
      
      
      
      
      
      var $18 = $self_addr;
      if (HEAP[$self_addr + 4] == _PyTextIOWrapper_Type) {
        __label__ = 8;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 8:
      
      
      
      var $22 = $self_addr;
      if (HEAP[$18 + 84] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      var $24 = HEAP[$22 + 84];
      var $25 = __PyFileIO_closed($24);
      $r = $25;
      __lastLabel__ = 9;
      __label__ = 16;
      break;
     case 10:
      var $26 = _textiowrapper_closed_get($22, 0);
      $_res = $26;
      
      
      if ($_res == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      $0 = 0;
      __label__ = 76;
      break;
     case 12:
      
      var $30 = _PyObject_IsTrue($_res);
      $r = $30;
      
      
      
      var $34 = HEAP[$_res] - 1;
      
      
      HEAP[$_res] = $34;
      
      
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $45 = HEAP[HEAP[$_res + 4] + 24];
      
      FUNCTION_TABLE[$45]($_res);
      __label__ = 14;
      break;
     case 14:
      var $47 = $r;
      
      if ($47 < 0) {
        __lastLabel__ = 14;
        __label__ = 15;
        break;
      } else {
        __lastLabel__ = 14;
        __label__ = 16;
        break;
      }
     case 15:
      $0 = 0;
      __label__ = 76;
      break;
     case 16:
      var $49 = __lastLabel__ == 14 ? $47 : $25;
      
      if ($49 > 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      var $51 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($51, __str60436);
      $0 = 0;
      __label__ = 76;
      break;
     case 18:
      
      var $53 = __PyIOBase_check_closed($18, __Py_TrueStruct);
      
      if ($53 == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      $0 = 0;
      __label__ = 76;
      break;
     case 20:
      
      
      
      
      if (HEAP[$self_addr + 28] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      var $59 = HEAP[_PyExc_IOError];
      _PyErr_SetString($59, __str61437);
      $0 = 0;
      __label__ = 76;
      break;
     case 22:
      
      
      
      var $63 = HEAP[HEAP[$text]] + 1;
      var $64 = HEAP[$text];
      HEAP[$64] = $63;
      var $65 = HEAP[$text];
      var $66 = _PyUnicodeUCS2_GetSize($65);
      $textlen = $66;
      
      
      
      
      if (HEAP[$self_addr + 51] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 23:
      
      
      
      
      if (HEAP[$self_addr + 44] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      
      
      
      if (HEAP[$self_addr + 48] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 25:
      
      
      
      var $82 = HEAP[HEAP[$text] + 8];
      
      
      
      var $86 = HEAP[HEAP[$text] + 12];
      var $87 = _findchar($86, $82, 10);
      
      if ($87 != 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      $haslf = 1;
      __label__ = 28;
      break;
     case 27:
      
      
      if ($haslf != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 28:
      
      
      
      
      if (HEAP[$self_addr + 51] != 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 29:
      
      
      
      
      if (HEAP[$self_addr + 44] != 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 30:
      
      
      var $100 = HEAP[$self_addr + 44];
      var $101 = HEAP[$text];
      var $102 = __PyObject_CallMethod_SizeT($101, __str62438, __str27402, allocate([ __str25400, 0, 0, 0, $100, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $newtext = $102;
      var $103 = HEAP[$text];
      
      
      var $106 = HEAP[$103] - 1;
      var $107 = $103;
      HEAP[$107] = $106;
      
      
      
      if (HEAP[$103] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      
      
      
      
      var $115 = HEAP[HEAP[HEAP[$text] + 4] + 24];
      var $116 = HEAP[$text];
      FUNCTION_TABLE[$115]($116);
      __label__ = 32;
      break;
     case 32:
      
      
      if ($newtext == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      $0 = 0;
      __label__ = 76;
      break;
     case 34:
      
      HEAP[$text] = $newtext;
      __label__ = 35;
      break;
     case 35:
      
      
      
      
      if (HEAP[$self_addr + 48] != 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 36:
      
      
      if ($haslf != 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 37:
      
      
      
      var $129 = HEAP[HEAP[$text] + 8];
      
      
      
      var $133 = HEAP[HEAP[$text] + 12];
      var $134 = _findchar($133, $129, 13);
      
      if ($134 != 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      $needflush = 1;
      __label__ = 39;
      break;
     case 39:
      
      
      
      
      if (HEAP[$self_addr + 56] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      
      
      var $142 = HEAP[$self_addr + 56];
      var $143 = HEAP[$text];
      
      
      var $146 = FUNCTION_TABLE[$142]($self_addr, $143);
      $b = $146;
      
      
      HEAP[$self_addr + 60] = 0;
      __label__ = 42;
      break;
     case 41:
      var $149 = HEAP[$text];
      var $150 = HEAP[__PyIO_str_encode];
      
      
      var $153 = HEAP[$self_addr + 28];
      var $154 = _PyObject_CallMethodObjArgs($153, $150, allocate([ $149, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $b = $154;
      __label__ = 42;
      break;
     case 42:
      var $155 = HEAP[$text];
      
      
      var $158 = HEAP[$155] - 1;
      var $159 = $155;
      HEAP[$159] = $158;
      
      
      
      if (HEAP[$155] == 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      
      
      
      
      var $167 = HEAP[HEAP[HEAP[$text] + 4] + 24];
      var $168 = HEAP[$text];
      FUNCTION_TABLE[$167]($168);
      __label__ = 44;
      break;
     case 44:
      
      
      if ($b == 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 45:
      $0 = 0;
      __label__ = 76;
      break;
     case 46:
      
      
      
      
      if (HEAP[$self_addr + 72] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 47:
      var $175 = _PyList_New(0);
      
      
      HEAP[$self_addr + 72] = $175;
      
      
      
      
      if (HEAP[$self_addr + 72] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 48:
      
      
      
      var $185 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $185;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 49:
      
      
      
      
      var $196 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$196]($b);
      __label__ = 50;
      break;
     case 50:
      $0 = 0;
      __label__ = 76;
      break;
     case 51:
      
      
      HEAP[$self_addr + 76] = 0;
      __label__ = 52;
      break;
     case 52:
      
      
      var $202 = HEAP[$self_addr + 72];
      
      var $204 = _PyList_Append($202, $b);
      
      if ($204 < 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 53:
      
      
      
      var $209 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $209;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      
      
      
      var $220 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$220]($b);
      __label__ = 55;
      break;
     case 55:
      $0 = 0;
      __label__ = 76;
      break;
     case 56:
      
      
      
      
      
      
      
      var $229 = HEAP[$b + 8] + HEAP[$self_addr + 76];
      
      
      HEAP[$self_addr + 76] = $229;
      
      
      
      var $235 = HEAP[$b] - 1;
      
      
      HEAP[$b] = $235;
      
      
      
      
      if (HEAP[$b] == 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      
      
      
      
      var $246 = HEAP[HEAP[$b + 4] + 24];
      
      FUNCTION_TABLE[$246]($b);
      __label__ = 58;
      break;
     case 58:
      
      
      
      
      
      
      
      if (HEAP[$self_addr + 76] > HEAP[$self_addr + 16]) {
        __label__ = 60;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 59:
      
      
      if ($needflush != 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 60:
      
      var $258 = __textiowrapper_writeflush($self_addr);
      
      if ($258 < 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 61:
      $0 = 0;
      __label__ = 76;
      break;
     case 62:
      
      
      if ($needflush != 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 63:
      var $261 = HEAP[__PyIO_str_flush];
      
      
      var $264 = HEAP[$self_addr + 20];
      var $265 = _PyObject_CallMethodObjArgs($264, $261, allocate(4, "i8*", ALLOC_STACK));
      $ret = $265;
      
      
      if ($ret == 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 64:
      $0 = 0;
      __label__ = 76;
      break;
     case 65:
      
      
      
      var $271 = HEAP[$ret] - 1;
      
      
      HEAP[$ret] = $271;
      
      
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      
      
      
      
      var $282 = HEAP[HEAP[$ret + 4] + 24];
      
      FUNCTION_TABLE[$282]($ret);
      __label__ = 67;
      break;
     case 67:
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 68:
      
      
      
      $_py_tmp = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $296 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $296;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      
      
      
      
      var $307 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$307]($_py_tmp);
      __label__ = 70;
      break;
     case 70:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 71:
      
      
      var $315 = HEAP[$self_addr + 32];
      var $316 = __PyObject_CallMethod_SizeT($315, __str31406, 0, allocate(1, "i32", ALLOC_STACK));
      $ret = $316;
      
      
      if ($ret == 0) {
        __label__ = 72;
        break;
      } else {
        __label__ = 73;
        break;
      }
     case 72:
      $0 = 0;
      __label__ = 76;
      break;
     case 73:
      
      
      
      var $322 = HEAP[$ret] - 1;
      
      
      HEAP[$ret] = $322;
      
      
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 74:
      
      
      
      
      var $333 = HEAP[HEAP[$ret + 4] + 24];
      
      FUNCTION_TABLE[$333]($ret);
      __label__ = 75;
      break;
     case 75:
      
      var $336 = _PyLong_FromSsize_t($textlen);
      $0 = $336;
      __label__ = 76;
      break;
     case 76:
      
      $retval = $0;
      var $retval77 = $retval;
      STACKTOP = __stackBase__;
      return $retval77;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_set_decoded_chars($self, $chars) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $chars_addr;
      var $_py_tmp;
      $self_addr = $self;
      $chars_addr = $chars;
      
      
      
      
      if (HEAP[$self_addr + 64] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      $_py_tmp = HEAP[$self_addr + 64];
      
      
      HEAP[$self_addr + 64] = 0;
      
      
      
      var $12 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $12;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $23 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$23]($_py_tmp);
      __label__ = 3;
      break;
     case 3:
      
      
      
      HEAP[$self_addr + 64] = $chars_addr;
      
      
      HEAP[$self_addr + 68] = 0;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_get_decoded_chars($self, $n) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $n_addr;
      var $retval;
      var $0;
      var $chars;
      var $avail;
      $self_addr = $self;
      $n_addr = $n;
      
      
      
      
      if (HEAP[$self_addr + 64] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _PyUnicodeUCS2_FromStringAndSize(0, 0);
      $0 = $5;
      __label__ = 13;
      break;
     case 2:
      
      
      
      
      
      
      
      
      
      
      $avail = HEAP[HEAP[$self_addr + 64] + 8] - HEAP[$self_addr + 68];
      
      
      if ($avail < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str63439, __str15390, 1334, ___PRETTY_FUNCTION___10189);
      throw "Reached an unreachable!";
     case 4:
      
      
      if ($n_addr < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      if ($n_addr > $avail) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      $n_addr = $avail;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[$self_addr + 68] > 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      if ($n_addr < $avail) {
        __label__ = 9;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 9:
      
      
      
      
      
      
      
      
      
      var $40 = HEAP[HEAP[$self_addr + 64] + 12] + 2 * HEAP[$self_addr + 68];
      
      var $42 = _PyUnicodeUCS2_FromUnicode($40, $n_addr);
      $chars = $42;
      
      if ($42 == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      $0 = 0;
      __label__ = 13;
      break;
     case 11:
      
      
      
      $chars = HEAP[$self_addr + 64];
      
      
      
      var $50 = HEAP[$chars] + 1;
      
      
      HEAP[$chars] = $50;
      __label__ = 12;
      break;
     case 12:
      
      
      
      
      var $57 = $n_addr + HEAP[$self_addr + 68];
      
      
      HEAP[$self_addr + 68] = $57;
      
      $0 = $chars;
      __label__ = 13;
      break;
     case 13:
      
      $retval = $0;
      var $retval14 = $retval;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_read_chunk($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $iftmp_189;
      var $0;
      var $dec_buffer = __stackBase__;
      var $dec_flags = __stackBase__ + 4;
      var $input_chunk;
      var $decoded_chars;
      var $chunk_size;
      var $eof;
      var $state;
      var $next_input;
      var $_py_tmp;
      $self_addr = $self;
      HEAP[$dec_buffer] = 0;
      HEAP[$dec_flags] = 0;
      $input_chunk = 0;
      
      
      
      
      if (HEAP[$self_addr + 32] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_IOError];
      _PyErr_SetString($5, __str64440);
      $0 = -1;
      __label__ = 49;
      break;
     case 2:
      
      
      
      
      if (HEAP[$self_addr + 53] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 3:
      var $10 = HEAP[__PyIO_str_getstate];
      
      
      var $13 = HEAP[$self_addr + 32];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      $state = $14;
      
      
      if ($state == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = -1;
      __label__ = 49;
      break;
     case 5:
      
      var $18 = __PyArg_Parse_SizeT($state, __str65441, allocate([ $dec_buffer, 0, 0, 0, $dec_flags, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($18 < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      
      var $23 = HEAP[$state] - 1;
      
      
      HEAP[$state] = $23;
      
      
      
      
      if (HEAP[$state] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $34 = HEAP[HEAP[$state + 4] + 24];
      
      FUNCTION_TABLE[$34]($state);
      __label__ = 8;
      break;
     case 8:
      $0 = -1;
      __label__ = 49;
      break;
     case 9:
      
      
      
      var $39 = HEAP[HEAP[$dec_buffer]] + 1;
      var $40 = HEAP[$dec_buffer];
      HEAP[$40] = $39;
      
      
      
      var $44 = HEAP[HEAP[$dec_flags]] + 1;
      var $45 = HEAP[$dec_flags];
      HEAP[$45] = $44;
      
      
      
      var $49 = HEAP[$state] - 1;
      
      
      HEAP[$state] = $49;
      
      
      
      
      if (HEAP[$state] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $60 = HEAP[HEAP[$state + 4] + 24];
      
      FUNCTION_TABLE[$60]($state);
      __label__ = 11;
      break;
     case 11:
      
      
      var $64 = HEAP[$self_addr + 16];
      var $65 = _PyLong_FromSsize_t($64);
      $chunk_size = $65;
      
      if ($65 == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      var $67 = HEAP[__PyIO_str_read1];
      
      
      var $70 = HEAP[$self_addr + 20];
      
      var $72 = _PyObject_CallMethodObjArgs($70, $67, allocate([ $chunk_size, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $input_chunk = $72;
      
      
      
      var $76 = HEAP[$chunk_size] - 1;
      
      
      HEAP[$chunk_size] = $76;
      
      
      
      
      if (HEAP[$chunk_size] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $87 = HEAP[HEAP[$chunk_size + 4] + 24];
      
      FUNCTION_TABLE[$87]($chunk_size);
      __label__ = 14;
      break;
     case 14:
      
      
      if ($input_chunk == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$input_chunk + 4] + 84] & 134217728) == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      ___assert_fail(__str66442, __str15390, 1407, ___PRETTY_FUNCTION___10233);
      throw "Reached an unreachable!";
     case 17:
      
      var $99 = _PyString_Size($input_chunk);
      
      
      $eof = $99 == 0;
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr + 32] + 4] == _PyIncrementalNewlineDecoder_Type) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      var $110 = HEAP[$self_addr + 32];
      
      
      var $113 = __PyIncrementalNewlineDecoder_decode($110, $input_chunk, $eof);
      $decoded_chars = $113;
      __lastLabel__ = 18;
      __label__ = 23;
      break;
     case 19:
      
      
      if ($eof != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      $iftmp_189 = __Py_TrueStruct;
      __label__ = 22;
      break;
     case 21:
      $iftmp_189 = __Py_ZeroStruct;
      __label__ = 22;
      break;
     case 22:
      var $116 = HEAP[__PyIO_str_decode];
      
      
      var $119 = HEAP[$self_addr + 32];
      
      
      var $122 = _PyObject_CallMethodObjArgs($119, $116, allocate([ $input_chunk, 0, 0, 0, $iftmp_189, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $decoded_chars = $122;
      __lastLabel__ = 22;
      __label__ = 23;
      break;
     case 23:
      var $123 = __lastLabel__ == 22 ? $122 : $113;
      
      if ($123 == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      
      _textiowrapper_set_decoded_chars($self_addr, $decoded_chars);
      
      
      
      
      
      if (HEAP[$decoded_chars + 8] > 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      $eof = 0;
      __label__ = 26;
      break;
     case 26:
      
      
      
      
      if (HEAP[$self_addr + 53] != 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 27:
      var $136 = HEAP[$dec_buffer];
      
      var $138 = _PyNumber_Add($136, $input_chunk);
      $next_input = $138;
      
      
      if ($next_input == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 28:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$next_input + 4] + 84] & 134217728) == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      ___assert_fail(__str67443, __str15390, 1434, ___PRETTY_FUNCTION___10233);
      throw "Reached an unreachable!";
     case 30:
      var $148 = HEAP[$dec_buffer];
      
      
      var $151 = HEAP[$148] - 1;
      var $152 = $148;
      HEAP[$152] = $151;
      
      
      
      if (HEAP[$148] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      
      
      
      
      var $160 = HEAP[HEAP[HEAP[$dec_buffer] + 4] + 24];
      var $161 = HEAP[$dec_buffer];
      FUNCTION_TABLE[$160]($161);
      __label__ = 32;
      break;
     case 32:
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 33:
      
      
      
      $_py_tmp = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $174 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $174;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      
      
      
      
      var $185 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$185]($_py_tmp);
      __label__ = 35;
      break;
     case 35:
      var $187 = HEAP[$dec_flags];
      
      var $189 = __Py_BuildValue_SizeT(__str68444, allocate([ $187, 0, 0, 0, $next_input, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      
      
      HEAP[$self_addr + 80] = $189;
      __label__ = 36;
      break;
     case 36:
      
      
      
      var $195 = HEAP[$input_chunk] - 1;
      
      
      HEAP[$input_chunk] = $195;
      
      
      
      
      if (HEAP[$input_chunk] == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      
      
      
      
      var $206 = HEAP[HEAP[$input_chunk + 4] + 24];
      
      FUNCTION_TABLE[$206]($input_chunk);
      __label__ = 38;
      break;
     case 38:
      
      
      
      $0 = $eof == 0;
      __label__ = 49;
      break;
     case 39:
      
      
      if (HEAP[$dec_buffer] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      var $213 = HEAP[$dec_buffer];
      
      
      var $216 = HEAP[$213] - 1;
      var $217 = $213;
      HEAP[$217] = $216;
      
      
      
      if (HEAP[$213] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $225 = HEAP[HEAP[HEAP[$dec_buffer] + 4] + 24];
      var $226 = HEAP[$dec_buffer];
      FUNCTION_TABLE[$225]($226);
      __label__ = 42;
      break;
     case 42:
      
      
      if (HEAP[$dec_flags] != 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 43:
      var $229 = HEAP[$dec_flags];
      
      
      var $232 = HEAP[$229] - 1;
      var $233 = $229;
      HEAP[$233] = $232;
      
      
      
      if (HEAP[$229] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 44:
      
      
      
      
      var $241 = HEAP[HEAP[HEAP[$dec_flags] + 4] + 24];
      var $242 = HEAP[$dec_flags];
      FUNCTION_TABLE[$241]($242);
      __label__ = 45;
      break;
     case 45:
      
      
      if ($input_chunk != 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      
      
      
      var $248 = HEAP[$input_chunk] - 1;
      
      
      HEAP[$input_chunk] = $248;
      
      
      
      
      if (HEAP[$input_chunk] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      
      
      
      
      var $259 = HEAP[HEAP[$input_chunk + 4] + 24];
      
      FUNCTION_TABLE[$259]($input_chunk);
      __label__ = 48;
      break;
     case 48:
      $0 = -1;
      __label__ = 49;
      break;
     case 49:
      
      $retval = $0;
      var $retval48 = $retval;
      STACKTOP = __stackBase__;
      return $retval48;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $n = __stackBase__;
      var $result;
      var $chunks;
      var $r;
      var $_res;
      var $bytes;
      var $decoded;
      var $final;
      var $_py_tmp;
      var $res;
      var $remaining;
      var $_py_tmp59;
      var $_py_tmp64;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$n] = -1;
      $result = 0;
      $chunks = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 72;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str21, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $n, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 72;
      break;
     case 7:
      
      
      
      
      
      var $18 = $self_addr;
      if (HEAP[$self_addr + 4] == _PyTextIOWrapper_Type) {
        __label__ = 8;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 8:
      
      
      
      var $22 = $self_addr;
      if (HEAP[$18 + 84] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      var $24 = HEAP[$22 + 84];
      var $25 = __PyFileIO_closed($24);
      $r = $25;
      __lastLabel__ = 9;
      __label__ = 16;
      break;
     case 10:
      var $26 = _textiowrapper_closed_get($22, 0);
      $_res = $26;
      
      
      if ($_res == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      $0 = 0;
      __label__ = 72;
      break;
     case 12:
      
      var $30 = _PyObject_IsTrue($_res);
      $r = $30;
      
      
      
      var $34 = HEAP[$_res] - 1;
      
      
      HEAP[$_res] = $34;
      
      
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $45 = HEAP[HEAP[$_res + 4] + 24];
      
      FUNCTION_TABLE[$45]($_res);
      __label__ = 14;
      break;
     case 14:
      var $47 = $r;
      
      if ($47 < 0) {
        __lastLabel__ = 14;
        __label__ = 15;
        break;
      } else {
        __lastLabel__ = 14;
        __label__ = 16;
        break;
      }
     case 15:
      $0 = 0;
      __label__ = 72;
      break;
     case 16:
      var $49 = __lastLabel__ == 14 ? $47 : $25;
      
      if ($49 > 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      var $51 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($51, __str60436);
      $0 = 0;
      __label__ = 72;
      break;
     case 18:
      
      var $53 = __PyIOBase_check_closed($18, __Py_TrueStruct);
      
      if ($53 == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      $0 = 0;
      __label__ = 72;
      break;
     case 20:
      
      
      
      
      if (HEAP[$self_addr + 32] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      var $59 = HEAP[_PyExc_IOError];
      _PyErr_SetString($59, __str64440);
      $0 = 0;
      __label__ = 72;
      break;
     case 22:
      
      var $61 = __textiowrapper_writeflush($self_addr);
      
      if ($61 < 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      $0 = 0;
      __label__ = 72;
      break;
     case 24:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 25:
      
      
      var $67 = HEAP[$self_addr + 20];
      var $68 = __PyObject_CallMethod_SizeT($67, __str1375, 0, allocate(1, "i32", ALLOC_STACK));
      $bytes = $68;
      
      
      if ($bytes == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      var $71 = HEAP[__PyIO_str_decode];
      
      
      var $74 = HEAP[$self_addr + 32];
      
      var $76 = _PyObject_CallMethodObjArgs($74, $71, allocate([ $bytes, 0, 0, 0, __Py_TrueStruct, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $decoded = $76;
      
      
      
      var $80 = HEAP[$bytes] - 1;
      
      
      HEAP[$bytes] = $80;
      
      
      
      
      if (HEAP[$bytes] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      
      
      var $91 = HEAP[HEAP[$bytes + 4] + 24];
      
      FUNCTION_TABLE[$91]($bytes);
      __label__ = 28;
      break;
     case 28:
      
      
      if ($decoded == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 29:
      
      var $96 = _textiowrapper_get_decoded_chars($self_addr, -1);
      $result = $96;
      
      
      if ($result == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 30:
      
      
      
      var $102 = HEAP[$decoded] - 1;
      
      
      HEAP[$decoded] = $102;
      
      
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      
      
      
      
      var $113 = HEAP[HEAP[$decoded + 4] + 24];
      
      FUNCTION_TABLE[$113]($decoded);
      __label__ = 32;
      break;
     case 32:
      $0 = 0;
      __label__ = 72;
      break;
     case 33:
      
      
      var $117 = _PyUnicodeUCS2_Concat($result, $decoded);
      $final = $117;
      
      
      
      var $121 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $121;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      
      
      
      
      var $132 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$132]($result);
      __label__ = 35;
      break;
     case 35:
      
      
      
      var $137 = HEAP[$decoded] - 1;
      
      
      HEAP[$decoded] = $137;
      
      
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 36:
      
      
      
      
      var $148 = HEAP[HEAP[$decoded + 4] + 24];
      
      FUNCTION_TABLE[$148]($decoded);
      __label__ = 37;
      break;
     case 37:
      
      
      if ($final == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 38:
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 39:
      
      
      
      $_py_tmp = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $164 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $164;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      
      
      
      
      var $175 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$175]($_py_tmp);
      __label__ = 41;
      break;
     case 41:
      
      $0 = $final;
      __label__ = 72;
      break;
     case 42:
      $res = 1;
      
      $remaining = HEAP[$n];
      var $179 = HEAP[$n];
      
      var $181 = _textiowrapper_get_decoded_chars($self_addr, $179);
      $result = $181;
      
      
      if ($result == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 43:
      
      
      
      
      
      var $189 = $remaining - HEAP[$result + 8];
      $remaining = $189;
      __lastLabel__ = 43;
      __label__ = 53;
      break;
     case 44:
      
      var $191 = _textiowrapper_read_chunk($self_addr);
      $res = $191;
      
      
      if ($res < 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      
      if ($res == 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      if ($chunks == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      var $198 = _PyList_New(0);
      $chunks = $198;
      
      
      if ($chunks == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 48:
      
      
      var $203 = _PyList_Append($chunks, $result);
      
      if ($203 < 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 49:
      
      
      
      var $208 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $208;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      
      
      
      
      var $219 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$219]($result);
      __label__ = 51;
      break;
     case 51:
      
      
      var $223 = _textiowrapper_get_decoded_chars($self_addr, $remaining);
      $result = $223;
      
      if ($223 == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 52:
      
      
      
      
      
      var $230 = $remaining - HEAP[$result + 8];
      $remaining = $230;
      __lastLabel__ = 52;
      __label__ = 53;
      break;
     case 53:
      var $231 = __lastLabel__ == 52 ? $230 : $189;
      
      if ($231 > 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 54:
      
      
      if ($chunks != 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 55:
      
      
      if ($result != 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 56:
      
      
      var $239 = _PyList_Append($chunks, $result);
      
      if ($239 < 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 57:
      
      
      if ($result != 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 58:
      
      $_py_tmp59 = $result;
      $result = 0;
      
      
      
      var $246 = HEAP[$_py_tmp59] - 1;
      
      
      HEAP[$_py_tmp59] = $246;
      
      
      
      
      if (HEAP[$_py_tmp59] == 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 59:
      
      
      
      
      var $257 = HEAP[HEAP[$_py_tmp59 + 4] + 24];
      
      FUNCTION_TABLE[$257]($_py_tmp59);
      __label__ = 60;
      break;
     case 60:
      var $259 = HEAP[__PyIO_empty_str];
      
      var $261 = _PyUnicodeUCS2_Join($259, $chunks);
      $result = $261;
      
      if ($261 == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 61:
      
      
      if ($chunks != 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 62:
      
      $_py_tmp64 = $chunks;
      $chunks = 0;
      
      
      
      var $269 = HEAP[$_py_tmp64] - 1;
      
      
      HEAP[$_py_tmp64] = $269;
      
      
      
      
      if (HEAP[$_py_tmp64] == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 63:
      
      
      
      
      var $280 = HEAP[HEAP[$_py_tmp64 + 4] + 24];
      
      FUNCTION_TABLE[$280]($_py_tmp64);
      __label__ = 64;
      break;
     case 64:
      
      $0 = $result;
      __label__ = 72;
      break;
     case 65:
      
      
      if ($result != 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 66:
      
      
      
      var $287 = HEAP[$result] - 1;
      
      
      HEAP[$result] = $287;
      
      
      
      
      if (HEAP[$result] == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      
      
      
      
      var $298 = HEAP[HEAP[$result + 4] + 24];
      
      FUNCTION_TABLE[$298]($result);
      __label__ = 68;
      break;
     case 68:
      
      
      if ($chunks != 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 69:
      
      
      
      var $305 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $305;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 70:
      
      
      
      
      var $316 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$316]($chunks);
      __label__ = 71;
      break;
     case 71:
      $0 = 0;
      __label__ = 72;
      break;
     case 72:
      
      $retval = $0;
      var $retval74 = $retval;
      STACKTOP = __stackBase__;
      return $retval74;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _find_control_char($start, $end, $ch) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $start_addr;
      var $end_addr;
      var $ch_addr;
      var $retval;
      var $0;
      var $s;
      $start_addr = $start;
      $end_addr = $end;
      $ch_addr = $ch;
      
      $s = $start_addr;
      __label__ = 2;
      break;
     case 1:
      
      $s = $7 + 2;
      __label__ = 2;
      break;
     case 2:
      
      
      
      
      var $7 = $s;
      if (HEAP[$s] > $ch_addr) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      var $11 = $s;
      if (HEAP[$7] == $ch_addr) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = $11;
      __label__ = 8;
      break;
     case 5:
      
      
      if ($11 == $end_addr) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 8;
      break;
     case 7:
      
      var $15 = $s + 2;
      $s = $15;
      __label__ = 2;
      break;
     case 8:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIO_find_line_ending($translated, $universal, $readnl, $start, $end, $consumed) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $translated_addr;
      var $universal_addr;
      var $readnl_addr;
      var $start_addr;
      var $end_addr;
      var $consumed_addr;
      var $retval;
      var $0;
      var $len;
      var $pos;
      var $s;
      var $ch;
      var $readnl_len;
      var $nl;
      var $pos19;
      var $s23;
      var $e;
      var $pos24;
      var $i;
      var $pos28;
      $translated_addr = $translated;
      $universal_addr = $universal;
      $readnl_addr = $readnl;
      $start_addr = $start;
      $end_addr = $end;
      $consumed_addr = $consumed;
      
      
      
      
      
      
      $len = ($end_addr - $start_addr) / 2 | 0;
      
      
      if ($translated_addr != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      
      
      var $11 = _find_control_char($start_addr, $end_addr, 10);
      $pos = $11;
      
      
      if ($pos != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      
      
      
      $0 = (($pos - $start_addr) / 2 | 0) + 1;
      __label__ = 36;
      break;
     case 3:
      
      
      HEAP[$consumed_addr] = $len;
      $0 = -1;
      __label__ = 36;
      break;
     case 4:
      
      
      if ($universal_addr != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 5:
      
      $s = $start_addr;
      __label__ = 7;
      break;
     case 6:
      
      $s = $30 + 2;
      __label__ = 7;
      break;
     case 7:
      
      
      
      var $30 = $s;
      if (HEAP[$s] > 13) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      if ($30 >= $end_addr) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      HEAP[$consumed_addr] = $len;
      $0 = -1;
      __label__ = 36;
      break;
     case 10:
      
      
      $ch = HEAP[$s];
      
      var $38 = $s + 2;
      $s = $38;
      
      
      if ($ch == 10) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      
      
      $0 = ($s - $start_addr) / 2 | 0;
      __label__ = 36;
      break;
     case 12:
      
      
      if ($ch == 13) {
        __label__ = 13;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 13:
      
      
      
      
      
      
      
      
      var $57 = ($s - $start_addr) / 2 | 0;
      if (HEAP[$s] == 10) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      $0 = $57 + 1;
      __label__ = 36;
      break;
     case 15:
      $0 = $57;
      __label__ = 36;
      break;
     case 16:
      
      
      
      
      $readnl_len = HEAP[$readnl_addr + 8];
      
      
      
      
      $nl = $readnl_addr + 20;
      
      
      if ($readnl_len == 1) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      
      
      
      
      
      
      var $75 = HEAP[$nl] & 65535;
      var $76 = _find_control_char($start_addr, $end_addr, $75);
      $pos19 = $76;
      
      
      if ($pos19 != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      
      
      
      $0 = (($pos19 - $start_addr) / 2 | 0) + 1;
      __label__ = 36;
      break;
     case 19:
      
      
      HEAP[$consumed_addr] = $len;
      $0 = -1;
      __label__ = 36;
      break;
     case 20:
      
      $s23 = $start_addr;
      
      
      
      
      
      $e = $end_addr + 2 * (0 - $readnl_len) + 2;
      
      
      
      if ($e < $s23) {
        __label__ = 21;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 21:
      
      $e = $s23;
      __label__ = 31;
      break;
     case 22:
      
      
      
      
      
      
      var $104 = HEAP[$nl] & 65535;
      var $105 = _find_control_char($s23, $end_addr, $104);
      $pos28 = $105;
      
      
      if ($pos28 == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 23:
      
      
      
      if ($pos28 >= $e) {
        __label__ = 32;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      $i = 1;
      __label__ = 27;
      break;
     case 25:
      
      
      
      
      
      
      
      
      
      
      if (HEAP[$pos28 + 2 * $i] != HEAP[$nl + $i]) {
        __label__ = 28;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      var $122 = $i + 1;
      $i = $122;
      __label__ = 27;
      break;
     case 27:
      
      
      
      if ($i < $readnl_len) {
        __label__ = 25;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 28:
      
      
      
      var $129 = $pos28;
      if ($i == $readnl_len) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      
      
      
      $0 = $readnl_len + (($129 - $start_addr) / 2 | 0);
      __label__ = 36;
      break;
     case 30:
      
      $s23 = $129 + 2;
      __label__ = 31;
      break;
     case 31:
      
      
      
      if ($s23 < $e) {
        __label__ = 22;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 32:
      
      
      
      
      
      
      var $147 = HEAP[$nl] & 65535;
      var $148 = _find_control_char($e, $end_addr, $147);
      $pos24 = $148;
      
      if ($148 == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      
      
      HEAP[$consumed_addr] = $len;
      __label__ = 35;
      break;
     case 34:
      
      
      
      
      
      
      
      HEAP[$consumed_addr] = ($pos24 - $start_addr) / 2 | 0;
      __label__ = 35;
      break;
     case 35:
      $0 = -1;
      __label__ = 36;
      break;
     case 36:
      
      $retval = $0;
      var $retval43 = $retval;
      return $retval43;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_readline($self, $limit) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    _memset(__stackBase__, 0, 8);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $limit_addr;
      var $retval;
      var $0;
      var $line = __stackBase__;
      var $chunks;
      var $remaining;
      var $start;
      var $endpos;
      var $chunked;
      var $offset_to_buffer;
      var $res;
      var $r;
      var $_res;
      var $ptr;
      var $line_len;
      var $consumed = __stackBase__ + 4;
      var $_py_tmp;
      var $_py_tmp32;
      var $s;
      var $_py_tmp57;
      var $s68;
      var $_py_tmp70;
      var $_py_tmp80;
      var $_py_tmp87;
      $self_addr = $self;
      $limit_addr = $limit;
      HEAP[$line] = 0;
      $chunks = 0;
      $remaining = 0;
      
      
      
      
      
      var $6 = $self_addr;
      if (HEAP[$self_addr + 4] == _PyTextIOWrapper_Type) {
        __label__ = 1;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 1:
      
      
      
      var $10 = $self_addr;
      if (HEAP[$6 + 84] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      var $12 = HEAP[$10 + 84];
      var $13 = __PyFileIO_closed($12);
      $r = $13;
      __lastLabel__ = 2;
      __label__ = 9;
      break;
     case 3:
      var $14 = _textiowrapper_closed_get($10, 0);
      $_res = $14;
      
      
      if ($_res == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      $0 = 0;
      __label__ = 97;
      break;
     case 5:
      
      var $18 = _PyObject_IsTrue($_res);
      $r = $18;
      
      
      
      var $22 = HEAP[$_res] - 1;
      
      
      HEAP[$_res] = $22;
      
      
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $33 = HEAP[HEAP[$_res + 4] + 24];
      
      FUNCTION_TABLE[$33]($_res);
      __label__ = 7;
      break;
     case 7:
      var $35 = $r;
      
      if ($35 < 0) {
        __lastLabel__ = 7;
        __label__ = 8;
        break;
      } else {
        __lastLabel__ = 7;
        __label__ = 9;
        break;
      }
     case 8:
      $0 = 0;
      __label__ = 97;
      break;
     case 9:
      var $37 = __lastLabel__ == 7 ? $35 : $13;
      
      if ($37 > 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 10:
      var $39 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($39, __str60436);
      $0 = 0;
      __label__ = 97;
      break;
     case 11:
      
      var $41 = __PyIOBase_check_closed($6, __Py_TrueStruct);
      
      if ($41 == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      $0 = 0;
      __label__ = 97;
      break;
     case 13:
      
      var $44 = __textiowrapper_writeflush($self_addr);
      
      if ($44 < 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      $0 = 0;
      __label__ = 97;
      break;
     case 15:
      $chunked = 0;
      __label__ = 16;
      break;
     case 16:
      HEAP[$consumed] = 0;
      $res = 1;
      __label__ = 19;
      break;
     case 17:
      
      var $47 = _textiowrapper_read_chunk($self_addr);
      $res = $47;
      
      if ($47 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      if ($res == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      
      if (HEAP[$self_addr + 64] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 20:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr + 64] + 8] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      
      if ($res == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 22:
      
      _textiowrapper_set_decoded_chars($self_addr, 0);
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 23:
      
      
      
      $_py_tmp = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $76 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $76;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      
      
      var $87 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$87]($_py_tmp);
      __label__ = 25;
      break;
     case 25:
      $offset_to_buffer = 0;
      
      $endpos = $offset_to_buffer;
      
      $start = $endpos;
      __label__ = 56;
      break;
     case 26:
      
      
      var $93 = $self_addr;
      if ($remaining == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      var $95 = HEAP[$93 + 64];
      HEAP[$line] = $95;
      
      
      
      $start = HEAP[$self_addr + 68];
      $offset_to_buffer = 0;
      
      
      
      var $102 = HEAP[HEAP[$line]] + 1;
      var $103 = HEAP[$line];
      HEAP[$103] = $102;
      __label__ = 34;
      break;
     case 28:
      
      
      
      if (HEAP[$93 + 68] != 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      ___assert_fail(__str70446, __str15390, 1691, ___PRETTY_FUNCTION___10735);
      throw "Reached an unreachable!";
     case 30:
      
      
      var $109 = HEAP[$self_addr + 64];
      
      var $111 = _PyUnicodeUCS2_Concat($remaining, $109);
      HEAP[$line] = $111;
      $start = 0;
      
      
      
      
      $offset_to_buffer = HEAP[$remaining + 8];
      
      
      if ($remaining != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      $_py_tmp32 = $remaining;
      $remaining = 0;
      
      
      
      var $122 = HEAP[$_py_tmp32] - 1;
      
      
      HEAP[$_py_tmp32] = $122;
      
      
      
      
      if (HEAP[$_py_tmp32] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $133 = HEAP[HEAP[$_py_tmp32 + 4] + 24];
      
      FUNCTION_TABLE[$133]($_py_tmp32);
      __label__ = 33;
      break;
     case 33:
      
      
      if (HEAP[$line] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 34:
      
      
      
      
      $ptr = HEAP[HEAP[$line] + 12];
      
      
      
      
      $line_len = HEAP[HEAP[$line] + 8];
      
      
      
      
      
      
      
      
      var $153 = HEAP[$self_addr + 36];
      
      
      
      var $157 = HEAP[$self_addr + 49];
      
      
      
      var $161 = HEAP[$self_addr + 50];
      var $162 = __PyIO_find_line_ending($161, $157, $153, $ptr + 2 * $start, $ptr + 2 * $line_len, $consumed);
      $endpos = $162;
      
      if ($162 >= 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 35:
      
      
      var $166 = $start + $endpos;
      $endpos = $166;
      
      
      if ($limit_addr >= 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 36:
      
      
      
      
      
      
      
      
      if (0 - $start + $endpos + $chunked >= $limit_addr) {
        __label__ = 37;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 37:
      
      
      
      
      
      
      $endpos = $limit_addr + $start + (0 - $chunked);
      __label__ = 56;
      break;
     case 38:
      
      
      
      $endpos = $start + HEAP[$consumed];
      
      
      if ($limit_addr >= 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 39:
      
      
      
      
      
      
      
      
      if (0 - $start + $endpos + $chunked >= $limit_addr) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      
      
      
      
      
      
      $endpos = $limit_addr + $start + (0 - $chunked);
      __label__ = 56;
      break;
     case 41:
      
      
      
      if ($endpos > $start) {
        __label__ = 42;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 42:
      
      
      if ($chunks == 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      var $203 = _PyList_New(0);
      $chunks = $203;
      
      
      if ($chunks == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      
      
      
      
      
      var $212 = _PyUnicodeUCS2_FromUnicode($ptr + 2 * $start, $endpos - $start);
      $s = $212;
      
      if ($212 == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      
      var $216 = _PyList_Append($chunks, $s);
      
      var $218 = $s;
      if ($216 < 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      
      
      var $221 = HEAP[$218] - 1;
      
      
      HEAP[$s] = $221;
      
      
      
      
      if (HEAP[$s] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 47:
      
      
      
      
      var $232 = HEAP[HEAP[$s + 4] + 24];
      
      FUNCTION_TABLE[$232]($s);
      __label__ = 87;
      break;
     case 48:
      
      
      
      
      var $238 = $chunked + HEAP[$218 + 8];
      $chunked = $238;
      
      
      
      var $242 = HEAP[$s] - 1;
      
      
      HEAP[$s] = $242;
      
      
      
      
      if (HEAP[$s] == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 49:
      
      
      
      
      var $253 = HEAP[HEAP[$s + 4] + 24];
      
      FUNCTION_TABLE[$253]($s);
      __label__ = 50;
      break;
     case 50:
      
      
      
      if ($endpos < $line_len) {
        __label__ = 51;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 51:
      
      
      
      
      
      
      var $264 = _PyUnicodeUCS2_FromUnicode($ptr + 2 * $endpos, $line_len - $endpos);
      $remaining = $264;
      
      
      if ($remaining == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 52:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 53:
      
      $_py_tmp57 = HEAP[$line];
      HEAP[$line] = 0;
      
      
      
      var $273 = HEAP[$_py_tmp57] - 1;
      
      
      HEAP[$_py_tmp57] = $273;
      
      
      
      
      if (HEAP[$_py_tmp57] == 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      
      
      
      var $284 = HEAP[HEAP[$_py_tmp57 + 4] + 24];
      
      FUNCTION_TABLE[$284]($_py_tmp57);
      __label__ = 55;
      break;
     case 55:
      
      _textiowrapper_set_decoded_chars($self_addr, 0);
      __label__ = 16;
      break;
     case 56:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 57:
      
      
      
      
      
      HEAP[$self_addr + 68] = $endpos - $offset_to_buffer;
      
      
      if ($start > 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      
      
      
      
      
      if (HEAP[HEAP[$line] + 8] > $endpos) {
        __label__ = 59;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 59:
      
      
      if ($start != 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 60:
      
      
      
      
      if (HEAP[HEAP[$line]] != 1) {
        __label__ = 62;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 61:
      
      var $308 = _PyUnicodeUCS2_Resize($line, $endpos);
      
      if ($308 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 62:
      
      
      
      
      
      
      
      
      var $318 = HEAP[HEAP[$line] + 12] + 2 * $start;
      var $319 = _PyUnicodeUCS2_FromUnicode($318, $endpos - $start);
      $s68 = $319;
      
      
      if (HEAP[$line] != 0) {
        __lastLabel__ = 62;
        __label__ = 63;
        break;
      } else {
        __lastLabel__ = 62;
        __label__ = 66;
        break;
      }
     case 63:
      
      $_py_tmp70 = HEAP[$line];
      HEAP[$line] = 0;
      
      
      
      var $326 = HEAP[$_py_tmp70] - 1;
      
      
      HEAP[$_py_tmp70] = $326;
      
      
      
      
      if (HEAP[$_py_tmp70] == 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 64:
      
      
      
      
      var $337 = HEAP[HEAP[$_py_tmp70 + 4] + 24];
      
      FUNCTION_TABLE[$337]($_py_tmp70);
      __label__ = 65;
      break;
     case 65:
      var $_pr2 = $s68;
      __lastLabel__ = 65;
      __label__ = 66;
      break;
     case 66:
      var $339 = __lastLabel__ == 65 ? $_pr2 : $319;
      
      if ($339 == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 67:
      
      HEAP[$line] = $s68;
      __label__ = 68;
      break;
     case 68:
      
      
      if ($remaining != 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 69:
      
      
      if ($chunks == 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 70:
      var $346 = _PyList_New(0);
      $chunks = $346;
      
      
      if ($chunks == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 71:
      
      
      var $351 = _PyList_Append($chunks, $remaining);
      
      if ($351 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 72:
      
      
      if ($remaining != 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 73:
      
      $_py_tmp80 = $remaining;
      $remaining = 0;
      
      
      
      var $359 = HEAP[$_py_tmp80] - 1;
      
      
      HEAP[$_py_tmp80] = $359;
      
      
      
      
      if (HEAP[$_py_tmp80] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 74:
      
      
      
      
      var $370 = HEAP[HEAP[$_py_tmp80 + 4] + 24];
      
      FUNCTION_TABLE[$370]($_py_tmp80);
      __label__ = 75;
      break;
     case 75:
      
      
      if ($chunks != 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 76:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 77;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 77:
      var $376 = HEAP[$line];
      
      var $378 = _PyList_Append($chunks, $376);
      
      if ($378 < 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 78:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 79;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 79:
      
      $_py_tmp87 = HEAP[$line];
      HEAP[$line] = 0;
      
      
      
      var $385 = HEAP[$_py_tmp87] - 1;
      
      
      HEAP[$_py_tmp87] = $385;
      
      
      
      
      if (HEAP[$_py_tmp87] == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 80:
      
      
      
      
      var $396 = HEAP[HEAP[$_py_tmp87 + 4] + 24];
      
      FUNCTION_TABLE[$396]($_py_tmp87);
      __label__ = 81;
      break;
     case 81:
      var $398 = HEAP[__PyIO_empty_str];
      
      var $400 = _PyUnicodeUCS2_Join($398, $chunks);
      HEAP[$line] = $400;
      
      if ($400 == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 82;
        break;
      }
     case 82:
      
      
      
      var $405 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $405;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 83;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 83:
      
      
      
      
      var $416 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$416]($chunks);
      __label__ = 84;
      break;
     case 84:
      
      
      if (HEAP[$line] == 0) {
        __label__ = 85;
        break;
      } else {
        __label__ = 86;
        break;
      }
     case 85:
      var $420 = _PyUnicodeUCS2_FromStringAndSize(0, 0);
      HEAP[$line] = $420;
      __label__ = 86;
      break;
     case 86:
      
      $0 = HEAP[$line];
      __label__ = 97;
      break;
     case 87:
      
      
      if ($chunks != 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 88:
      
      
      
      var $426 = HEAP[$chunks] - 1;
      
      
      HEAP[$chunks] = $426;
      
      
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 89;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 89:
      
      
      
      
      var $437 = HEAP[HEAP[$chunks + 4] + 24];
      
      FUNCTION_TABLE[$437]($chunks);
      __label__ = 90;
      break;
     case 90:
      
      
      if ($remaining != 0) {
        __label__ = 91;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 91:
      
      
      
      var $444 = HEAP[$remaining] - 1;
      
      
      HEAP[$remaining] = $444;
      
      
      
      
      if (HEAP[$remaining] == 0) {
        __label__ = 92;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 92:
      
      
      
      
      var $455 = HEAP[HEAP[$remaining + 4] + 24];
      
      FUNCTION_TABLE[$455]($remaining);
      __label__ = 93;
      break;
     case 93:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 94;
        break;
      } else {
        __label__ = 96;
        break;
      }
     case 94:
      var $459 = HEAP[$line];
      
      
      var $462 = HEAP[$459] - 1;
      var $463 = $459;
      HEAP[$463] = $462;
      
      
      
      if (HEAP[$459] == 0) {
        __label__ = 95;
        break;
      } else {
        __label__ = 96;
        break;
      }
     case 95:
      
      
      
      
      var $471 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $472 = HEAP[$line];
      FUNCTION_TABLE[$471]($472);
      __label__ = 96;
      break;
     case 96:
      $0 = 0;
      __label__ = 97;
      break;
     case 97:
      
      $retval = $0;
      var $retval105 = $retval;
      STACKTOP = __stackBase__;
      return $retval105;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $limitobj = __stackBase__;
      var $limit;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$limitobj] = 0;
      $limit = -1;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 14;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str71447, allocate([ $limitobj, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 14;
      break;
     case 7:
      
      
      if (HEAP[$limitobj] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 8:
      var $15 = HEAP[$limitobj];
      var $16 = _PyNumber_Check($15);
      
      if ($16 == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $22 = HEAP[HEAP[HEAP[$limitobj] + 4] + 12];
      var $23 = HEAP[_PyExc_TypeError];
      var $24 = _PyErr_Format($23, __str72448, allocate([ $22, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = 0;
      __label__ = 14;
      break;
     case 10:
      var $25 = HEAP[_PyExc_OverflowError];
      var $26 = HEAP[$limitobj];
      var $27 = _PyNumber_AsSsize_t($26, $25);
      $limit = $27;
      
      var $29 = $limit == -1;
      if ($29) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      var $30 = _PyErr_Occurred();
      
      if ($30 != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      $0 = 0;
      __label__ = 14;
      break;
     case 13:
      
      
      var $34 = __textiowrapper_readline($self_addr, $limit);
      $0 = $34;
      __label__ = 14;
      break;
     case 14:
      
      $retval = $0;
      var $retval14 = $retval;
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_parse_cookie($cookie, $cookieObj) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 21;
    _memset(__stackBase__, 0, 21);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $cookie_addr;
      var $cookieObj_addr;
      var $retval;
      var $0;
      var $buffer = __stackBase__;
      var $cookieLong;
      $cookie_addr = $cookie;
      $cookieObj_addr = $cookieObj;
      
      var $2 = _PyNumber_Long($cookieObj_addr);
      
      $cookieLong = $2;
      
      
      if ($cookieLong == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      $0 = -1;
      __label__ = 9;
      break;
     case 2:
      
      var $buffer2 = $buffer;
      var $7 = __PyLong_AsByteArray($cookieLong, $buffer2, 21, 1, 0);
      var $8 = $7 < 0;
      
      
      
      
      var $13 = HEAP[$cookieLong] - 1;
      
      HEAP[$cookieLong] = $13;
      
      
      var $17 = HEAP[$cookieLong] == 0;
      if ($8) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      if ($17) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      
      var $23 = HEAP[HEAP[$cookieLong + 4] + 24];
      
      
      FUNCTION_TABLE[$23]($cookieLong);
      __label__ = 5;
      break;
     case 5:
      $0 = -1;
      __label__ = 9;
      break;
     case 6:
      if ($17) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $31 = HEAP[HEAP[$cookieLong + 4] + 24];
      
      
      FUNCTION_TABLE[$31]($cookieLong);
      __label__ = 8;
      break;
     case 8:
      
      
      
      var $36 = $buffer;
      
      _llvm_memcpy_p0i8_p0i8_i32($cookie_addr, $36, 8, 1, 0);
      
      
      
      var $40 = $buffer + 8;
      
      _llvm_memcpy_p0i8_p0i8_i32($cookie_addr + 8, $40, 4, 1, 0);
      
      
      
      var $44 = $buffer + 12;
      
      _llvm_memcpy_p0i8_p0i8_i32($cookie_addr + 12, $44, 4, 1, 0);
      
      
      
      var $48 = $buffer + 16;
      
      _llvm_memcpy_p0i8_p0i8_i32($cookie_addr + 16, $48, 4, 1, 0);
      
      
      
      var $52 = $buffer + 20;
      _llvm_memcpy_p0i8_p0i8_i32($cookie_addr + 20, $52, 1, 1, 0);
      $0 = 0;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval15 = $retval;
      STACKTOP = __stackBase__;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_build_cookie($cookie) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 21;
    _memset(__stackBase__, 0, 21);
    
    var $cookie_addr;
    var $retval;
    var $0;
    var $buffer = __stackBase__;
    $cookie_addr = $cookie;
    
    
    
    var $3 = $buffer;
    
    _llvm_memcpy_p0i8_p0i8_i32($3, $cookie_addr, 8, 1, 0);
    
    
    
    var $7 = $buffer + 8;
    
    _llvm_memcpy_p0i8_p0i8_i32($7, $cookie_addr + 8, 4, 1, 0);
    
    
    
    var $11 = $buffer + 12;
    
    _llvm_memcpy_p0i8_p0i8_i32($11, $cookie_addr + 12, 4, 1, 0);
    
    
    
    var $15 = $buffer + 16;
    
    _llvm_memcpy_p0i8_p0i8_i32($15, $cookie_addr + 16, 4, 1, 0);
    
    
    
    var $19 = $buffer + 20;
    _llvm_memcpy_p0i8_p0i8_i32($19, $cookie_addr + 20, 1, 1, 0);
    var $buffer6 = $buffer;
    var $20 = __PyLong_FromByteArray($buffer6, 21, 1, 0);
    $0 = $20;
    
    $retval = $0;
    var $retval7 = $retval;
    STACKTOP = __stackBase__;
    return $retval7;
  }
  function __textiowrapper_decoder_setstate($self, $cookie) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $cookie_addr;
      var $retval;
      var $0;
      var $res;
      $self_addr = $self;
      $cookie_addr = $cookie;
      
      
      
      
      if (HEAP[$cookie_addr] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$cookie_addr + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      var $9 = HEAP[__PyIO_str_reset];
      
      
      var $12 = HEAP[$self_addr + 32];
      var $13 = _PyObject_CallMethodObjArgs($12, $9, allocate(4, "i8*", ALLOC_STACK));
      $res = $13;
      __lastLabel__ = 2;
      __label__ = 4;
      break;
     case 3:
      
      
      var $16 = HEAP[$cookie_addr + 8];
      
      
      var $19 = HEAP[$self_addr + 32];
      var $20 = __PyObject_CallMethod_SizeT($19, __str22397, __str73449, allocate([ __str20395, 0, 0, 0, $16, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $res = $20;
      __lastLabel__ = 3;
      __label__ = 4;
      break;
     case 4:
      var $21 = __lastLabel__ == 3 ? $20 : $13;
      
      if ($21 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = -1;
      __label__ = 9;
      break;
     case 6:
      
      
      
      var $26 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $26;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $37 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$37]($res);
      __label__ = 8;
      break;
     case 8:
      $0 = 0;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_encoder_setstate($self, $cookie) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $cookie_addr;
      var $retval;
      var $0;
      var $res;
      $self_addr = $self;
      $cookie_addr = $cookie;
      
      
      
      
      if (HEAP[$cookie_addr] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[$cookie_addr + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      var $9 = HEAP[__PyIO_str_reset];
      
      
      var $12 = HEAP[$self_addr + 28];
      var $13 = _PyObject_CallMethodObjArgs($12, $9, allocate(4, "i8*", ALLOC_STACK));
      $res = $13;
      
      
      HEAP[$self_addr + 60] = 1;
      __label__ = 4;
      break;
     case 3:
      var $16 = HEAP[__PyIO_zero];
      var $17 = HEAP[__PyIO_str_setstate];
      
      
      var $20 = HEAP[$self_addr + 28];
      var $21 = _PyObject_CallMethodObjArgs($20, $17, allocate([ $16, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $21;
      
      
      HEAP[$self_addr + 60] = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      if ($res == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      $0 = -1;
      __label__ = 9;
      break;
     case 6:
      
      
      
      var $29 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $29;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $40 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$40]($res);
      __label__ = 8;
      break;
     case 8:
      $0 = 0;
      __label__ = 9;
      break;
     case 9:
      
      $retval = $0;
      var $retval9 = $retval;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    _memset(__stackBase__, 0, 32);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $cookieObj = __stackBase__;
      var $posobj;
      var $cookie = __stackBase__ + 4;
      var $whence = __stackBase__ + 28;
      var $res;
      var $cmp;
      var $r;
      var $_res;
      var $_py_tmp;
      var $repr;
      var $_py_tmp68;
      var $input_chunk;
      var $decoded;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$whence] = 0;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 88;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str74, allocate([ $cookieObj, 0, 0, 0, $whence, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 88;
      break;
     case 7:
      
      
      
      
      
      var $18 = $self_addr;
      if (HEAP[$self_addr + 4] == _PyTextIOWrapper_Type) {
        __label__ = 8;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 8:
      
      
      
      var $22 = $self_addr;
      if (HEAP[$18 + 84] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      var $24 = HEAP[$22 + 84];
      var $25 = __PyFileIO_closed($24);
      $r = $25;
      __lastLabel__ = 9;
      __label__ = 16;
      break;
     case 10:
      var $26 = _textiowrapper_closed_get($22, 0);
      $_res = $26;
      
      
      if ($_res == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      $0 = 0;
      __label__ = 88;
      break;
     case 12:
      
      var $30 = _PyObject_IsTrue($_res);
      $r = $30;
      
      
      
      var $34 = HEAP[$_res] - 1;
      
      
      HEAP[$_res] = $34;
      
      
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $45 = HEAP[HEAP[$_res + 4] + 24];
      
      FUNCTION_TABLE[$45]($_res);
      __label__ = 14;
      break;
     case 14:
      var $47 = $r;
      
      if ($47 < 0) {
        __lastLabel__ = 14;
        __label__ = 15;
        break;
      } else {
        __lastLabel__ = 14;
        __label__ = 16;
        break;
      }
     case 15:
      $0 = 0;
      __label__ = 88;
      break;
     case 16:
      var $49 = __lastLabel__ == 14 ? $47 : $25;
      
      if ($49 > 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      var $51 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($51, __str60436);
      $0 = 0;
      __label__ = 88;
      break;
     case 18:
      
      var $53 = __PyIOBase_check_closed($18, __Py_TrueStruct);
      
      if ($53 == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      $0 = 0;
      __label__ = 88;
      break;
     case 20:
      
      
      
      var $58 = HEAP[HEAP[$cookieObj]] + 1;
      var $59 = HEAP[$cookieObj];
      HEAP[$59] = $58;
      
      
      
      
      if (HEAP[$self_addr + 52] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      var $64 = HEAP[_PyExc_IOError];
      _PyErr_SetString($64, __str75);
      __label__ = 84;
      break;
     case 22:
      
      
      if (HEAP[$whence] == 1) {
        __label__ = 23;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 23:
      var $67 = HEAP[__PyIO_zero];
      var $68 = HEAP[$cookieObj];
      var $69 = _PyObject_RichCompareBool($68, $67, 2);
      $cmp = $69;
      
      
      if ($cmp < 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      
      if ($cmp == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      var $74 = HEAP[_PyExc_IOError];
      _PyErr_SetString($74, __str76);
      __label__ = 84;
      break;
     case 26:
      var $75 = HEAP[$cookieObj];
      
      
      var $78 = HEAP[$75] - 1;
      var $79 = $75;
      HEAP[$79] = $78;
      
      
      
      if (HEAP[$75] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      
      
      var $87 = HEAP[HEAP[HEAP[$cookieObj] + 4] + 24];
      var $88 = HEAP[$cookieObj];
      FUNCTION_TABLE[$87]($88);
      __label__ = 28;
      break;
     case 28:
      
      
      var $91 = __PyObject_CallMethod_SizeT($self_addr, __str77, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$cookieObj] = $91;
      
      if ($91 == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 29:
      
      
      if (HEAP[$whence] == 2) {
        __label__ = 30;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 30:
      var $95 = HEAP[__PyIO_zero];
      var $96 = HEAP[$cookieObj];
      var $97 = _PyObject_RichCompareBool($96, $95, 2);
      $cmp = $97;
      
      
      if ($cmp < 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      if ($cmp == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      var $102 = HEAP[_PyExc_IOError];
      _PyErr_SetString($102, __str78);
      __label__ = 84;
      break;
     case 33:
      
      
      var $105 = __PyObject_CallMethod_SizeT($self_addr, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $105;
      
      
      if ($res == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 34:
      
      
      
      var $111 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $111;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      
      
      
      
      var $122 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$122]($res);
      __label__ = 36;
      break;
     case 36:
      
      _textiowrapper_set_decoded_chars($self_addr, 0);
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 37:
      
      
      
      $_py_tmp = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $137 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $137;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      
      var $148 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$148]($_py_tmp);
      __label__ = 39;
      break;
     case 39:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 40:
      
      
      var $156 = HEAP[$self_addr + 32];
      var $157 = __PyObject_CallMethod_SizeT($156, __str31406, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $157;
      
      
      if ($res == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 41:
      
      
      
      var $163 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $163;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 42:
      
      
      
      
      var $174 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$174]($res);
      __label__ = 43;
      break;
     case 43:
      
      
      var $178 = HEAP[$self_addr + 20];
      var $179 = __PyObject_CallMethod_SizeT($178, __str80, __str81, allocate([ 0, 0, 0, 0, 2, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $res = $179;
      
      
      if (HEAP[$cookieObj] != 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 44:
      var $182 = HEAP[$cookieObj];
      
      
      var $185 = HEAP[$182] - 1;
      var $186 = $182;
      HEAP[$186] = $185;
      
      
      
      if (HEAP[$182] == 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 45:
      
      
      
      
      var $194 = HEAP[HEAP[HEAP[$cookieObj] + 4] + 24];
      var $195 = HEAP[$cookieObj];
      FUNCTION_TABLE[$194]($195);
      __label__ = 46;
      break;
     case 46:
      
      $0 = $res;
      __label__ = 88;
      break;
     case 47:
      
      
      if (HEAP[$whence] != 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      var $199 = HEAP[$whence];
      var $200 = HEAP[_PyExc_ValueError];
      var $201 = _PyErr_Format($200, __str82, allocate([ $199, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 84;
      break;
     case 49:
      var $202 = HEAP[__PyIO_zero];
      var $203 = HEAP[$cookieObj];
      var $204 = _PyObject_RichCompareBool($203, $202, 0);
      $cmp = $204;
      
      if ($204 < 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      
      if ($cmp == 1) {
        __label__ = 51;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 51:
      var $208 = HEAP[$cookieObj];
      var $209 = _PyObject_Repr($208);
      $repr = $209;
      
      
      if ($repr != 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 52:
      
      
      
      
      var $216 = HEAP[_PyExc_ValueError];
      var $217 = _PyErr_Format($216, __str83, allocate([ $repr + 20, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $221 = HEAP[$repr] - 1;
      
      
      HEAP[$repr] = $221;
      
      
      
      
      if (HEAP[$repr] == 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 53:
      
      
      
      
      var $232 = HEAP[HEAP[$repr + 4] + 24];
      
      FUNCTION_TABLE[$232]($repr);
      __label__ = 84;
      break;
     case 54:
      var $234 = HEAP[__PyIO_str_flush];
      
      
      var $237 = _PyObject_CallMethodObjArgs($self_addr, $234, allocate(4, "i8*", ALLOC_STACK));
      $res = $237;
      
      
      if ($res == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 55:
      
      
      
      var $243 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $243;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 56:
      
      
      
      
      var $254 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$254]($res);
      __label__ = 57;
      break;
     case 57:
      var $256 = HEAP[$cookieObj];
      var $257 = _textiowrapper_parse_cookie($cookie, $256);
      
      if ($257 < 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      var $260 = HEAP[$cookie];
      var $261 = _PyLong_FromLongLong($260);
      $posobj = $261;
      
      
      if ($posobj == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 59:
      var $264 = HEAP[__PyIO_str_seek];
      
      
      var $267 = HEAP[$self_addr + 20];
      
      var $269 = _PyObject_CallMethodObjArgs($267, $264, allocate([ $posobj, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $269;
      
      
      
      var $273 = HEAP[$posobj] - 1;
      
      
      HEAP[$posobj] = $273;
      
      
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 60:
      
      
      
      
      var $284 = HEAP[HEAP[$posobj + 4] + 24];
      
      FUNCTION_TABLE[$284]($posobj);
      __label__ = 61;
      break;
     case 61:
      
      
      if ($res == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      
      
      
      var $291 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $291;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 63:
      
      
      
      
      var $302 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$302]($res);
      __label__ = 64;
      break;
     case 64:
      
      _textiowrapper_set_decoded_chars($self_addr, 0);
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 65:
      
      
      
      $_py_tmp68 = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $317 = HEAP[$_py_tmp68] - 1;
      
      
      HEAP[$_py_tmp68] = $317;
      
      
      
      
      if (HEAP[$_py_tmp68] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      
      
      
      
      var $328 = HEAP[HEAP[$_py_tmp68 + 4] + 24];
      
      FUNCTION_TABLE[$328]($_py_tmp68);
      __label__ = 67;
      break;
     case 67:
      
      
      
      
      if (HEAP[$self_addr + 32] != 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 68:
      
      var $335 = __textiowrapper_decoder_setstate($self_addr, $cookie);
      
      if ($335 < 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 69:
      
      
      
      if (HEAP[$cookie + 16] != 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 70:
      
      var $341 = HEAP[$cookie + 12];
      
      
      var $344 = HEAP[$self_addr + 20];
      var $345 = __PyObject_CallMethod_SizeT($344, __str1375, __str84, allocate([ $341, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      $input_chunk = $345;
      
      
      if ($input_chunk == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 71:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$input_chunk + 4] + 84] & 134217728) == 0) {
        __label__ = 72;
        break;
      } else {
        __label__ = 73;
        break;
      }
     case 72:
      ___assert_fail(__str66442, __str15390, 2088, ___PRETTY_FUNCTION___11188);
      throw "Reached an unreachable!";
     case 73:
      
      var $356 = HEAP[$cookie + 8];
      
      var $358 = __Py_BuildValue_SizeT(__str85, allocate([ $356, 0, 0, 0, $input_chunk, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      
      
      HEAP[$self_addr + 80] = $358;
      
      
      
      
      if (HEAP[$self_addr + 80] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 74:
      
      
      
      var $368 = HEAP[$input_chunk] - 1;
      
      
      HEAP[$input_chunk] = $368;
      
      
      
      
      if (HEAP[$input_chunk] == 0) {
        __label__ = 75;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 75:
      
      
      
      
      var $379 = HEAP[HEAP[$input_chunk + 4] + 24];
      
      FUNCTION_TABLE[$379]($input_chunk);
      __label__ = 84;
      break;
     case 76:
      
      
      var $383 = HEAP[$cookie + 20];
      
      
      var $386 = HEAP[$self_addr + 32];
      
      var $388 = __PyObject_CallMethod_SizeT($386, __str29404, __str51427, allocate([ $input_chunk, 0, 0, 0, $383, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $decoded = $388;
      
      
      if ($decoded == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 77:
      
      
      _textiowrapper_set_decoded_chars($self_addr, $decoded);
      
      
      var $395 = HEAP[$self_addr + 64];
      var $396 = _PyUnicodeUCS2_GetSize($395);
      
      
      
      if ($396 < HEAP[$cookie + 16]) {
        __label__ = 78;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 78:
      var $400 = HEAP[_PyExc_IOError];
      _PyErr_SetString($400, __str86);
      __label__ = 84;
      break;
     case 79:
      
      var $402 = HEAP[$cookie + 16];
      
      
      HEAP[$self_addr + 68] = $402;
      __label__ = 81;
      break;
     case 80:
      
      var $406 = HEAP[$cookie + 8];
      var $407 = __Py_BuildValue_SizeT(__str87, allocate([ $406, 0, 0, 0, __str20395, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      HEAP[$self_addr + 80] = $407;
      
      
      
      
      if (HEAP[$self_addr + 80] == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 81:
      
      
      
      
      if (HEAP[$self_addr + 28] != 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 82:
      
      var $419 = __textiowrapper_encoder_setstate($self_addr, $cookie);
      
      if ($419 < 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 83:
      
      $0 = HEAP[$cookieObj];
      __label__ = 88;
      break;
     case 84:
      
      
      if (HEAP[$cookieObj] != 0) {
        __label__ = 85;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 85:
      var $423 = HEAP[$cookieObj];
      
      
      var $426 = HEAP[$423] - 1;
      var $427 = $423;
      HEAP[$427] = $426;
      
      
      
      if (HEAP[$423] == 0) {
        __label__ = 86;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 86:
      
      
      
      
      var $435 = HEAP[HEAP[HEAP[$cookieObj] + 4] + 24];
      var $436 = HEAP[$cookieObj];
      FUNCTION_TABLE[$435]($436);
      __label__ = 87;
      break;
     case 87:
      $0 = 0;
      __label__ = 88;
      break;
     case 88:
      
      $retval = $0;
      var $retval92 = $retval;
      STACKTOP = __stackBase__;
      return $retval92;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_tell($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    _memset(__stackBase__, 0, 52);
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      var $posobj;
      var $cookie = __stackBase__;
      var $next_input = __stackBase__ + 24;
      var $chars_to_skip;
      var $chars_decoded;
      var $saved_state;
      var $input;
      var $input_end;
      var $r;
      var $_res;
      var $state;
      var $dec_buffer = __stackBase__ + 28;
      var $dec_buffer_len = __stackBase__ + 32;
      var $dec_flags = __stackBase__ + 36;
      var $decoded;
      var $decoded65;
      var $type = __stackBase__ + 40;
      var $value = __stackBase__ + 44;
      var $traceback = __stackBase__ + 48;
      $self_addr = $self;
      $args_addr = $args;
      $posobj = 0;
      
      HEAP[$cookie] = 0;
      
      HEAP[$cookie + 8] = 0;
      
      HEAP[$cookie + 12] = 0;
      
      HEAP[$cookie + 16] = 0;
      
      HEAP[$cookie + 20] = 0;
      $saved_state = 0;
      
      
      
      
      var $10 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $14 = HEAP[_PyExc_ValueError];
      if (HEAP[$10 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($14, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($14, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 92;
      break;
     case 5:
      
      
      
      
      var $19 = $self_addr;
      if (HEAP[$10 + 4] == _PyTextIOWrapper_Type) {
        __label__ = 6;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 6:
      
      
      
      var $23 = $self_addr;
      if (HEAP[$19 + 84] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      var $25 = HEAP[$23 + 84];
      var $26 = __PyFileIO_closed($25);
      $r = $26;
      __lastLabel__ = 7;
      __label__ = 14;
      break;
     case 8:
      var $27 = _textiowrapper_closed_get($23, 0);
      $_res = $27;
      
      
      if ($_res == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 92;
      break;
     case 10:
      
      var $31 = _PyObject_IsTrue($_res);
      $r = $31;
      
      
      
      var $35 = HEAP[$_res] - 1;
      
      
      HEAP[$_res] = $35;
      
      
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $46 = HEAP[HEAP[$_res + 4] + 24];
      
      FUNCTION_TABLE[$46]($_res);
      __label__ = 12;
      break;
     case 12:
      var $48 = $r;
      
      if ($48 < 0) {
        __lastLabel__ = 12;
        __label__ = 13;
        break;
      } else {
        __lastLabel__ = 12;
        __label__ = 14;
        break;
      }
     case 13:
      $0 = 0;
      __label__ = 92;
      break;
     case 14:
      var $50 = __lastLabel__ == 12 ? $48 : $26;
      
      if ($50 > 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      var $52 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($52, __str60436);
      $0 = 0;
      __label__ = 92;
      break;
     case 16:
      
      var $54 = __PyIOBase_check_closed($19, __Py_TrueStruct);
      
      if ($54 == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      $0 = 0;
      __label__ = 92;
      break;
     case 18:
      
      
      
      
      if (HEAP[$self_addr + 52] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      var $60 = HEAP[_PyExc_IOError];
      _PyErr_SetString($60, __str75);
      __label__ = 80;
      break;
     case 20:
      
      
      
      
      if (HEAP[$self_addr + 53] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      var $65 = HEAP[_PyExc_IOError];
      _PyErr_SetString($65, __str88);
      __label__ = 80;
      break;
     case 22:
      
      var $67 = __textiowrapper_writeflush($self_addr);
      
      if ($67 < 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      $0 = 0;
      __label__ = 92;
      break;
     case 24:
      
      
      var $71 = __PyObject_CallMethod_SizeT($self_addr, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $71;
      
      
      if ($res == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      
      
      
      var $77 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $77;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $88 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$88]($res);
      __label__ = 27;
      break;
     case 27:
      
      
      var $92 = HEAP[$self_addr + 20];
      var $93 = __PyObject_CallMethod_SizeT($92, __str77, 0, allocate(1, "i32", ALLOC_STACK));
      $posobj = $93;
      
      if ($93 == 0) {
        __label__ = 83;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 28:
      
      
      
      
      if (HEAP[$self_addr + 32] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 29:
      
      
      
      
      if (HEAP[$self_addr + 80] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 30:
      
      
      
      
      if (HEAP[$self_addr + 64] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      var $109 = HEAP[$self_addr + 64];
      var $110 = _PyUnicodeUCS2_GetSize($109);
      
      if ($110 != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      ___assert_fail(__str89, __str15390, 2166, ___PRETTY_FUNCTION___11475);
      throw "Reached an unreachable!";
     case 33:
      
      $0 = $posobj;
      __label__ = 92;
      break;
     case 34:
      
      var $114 = _PyLong_AsLongLong($posobj);
      
      HEAP[$cookie] = $114;
      var $116 = _PyErr_Occurred();
      
      if ($116 != 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 35:
      
      
      var $120 = HEAP[$self_addr + 80];
      var $121 = $cookie + 8;
      var $122 = __PyArg_Parse_SizeT($120, __str90, allocate([ $121, 0, 0, 0, $next_input, 0, 0, 0 ], [ "i32*", 0, 0, 0, "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($122 == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 36:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$next_input] + 4] + 84] & 134217728) == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      ___assert_fail(__str67443, __str15390, 2182, ___PRETTY_FUNCTION___11475);
      throw "Reached an unreachable!";
     case 38:
      
      
      
      
      
      
      
      var $138 = HEAP[$cookie] - HEAP[HEAP[$next_input] + 8];
      
      HEAP[$cookie] = $138;
      
      
      
      
      if (HEAP[$self_addr + 68] == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 39:
      
      
      
      var $147 = HEAP[$posobj] - 1;
      
      
      HEAP[$posobj] = $147;
      
      
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      
      
      
      
      var $158 = HEAP[HEAP[$posobj + 4] + 24];
      
      FUNCTION_TABLE[$158]($posobj);
      __label__ = 41;
      break;
     case 41:
      var $160 = _textiowrapper_build_cookie($cookie);
      $0 = $160;
      __label__ = 92;
      break;
     case 42:
      
      
      
      $chars_to_skip = HEAP[$self_addr + 68];
      var $164 = HEAP[__PyIO_str_getstate];
      
      
      var $167 = HEAP[$self_addr + 32];
      var $168 = _PyObject_CallMethodObjArgs($167, $164, allocate(4, "i8*", ALLOC_STACK));
      $saved_state = $168;
      
      
      if ($saved_state == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 43:
      
      var $172 = __textiowrapper_decoder_setstate($self_addr, $cookie);
      
      if ($172 < 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      $chars_decoded = 0;
      
      
      
      
      $input = HEAP[$next_input] + 20;
      
      
      
      
      
      
      $input_end = $input + HEAP[HEAP[$next_input] + 8];
      var $184 = $cookie + 12;
      var $185 = $cookie + 12;
      var $186 = $cookie;
      var $187 = $cookie + 12;
      var $188 = $cookie;
      var $189 = $cookie + 8;
      var $190 = $cookie + 12;
      __label__ = 61;
      break;
     case 45:
      
      
      var $193 = HEAP[$self_addr + 32];
      
      var $195 = __PyObject_CallMethod_SizeT($193, __str29404, __str91, allocate([ $input, 0, 0, 0, 1, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $decoded = $195;
      
      
      if ($decoded == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$decoded + 4] + 84] & 268435456) == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      ___assert_fail(__str92, __str15390, 2225, ___PRETTY_FUNCTION___11475);
      throw "Reached an unreachable!";
     case 48:
      
      
      
      
      
      var $210 = $chars_decoded + HEAP[$decoded + 8];
      $chars_decoded = $210;
      
      
      
      var $214 = HEAP[$decoded] - 1;
      
      
      HEAP[$decoded] = $214;
      
      
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 49:
      
      
      
      
      var $225 = HEAP[HEAP[$decoded + 4] + 24];
      
      FUNCTION_TABLE[$225]($decoded);
      __label__ = 50;
      break;
     case 50:
      
      var $228 = HEAP[$184] + 1;
      HEAP[$185] = $228;
      var $229 = HEAP[__PyIO_str_getstate];
      
      
      var $232 = HEAP[$self_addr + 32];
      var $233 = _PyObject_CallMethodObjArgs($232, $229, allocate(4, "i8*", ALLOC_STACK));
      $state = $233;
      
      if ($233 == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 51:
      
      var $236 = __PyArg_Parse_SizeT($state, __str93, allocate([ $dec_buffer, 0, 0, 0, $dec_buffer_len, 0, 0, 0, $dec_flags, 0, 0, 0 ], [ "i8**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      var $237 = $236 == 0;
      
      
      
      var $241 = HEAP[$state] - 1;
      
      
      HEAP[$state] = $241;
      
      
      
      var $247 = HEAP[$state] == 0;
      if ($237) {
        __label__ = 52;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 52:
      if ($247) {
        __label__ = 53;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 53:
      
      
      
      
      var $252 = HEAP[HEAP[$state + 4] + 24];
      
      FUNCTION_TABLE[$252]($state);
      __label__ = 80;
      break;
     case 54:
      if ($247) {
        __label__ = 55;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 55:
      
      
      
      
      var $258 = HEAP[HEAP[$state + 4] + 24];
      
      FUNCTION_TABLE[$258]($state);
      __label__ = 56;
      break;
     case 56:
      
      
      if (HEAP[$dec_buffer_len] == 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 57:
      
      
      
      if ($chars_decoded <= $chars_to_skip) {
        __label__ = 58;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 58:
      
      
      
      var $268 = HEAP[$187] + HEAP[$186];
      HEAP[$188] = $268;
      
      
      var $271 = $chars_to_skip - $chars_decoded;
      $chars_to_skip = $271;
      var $272 = HEAP[$dec_flags];
      HEAP[$189] = $272;
      HEAP[$190] = 0;
      $chars_decoded = 0;
      __label__ = 59;
      break;
     case 59:
      
      
      
      if ($chars_decoded >= $chars_to_skip) {
        __label__ = 62;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 60:
      
      var $277 = $input + 1;
      $input = $277;
      __label__ = 61;
      break;
     case 61:
      
      
      
      if ($input < $input_end) {
        __label__ = 45;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      
      
      
      if ($input == $input_end) {
        __label__ = 63;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 63:
      
      
      var $286 = HEAP[$self_addr + 32];
      var $287 = __PyObject_CallMethod_SizeT($286, __str29404, __str94, allocate([ __str20395, 0, 0, 0, 1, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      $decoded65 = $287;
      
      
      if ($decoded65 == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 64:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$decoded65 + 4] + 84] & 268435456) == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 65:
      ___assert_fail(__str92, __str15390, 2259, ___PRETTY_FUNCTION___11475);
      throw "Reached an unreachable!";
     case 66:
      
      
      
      
      
      var $302 = $chars_decoded + HEAP[$decoded65 + 8];
      $chars_decoded = $302;
      
      
      
      var $306 = HEAP[$decoded65] - 1;
      
      
      HEAP[$decoded65] = $306;
      
      
      
      
      if (HEAP[$decoded65] == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      
      
      
      
      var $317 = HEAP[HEAP[$decoded65 + 4] + 24];
      
      FUNCTION_TABLE[$317]($decoded65);
      __label__ = 68;
      break;
     case 68:
      
      HEAP[$cookie + 20] = 1;
      
      
      
      if ($chars_decoded < $chars_to_skip) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      var $323 = HEAP[_PyExc_IOError];
      _PyErr_SetString($323, __str95);
      __label__ = 80;
      break;
     case 70:
      
      
      if ($posobj != 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 73;
        break;
      }
     case 71:
      
      
      
      var $329 = HEAP[$posobj] - 1;
      
      
      HEAP[$posobj] = $329;
      
      
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 72;
        break;
      } else {
        __label__ = 73;
        break;
      }
     case 72:
      
      
      
      
      var $340 = HEAP[HEAP[$posobj + 4] + 24];
      
      FUNCTION_TABLE[$340]($posobj);
      __label__ = 73;
      break;
     case 73:
      
      
      var $344 = HEAP[$self_addr + 32];
      
      var $346 = __PyObject_CallMethod_SizeT($344, __str22397, __str96, allocate([ $saved_state, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      $res = $346;
      
      
      
      var $350 = HEAP[$saved_state] - 1;
      
      
      HEAP[$saved_state] = $350;
      
      
      
      
      if (HEAP[$saved_state] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 74:
      
      
      
      
      var $361 = HEAP[HEAP[$saved_state + 4] + 24];
      
      FUNCTION_TABLE[$361]($saved_state);
      __label__ = 75;
      break;
     case 75:
      
      
      if ($res == 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 76:
      $0 = 0;
      __label__ = 92;
      break;
     case 77:
      
      
      
      var $368 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $368;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 78;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 78:
      
      
      
      
      var $379 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$379]($res);
      __label__ = 79;
      break;
     case 79:
      
      
      HEAP[$cookie + 16] = $chars_to_skip;
      var $383 = _textiowrapper_build_cookie($cookie);
      $0 = $383;
      __label__ = 92;
      break;
     case 80:
      
      
      if ($posobj != 0) {
        __label__ = 81;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 81:
      
      
      
      var $388 = HEAP[$posobj] - 1;
      
      
      HEAP[$posobj] = $388;
      
      
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 82:
      
      
      
      
      var $399 = HEAP[HEAP[$posobj + 4] + 24];
      
      FUNCTION_TABLE[$399]($posobj);
      __label__ = 83;
      break;
     case 83:
      
      
      if ($saved_state != 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 91;
        break;
      }
     case 84:
      _PyErr_Fetch($type, $value, $traceback);
      
      
      var $405 = HEAP[$self_addr + 32];
      
      var $407 = __PyObject_CallMethod_SizeT($405, __str22397, __str96, allocate([ $saved_state, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      $res = $407;
      
      
      
      var $411 = HEAP[$saved_state] - 1;
      
      
      HEAP[$saved_state] = $411;
      
      
      
      
      if (HEAP[$saved_state] == 0) {
        __label__ = 85;
        break;
      } else {
        __label__ = 86;
        break;
      }
     case 85:
      
      
      
      
      var $422 = HEAP[HEAP[$saved_state + 4] + 24];
      
      FUNCTION_TABLE[$422]($saved_state);
      __label__ = 86;
      break;
     case 86:
      
      
      if ($res == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 87:
      $0 = 0;
      __label__ = 92;
      break;
     case 88:
      
      
      
      var $429 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $429;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 89;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 89:
      
      
      
      
      var $440 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$440]($res);
      __label__ = 90;
      break;
     case 90:
      var $442 = HEAP[$traceback];
      var $443 = HEAP[$value];
      var $444 = HEAP[$type];
      _PyErr_Restore($444, $443, $442);
      __label__ = 91;
      break;
     case 91:
      $0 = 0;
      __label__ = 92;
      break;
     case 92:
      
      $retval = $0;
      var $retval94 = $retval;
      STACKTOP = __stackBase__;
      return $retval94;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $pos = __stackBase__;
      var $res;
      $self_addr = $self;
      $args_addr = $args;
      HEAP[$pos] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 12;
      break;
     case 5:
      
      var $11 = __PyArg_ParseTuple_SizeT($args_addr, __str97, allocate([ $pos, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 12;
      break;
     case 7:
      var $13 = HEAP[__PyIO_str_flush];
      
      
      var $16 = _PyObject_CallMethodObjArgs($self_addr, $13, allocate(4, "i8*", ALLOC_STACK));
      $res = $16;
      
      
      if ($res == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      $0 = 0;
      __label__ = 12;
      break;
     case 9:
      
      
      
      var $22 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $22;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $33 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$33]($res);
      __label__ = 11;
      break;
     case 11:
      var $35 = HEAP[$pos];
      var $36 = HEAP[__PyIO_str_truncate];
      
      
      var $39 = HEAP[$self_addr + 20];
      var $40 = _PyObject_CallMethodObjArgs($39, $36, allocate([ $35, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $0 = $40;
      __label__ = 12;
      break;
     case 12:
      
      $retval = $0;
      var $retval12 = $retval;
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_repr($self) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $nameobj;
      var $res;
      var $namerepr;
      var $encrepr;
      $self_addr = $self;
      $namerepr = 0;
      $encrepr = 0;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 24;
      break;
     case 5:
      
      var $11 = _PyObject_GetAttrString($5, __str53429);
      $nameobj = $11;
      
      
      if ($nameobj == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      var $14 = HEAP[_PyExc_AttributeError];
      var $15 = _PyErr_ExceptionMatches($14);
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 7:
      _PyErr_Clear();
      
      
      var $19 = HEAP[$self_addr + 24];
      var $20 = _PyObject_Repr($19);
      $encrepr = $20;
      
      
      
      
      var $25 = _PyString_FromFormat(__str98, allocate([ $encrepr + 20, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $25;
      __label__ = 10;
      break;
     case 8:
      
      
      var $28 = HEAP[$self_addr + 24];
      var $29 = _PyObject_Repr($28);
      $encrepr = $29;
      
      var $31 = _PyObject_Repr($nameobj);
      $namerepr = $31;
      
      
      
      
      
      
      
      
      var $40 = _PyString_FromFormat(__str99, allocate([ $namerepr + 20, 0, 0, 0, $encrepr + 20, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      $res = $40;
      
      
      
      var $44 = HEAP[$nameobj] - 1;
      
      
      HEAP[$nameobj] = $44;
      
      
      
      
      if (HEAP[$nameobj] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $55 = HEAP[HEAP[$nameobj + 4] + 24];
      
      FUNCTION_TABLE[$55]($nameobj);
      __label__ = 10;
      break;
     case 10:
      
      
      if ($namerepr != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      
      var $62 = HEAP[$namerepr] - 1;
      
      
      HEAP[$namerepr] = $62;
      
      
      
      
      if (HEAP[$namerepr] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $73 = HEAP[HEAP[$namerepr + 4] + 24];
      
      FUNCTION_TABLE[$73]($namerepr);
      __label__ = 13;
      break;
     case 13:
      
      
      if ($encrepr != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      
      
      var $80 = HEAP[$encrepr] - 1;
      
      
      HEAP[$encrepr] = $80;
      
      
      
      
      if (HEAP[$encrepr] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $91 = HEAP[HEAP[$encrepr + 4] + 24];
      
      FUNCTION_TABLE[$91]($encrepr);
      __label__ = 16;
      break;
     case 16:
      
      $0 = $res;
      __label__ = 24;
      break;
     case 17:
      
      
      if ($namerepr != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      
      
      
      var $99 = HEAP[$namerepr] - 1;
      
      
      HEAP[$namerepr] = $99;
      
      
      
      
      if (HEAP[$namerepr] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $110 = HEAP[HEAP[$namerepr + 4] + 24];
      
      FUNCTION_TABLE[$110]($namerepr);
      __label__ = 20;
      break;
     case 20:
      
      
      if ($encrepr != 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 21:
      
      
      
      var $117 = HEAP[$encrepr] - 1;
      
      
      HEAP[$encrepr] = $117;
      
      
      
      
      if (HEAP[$encrepr] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      var $128 = HEAP[HEAP[$encrepr + 4] + 24];
      
      FUNCTION_TABLE[$128]($encrepr);
      __label__ = 23;
      break;
     case 23:
      $0 = 0;
      __label__ = 24;
      break;
     case 24:
      
      $retval = $0;
      var $retval23 = $retval;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_fileno($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 20];
      var $12 = __PyObject_CallMethod_SizeT($11, __str100, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_seekable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 20];
      var $12 = __PyObject_CallMethod_SizeT($11, __str55431, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_readable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 20];
      var $12 = __PyObject_CallMethod_SizeT($11, __str50426, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_writable($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 20];
      var $12 = __PyObject_CallMethod_SizeT($11, __str52428, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_isatty($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 20];
      var $12 = __PyObject_CallMethod_SizeT($11, __str101, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_flush($self, $args) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $r;
      var $_res;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 21;
      break;
     case 5:
      
      
      
      
      var $14 = $self_addr;
      if (HEAP[$5 + 4] == _PyTextIOWrapper_Type) {
        __label__ = 6;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 6:
      
      
      
      var $18 = $self_addr;
      if (HEAP[$14 + 84] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      var $20 = HEAP[$18 + 84];
      var $21 = __PyFileIO_closed($20);
      $r = $21;
      __lastLabel__ = 7;
      __label__ = 14;
      break;
     case 8:
      var $22 = _textiowrapper_closed_get($18, 0);
      $_res = $22;
      
      
      if ($_res == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      $0 = 0;
      __label__ = 21;
      break;
     case 10:
      
      var $26 = _PyObject_IsTrue($_res);
      $r = $26;
      
      
      
      var $30 = HEAP[$_res] - 1;
      
      
      HEAP[$_res] = $30;
      
      
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $41 = HEAP[HEAP[$_res + 4] + 24];
      
      FUNCTION_TABLE[$41]($_res);
      __label__ = 12;
      break;
     case 12:
      var $43 = $r;
      
      if ($43 < 0) {
        __lastLabel__ = 12;
        __label__ = 13;
        break;
      } else {
        __lastLabel__ = 12;
        __label__ = 14;
        break;
      }
     case 13:
      $0 = 0;
      __label__ = 21;
      break;
     case 14:
      var $45 = __lastLabel__ == 12 ? $43 : $21;
      
      if ($45 > 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      var $47 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($47, __str60436);
      $0 = 0;
      __label__ = 21;
      break;
     case 16:
      
      var $49 = __PyIOBase_check_closed($14, __Py_TrueStruct);
      
      if ($49 == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      $0 = 0;
      __label__ = 21;
      break;
     case 18:
      
      
      var $53 = HEAP[$self_addr + 52];
      
      
      HEAP[$self_addr + 53] = $53;
      
      var $57 = __textiowrapper_writeflush($self_addr);
      
      if ($57 < 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      $0 = 0;
      __label__ = 21;
      break;
     case 20:
      
      
      var $61 = HEAP[$self_addr + 20];
      var $62 = __PyObject_CallMethod_SizeT($61, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $62;
      __label__ = 21;
      break;
     case 21:
      
      $retval = $0;
      var $retval22 = $retval;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_close($self, $args) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $args_addr;
      var $retval;
      var $0;
      var $res;
      var $r;
      $self_addr = $self;
      $args_addr = $args;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 18;
      break;
     case 5:
      var $10 = _textiowrapper_closed_get($5, 0);
      $res = $10;
      
      
      if ($res == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      $0 = 0;
      __label__ = 18;
      break;
     case 7:
      
      var $14 = _PyObject_IsTrue($res);
      $r = $14;
      
      
      
      var $18 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $18;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $29 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$29]($res);
      __label__ = 9;
      break;
     case 9:
      
      
      if ($r < 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      $0 = 0;
      __label__ = 18;
      break;
     case 11:
      
      
      if ($r > 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      var $36 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $36;
      $0 = __Py_NoneStruct;
      __label__ = 18;
      break;
     case 13:
      
      
      var $39 = __PyObject_CallMethod_SizeT($self_addr, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      $res = $39;
      
      
      if ($res == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      $0 = 0;
      __label__ = 18;
      break;
     case 15:
      
      
      
      var $45 = HEAP[$res] - 1;
      
      
      HEAP[$res] = $45;
      
      
      
      
      if (HEAP[$res] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $56 = HEAP[HEAP[$res + 4] + 24];
      
      FUNCTION_TABLE[$56]($res);
      __label__ = 17;
      break;
     case 17:
      
      
      var $60 = HEAP[$self_addr + 20];
      var $61 = __PyObject_CallMethod_SizeT($60, __str102, 0, allocate(1, "i32", ALLOC_STACK));
      $0 = $61;
      __label__ = 18;
      break;
     case 18:
      
      $retval = $0;
      var $retval18 = $retval;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_iternext($self) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $retval;
      var $0;
      var $line;
      var $_py_tmp;
      $self_addr = $self;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 22;
      break;
     case 5:
      
      HEAP[$5 + 53] = 0;
      
      
      
      
      
      if (HEAP[$self_addr + 4] == _PyTextIOWrapper_Type) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      var $17 = __textiowrapper_readline($self_addr, -1);
      $line = $17;
      __lastLabel__ = 6;
      __label__ = 12;
      break;
     case 7:
      var $18 = HEAP[__PyIO_str_readline];
      
      
      var $21 = _PyObject_CallMethodObjArgs($self_addr, $18, allocate(4, "i8*", ALLOC_STACK));
      $line = $21;
      
      
      if ($line != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      var $31 = $line;
      if ((HEAP[HEAP[$line + 4] + 84] & 268435456) == 0) {
        __lastLabel__ = 8;
        __label__ = 9;
        break;
      } else {
        __lastLabel__ = 8;
        __label__ = 12;
        break;
      }
     case 9:
      
      
      
      var $35 = HEAP[HEAP[$31 + 4] + 12];
      var $36 = HEAP[_PyExc_IOError];
      var $37 = _PyErr_Format($36, __str103, allocate([ $35, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $41 = HEAP[$line] - 1;
      
      
      HEAP[$line] = $41;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $52 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$52]($line);
      __label__ = 11;
      break;
     case 11:
      $0 = 0;
      __label__ = 22;
      break;
     case 12:
      var $54 = __lastLabel__ == 6 ? $17 : $31;
      
      if ($54 == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      $0 = 0;
      __label__ = 22;
      break;
     case 14:
      
      
      
      
      
      var $61 = $line;
      if (HEAP[$line + 8] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 15:
      
      
      var $64 = HEAP[$61] - 1;
      
      
      HEAP[$line] = $64;
      
      
      
      
      if (HEAP[$line] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $75 = HEAP[HEAP[$line + 4] + 24];
      
      FUNCTION_TABLE[$75]($line);
      __label__ = 17;
      break;
     case 17:
      
      
      
      
      if (HEAP[$self_addr + 80] != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      
      
      
      $_py_tmp = HEAP[$self_addr + 80];
      
      
      HEAP[$self_addr + 80] = 0;
      
      
      
      var $89 = HEAP[$_py_tmp] - 1;
      
      
      HEAP[$_py_tmp] = $89;
      
      
      
      
      if (HEAP[$_py_tmp] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $100 = HEAP[HEAP[$_py_tmp + 4] + 24];
      
      FUNCTION_TABLE[$100]($_py_tmp);
      __label__ = 20;
      break;
     case 20:
      
      
      var $104 = HEAP[$self_addr + 52];
      
      
      HEAP[$self_addr + 53] = $104;
      $0 = 0;
      __label__ = 22;
      break;
     case 21:
      $0 = $61;
      __label__ = 22;
      break;
     case 22:
      
      $retval = $0;
      var $retval22 = $retval;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_name_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 20];
      var $12 = _PyObject_GetAttrString($11, __str53429);
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_closed_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      var $10 = HEAP[__PyIO_str_closed];
      
      
      var $13 = HEAP[$self_addr + 20];
      var $14 = _PyObject_GetAttr($13, $10);
      $0 = $14;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_newlines_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      var $res;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 12;
      break;
     case 5:
      
      
      
      if (HEAP[$5 + 32] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      var $14 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $14;
      $0 = __Py_NoneStruct;
      __label__ = 12;
      break;
     case 7:
      var $15 = HEAP[__PyIO_str_newlines];
      
      
      var $18 = HEAP[$self_addr + 32];
      var $19 = _PyObject_GetAttr($18, $15);
      $res = $19;
      
      
      if ($res == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      var $22 = HEAP[_PyExc_AttributeError];
      var $23 = _PyErr_ExceptionMatches($22);
      
      if ($23 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      _PyErr_Clear();
      
      var $26 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $26;
      $0 = __Py_NoneStruct;
      __label__ = 12;
      break;
     case 10:
      $0 = 0;
      __label__ = 12;
      break;
     case 11:
      
      $0 = $res;
      __label__ = 12;
      break;
     case 12:
      
      $retval = $0;
      var $retval12 = $retval;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_errors_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      
      
      var $14 = HEAP[HEAP[$5 + 40]] + 1;
      var $15 = HEAP[$5 + 40];
      HEAP[$15] = $14;
      
      
      
      $0 = HEAP[$self_addr + 40];
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_chunk_size_get($self, $context) {
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $context_addr;
      var $retval;
      var $0;
      $self_addr = $self;
      $context_addr = $context;
      
      
      
      
      var $5 = $self_addr;
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$5 + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = 0;
      __label__ = 6;
      break;
     case 5:
      
      var $11 = HEAP[$5 + 16];
      var $12 = _PyLong_FromSsize_t($11);
      $0 = $12;
      __label__ = 6;
      break;
     case 6:
      
      $retval = $0;
      var $retval6 = $retval;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_chunk_size_set($self, $arg, $context) {
    var __label__;
    var __lastLabel__ = null;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr;
      var $arg_addr;
      var $context_addr;
      var $retval;
      var $0;
      var $n;
      $self_addr = $self;
      $arg_addr = $arg;
      $context_addr = $context;
      
      
      
      
      if (HEAP[$self_addr + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      var $9 = HEAP[_PyExc_ValueError];
      if (HEAP[$self_addr + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      _PyErr_SetString($9, __str58434);
      __label__ = 4;
      break;
     case 4:
      $0 = -1;
      __label__ = 12;
      break;
     case 5:
      var $10 = HEAP[_PyExc_TypeError];
      
      var $12 = _PyNumber_AsSsize_t($arg_addr, $10);
      $n = $12;
      var $13 = $n;
      var $14 = $13 == -1;
      if ($14) {
        __lastLabel__ = 5;
        __label__ = 6;
        break;
      } else {
        __lastLabel__ = 5;
        __label__ = 9;
        break;
      }
     case 6:
      var $15 = _PyErr_Occurred();
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      $0 = -1;
      __label__ = 12;
      break;
     case 8:
      var $_pr = $n;
      __lastLabel__ = 8;
      __label__ = 9;
      break;
     case 9:
      var $17 = __lastLabel__ == 8 ? $_pr : $13;
      
      if ($17 <= 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      var $19 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($19, __str104);
      $0 = -1;
      __label__ = 12;
      break;
     case 11:
      
      
      
      HEAP[$self_addr + 16] = $n;
      $0 = 0;
      __label__ = 12;
      break;
     case 12:
      
      $retval = $0;
      var $retval11 = $retval;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  FUNCTION_TABLE = FUNCTION_TABLE.concat([ 0, 0, __PyIO_ConvertSsize_t, 0, _bufferediobase_detach, 0, _bufferediobase_read, 0, _bufferediobase_read1, 0, _bufferediobase_readinto, 0, _bufferediobase_write, 0, _buffered_detach, 0, _buffered_simple_flush, 0, _buffered_close, 0, _buffered_seekable, 0, _buffered_readable, 0, _buffered_writable, 0, _buffered_fileno, 0, _buffered_isatty, 0, _buffered_read, 0, _buffered_peek, 0, _buffered_read1, 0, _buffered_readline, 0, _buffered_seek, 0, _buffered_tell, 0, _buffered_truncate, 0, _buffered_closed_get, 0, _buffered_name_get, 0, _buffered_mode_get, 0, _buffered_dealloc, 0, _buffered_repr, 0, _buffered_traverse, 0, _buffered_clear, 0, _buffered_iternext, 0, _bufferedreader_init, 0, _PyType_GenericNew, 0, _bufferedwriter_write, 0, _buffered_flush, 0, _bufferedwriter_init, 0, _bufferedrwpair_read, 0, _bufferedrwpair_peek, 0, _bufferedrwpair_read1, 0, _bufferedrwpair_readinto, 0, _bufferedrwpair_write, 0, _bufferedrwpair_flush, 0, _bufferedrwpair_readable, 0, _bufferedrwpair_writable, 0, _bufferedrwpair_close, 0, _bufferedrwpair_isatty, 0, _bufferedrwpair_closed_get, 0, _bufferedrwpair_dealloc, 0, _bufferedrwpair_traverse, 0, _bufferedrwpair_clear, 0, _bufferedrwpair_init, 0, _buffered_readinto, 0, _bufferedrandom_init, 0, _bytesio_get_closed, 0, _return_true, 0, _bytesio_close, 0, _bytesio_flush, 0, _bytesio_isatty, 0, _bytesio_tell, 0, _bytesio_write, 0, _bytesio_writelines, 0, _bytesio_read1, 0, _bytesio_readinto, 0, _bytesio_readline, 0, _bytesio_readlines, 0, _bytesio_read, 0, _bytesio_getvalue, 0, _bytesio_seek, 0, _bytesio_truncate, 0, _bytesio_getstate, 0, _bytesio_setstate, 0, _bytesio_dealloc, 0, _bytesio_traverse, 0, _bytesio_clear, 0, _PyObject_SelfIter, 0, _bytesio_iternext, 0, _bytesio_init, 0, _bytesio_new, 0, _fileio_read, 0, _fileio_readall, 0, _fileio_readinto, 0, _fileio_write, 0, _fileio_seek, 0, _fileio_tell, 0, _fileio_truncate, 0, _fileio_close, 0, _fileio_seekable, 0, _fileio_readable, 0, _fileio_writable, 0, _fileio_fileno, 0, _fileio_isatty, 0, _get_closed, 0, _get_closefd, 0, _get_mode, 0, _fileio_dealloc, 0, _fileio_repr, 0, _PyObject_GenericGetAttr, 0, _fileio_traverse, 0, _fileio_clear, 0, _fileio_init, 0, _PyType_GenericAlloc, 0, _fileio_new, 0, _PyObject_GC_Del, 0, _iobase_seek, 0, _iobase_tell, 0, _iobase_truncate, 0, _iobase_flush, 0, _iobase_close, 0, _iobase_seekable, 0, _iobase_readable, 0, _iobase_writable, 0, __PyIOBase_check_closed, 0, __PyIOBase_check_seekable, 0, __PyIOBase_check_readable, 0, __PyIOBase_check_writable, 0, _iobase_fileno, 0, _iobase_isatty, 0, _iobase_enter, 0, _iobase_exit, 0, _iobase_readline, 0, _iobase_readlines, 0, _iobase_writelines, 0, _iobase_closed_get, 0, _iobase_dealloc, 0, _iobase_traverse, 0, _iobase_clear, 0, _iobase_iter, 0, _iobase_iternext, 0, _rawiobase_read, 0, _rawiobase_readall, 0, _blockingioerror_init, 0, _io_open, 0, _stringio_close, 0, _stringio_getvalue, 0, _stringio_read, 0, _stringio_readline, 0, _stringio_tell, 0, _stringio_truncate, 0, _stringio_seek, 0, _stringio_write, 0, _stringio_seekable, 0, _stringio_readable, 0, _stringio_writable, 0, _stringio_getstate, 0, _stringio_setstate, 0, _stringio_closed, 0, _stringio_newlines, 0, _stringio_line_buffering, 0, _stringio_dealloc, 0, _stringio_traverse, 0, _stringio_clear, 0, _stringio_iternext, 0, _stringio_init, 0, _stringio_new, 0, _textiobase_detach, 0, _textiobase_read, 0, _textiobase_readline, 0, _textiobase_write, 0, _textiobase_encoding_get, 0, _textiobase_newlines_get, 0, _textiobase_errors_get, 0, _incrementalnewlinedecoder_decode, 0, _incrementalnewlinedecoder_getstate, 0, _incrementalnewlinedecoder_setstate, 0, _incrementalnewlinedecoder_reset, 0, _incrementalnewlinedecoder_newlines_get, 0, _incrementalnewlinedecoder_dealloc, 0, _incrementalnewlinedecoder_init, 0, _ascii_encode, 0, _latin1_encode, 0, _utf8_encode, 0, _utf16be_encode, 0, _utf16le_encode, 0, _utf16_encode, 0, _utf32be_encode, 0, _utf32le_encode, 0, _utf32_encode, 0, _textiowrapper_detach, 0, _textiowrapper_write, 0, _textiowrapper_read, 0, _textiowrapper_readline, 0, _textiowrapper_flush, 0, _textiowrapper_close, 0, _textiowrapper_fileno, 0, _textiowrapper_seekable, 0, _textiowrapper_readable, 0, _textiowrapper_writable, 0, _textiowrapper_isatty, 0, _textiowrapper_seek, 0, _textiowrapper_tell, 0, _textiowrapper_truncate, 0, _textiowrapper_name_get, 0, _textiowrapper_closed_get, 0, _textiowrapper_newlines_get, 0, _textiowrapper_errors_get, 0, _textiowrapper_chunk_size_get, 0, _textiowrapper_chunk_size_set, 0, _textiowrapper_dealloc, 0, _textiowrapper_repr, 0, _textiowrapper_traverse, 0, _textiowrapper_clear, 0, _textiowrapper_iternext, 0, _textiowrapper_init, 0 ]);
  function run(args) {
    _bufferediobase_doc = allocate([ 66, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 115, 46, 10, 10, 84, 104, 101, 32, 109, 97, 105, 110, 32, 100, 105, 102, 102, 101, 114, 101, 110, 99, 101, 32, 119, 105, 116, 104, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 105, 115, 32, 116, 104, 97, 116, 32, 116, 104, 101, 32, 114, 101, 97, 100, 40, 41, 32, 109, 101, 116, 104, 111, 100, 10, 115, 117, 112, 112, 111, 114, 116, 115, 32, 111, 109, 105, 116, 116, 105, 110, 103, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 44, 32, 97, 110, 100, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 104, 97, 118, 101, 32, 97, 32, 100, 101, 102, 97, 117, 108, 116, 10, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 116, 104, 97, 116, 32, 100, 101, 102, 101, 114, 115, 32, 116, 111, 32, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 46, 10, 10, 73, 110, 32, 97, 100, 100, 105, 116, 105, 111, 110, 44, 32, 114, 101, 97, 100, 40, 41, 44, 32, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 40, 41, 32, 109, 97, 121, 32, 114, 97, 105, 115, 101, 10, 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 32, 105, 102, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 105, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 10, 109, 111, 100, 101, 32, 97, 110, 100, 32, 110, 111, 116, 32, 114, 101, 97, 100, 121, 59, 32, 117, 110, 108, 105, 107, 101, 32, 116, 104, 101, 105, 114, 32, 114, 97, 119, 32, 99, 111, 117, 110, 116, 101, 114, 112, 97, 114, 116, 115, 44, 32, 116, 104, 101, 121, 32, 119, 105, 108, 108, 32, 110, 101, 118, 101, 114, 10, 114, 101, 116, 117, 114, 110, 32, 78, 111, 110, 101, 46, 10, 10, 65, 32, 116, 121, 112, 105, 99, 97, 108, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 115, 104, 111, 117, 108, 100, 32, 110, 111, 116, 32, 105, 110, 104, 101, 114, 105, 116, 32, 102, 114, 111, 109, 32, 97, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 10, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 44, 32, 98, 117, 116, 32, 119, 114, 97, 112, 32, 111, 110, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str = allocate([ 119, 42, 58, 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    __str1 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str2 = allocate([ 110, 0 ], "i8", ALLOC_NORMAL);
    __str3 = allocate([ 114, 101, 97, 100, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 114, 101, 116, 117, 114, 110, 32, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_detach_doc = allocate([ 68, 105, 115, 99, 111, 110, 110, 101, 99, 116, 32, 116, 104, 105, 115, 32, 98, 117, 102, 102, 101, 114, 32, 102, 114, 111, 109, 32, 105, 116, 115, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 105, 116, 46, 10, 10, 65, 102, 116, 101, 114, 32, 116, 104, 101, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 44, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 32, 105, 115, 32, 105, 110, 32, 97, 110, 32, 117, 110, 117, 115, 97, 98, 108, 101, 10, 115, 116, 97, 116, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str4 = allocate([ 100, 101, 116, 97, 99, 104, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_read_doc = allocate([ 82, 101, 97, 100, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 117, 112, 32, 116, 111, 32, 110, 32, 98, 121, 116, 101, 115, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 78, 111, 110, 101, 44, 32, 111, 114, 32, 110, 101, 103, 97, 116, 105, 118, 101, 44, 32, 114, 101, 97, 100, 115, 32, 97, 110, 100, 10, 114, 101, 116, 117, 114, 110, 115, 32, 97, 108, 108, 32, 100, 97, 116, 97, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 112, 111, 115, 105, 116, 105, 118, 101, 44, 32, 97, 110, 100, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 10, 110, 111, 116, 32, 39, 105, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 39, 44, 32, 109, 117, 108, 116, 105, 112, 108, 101, 32, 114, 97, 119, 32, 114, 101, 97, 100, 115, 32, 109, 97, 121, 32, 98, 101, 32, 105, 115, 115, 117, 101, 100, 32, 116, 111, 32, 115, 97, 116, 105, 115, 102, 121, 10, 116, 104, 101, 32, 98, 121, 116, 101, 32, 99, 111, 117, 110, 116, 32, 40, 117, 110, 108, 101, 115, 115, 32, 69, 79, 70, 32, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 32, 102, 105, 114, 115, 116, 41, 46, 32, 32, 66, 117, 116, 32, 102, 111, 114, 10, 105, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 115, 32, 40, 97, 115, 32, 119, 101, 108, 108, 32, 97, 115, 32, 115, 111, 99, 107, 101, 116, 115, 32, 97, 110, 100, 32, 112, 105, 112, 101, 115, 41, 44, 32, 97, 116, 32, 109, 111, 115, 116, 10, 111, 110, 101, 32, 114, 97, 119, 32, 114, 101, 97, 100, 32, 119, 105, 108, 108, 32, 98, 101, 32, 105, 115, 115, 117, 101, 100, 44, 32, 97, 110, 100, 32, 97, 32, 115, 104, 111, 114, 116, 32, 114, 101, 115, 117, 108, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 105, 109, 112, 108, 121, 10, 116, 104, 97, 116, 32, 69, 79, 70, 32, 105, 115, 32, 105, 109, 109, 105, 110, 101, 110, 116, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 32, 111, 110, 32, 69, 79, 70, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 78, 111, 110, 101, 32, 105, 102, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 119, 97, 115, 32, 111, 112, 101, 110, 32, 105, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 10, 109, 111, 100, 101, 32, 97, 110, 100, 32, 110, 111, 32, 100, 97, 116, 97, 32, 105, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 32, 97, 116, 32, 116, 104, 101, 32, 109, 111, 109, 101, 110, 116, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_read1_doc = allocate([ 82, 101, 97, 100, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 117, 112, 32, 116, 111, 32, 110, 32, 98, 121, 116, 101, 115, 44, 32, 119, 105, 116, 104, 32, 97, 116, 32, 109, 111, 115, 116, 32, 111, 110, 101, 32, 114, 101, 97, 100, 40, 41, 32, 99, 97, 108, 108, 10, 116, 111, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 46, 32, 65, 32, 115, 104, 111, 114, 116, 32, 114, 101, 115, 117, 108, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 105, 109, 112, 108, 121, 10, 116, 104, 97, 116, 32, 69, 79, 70, 32, 105, 115, 32, 105, 109, 109, 105, 110, 101, 110, 116, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 32, 111, 110, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str5 = allocate([ 114, 101, 97, 100, 49, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_write_doc = allocate([ 87, 114, 105, 116, 101, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 98, 117, 102, 102, 101, 114, 32, 116, 111, 32, 116, 104, 101, 32, 73, 79, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 119, 114, 105, 116, 116, 101, 110, 44, 32, 119, 104, 105, 99, 104, 32, 105, 115, 32, 110, 101, 118, 101, 114, 32, 108, 101, 115, 115, 32, 116, 104, 97, 110, 10, 108, 101, 110, 40, 98, 41, 46, 10, 10, 82, 97, 105, 115, 101, 115, 32, 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 32, 105, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 32, 105, 115, 32, 102, 117, 108, 108, 32, 97, 110, 100, 32, 116, 104, 101, 10, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 99, 97, 110, 110, 111, 116, 32, 97, 99, 99, 101, 112, 116, 32, 109, 111, 114, 101, 32, 100, 97, 116, 97, 32, 97, 116, 32, 116, 104, 101, 32, 109, 111, 109, 101, 110, 116, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str6 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str7 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str8 = allocate([ 95, 105, 111, 46, 95, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str9 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str10 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 98, 117, 102, 102, 101, 114, 101, 100, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8563 = allocate([ 98, 117, 102, 102, 101, 114, 101, 100, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str11 = allocate([ 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str12 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 117, 110, 105, 110, 105, 116, 105, 97, 108, 105, 122, 101, 100, 32, 111, 98, 106, 101, 99, 116, 0 ], "i8", ALLOC_NORMAL);
    __str13 = allocate([ 110, 97, 109, 101, 0 ], "i8", ALLOC_NORMAL);
    __str14 = allocate([ 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str15 = allocate([ 82, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 118, 97, 108, 105, 100, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 37, 108, 108, 100, 0 ], "i8", ALLOC_NORMAL);
    __str16 = allocate([ 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 115, 116, 114, 105, 99, 116, 108, 121, 32, 112, 111, 115, 105, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    _eintr_int_9093 = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str17 = allocate([ 101, 105, 110, 116, 114, 95, 105, 110, 116, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9098 = allocate([ 95, 116, 114, 97, 112, 95, 101, 105, 110, 116, 114, 0 ], "i8", ALLOC_NORMAL);
    __str18 = allocate([ 101, 110, 118, 95, 101, 114, 114, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str19 = allocate([ 102, 108, 117, 115, 104, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str20 = allocate([ 124, 110, 58, 112, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str21 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str22 = allocate([ 114, 101, 97, 100, 32, 108, 101, 110, 103, 116, 104, 32, 109, 117, 115, 116, 32, 98, 101, 32, 112, 111, 115, 105, 116, 105, 118, 101, 32, 111, 114, 32, 45, 49, 0 ], "i8", ALLOC_NORMAL);
    __str23 = allocate([ 114, 101, 97, 100, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str24 = allocate([ 110, 58, 114, 101, 97, 100, 49, 0 ], "i8", ALLOC_NORMAL);
    __str25 = allocate([ 114, 101, 97, 100, 32, 108, 101, 110, 103, 116, 104, 32, 109, 117, 115, 116, 32, 98, 101, 32, 112, 111, 115, 105, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    __str26 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str27 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str28 = allocate([ 79, 124, 105, 58, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str29 = allocate([ 119, 104, 101, 110, 99, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 98, 101, 116, 119, 101, 101, 110, 32, 48, 32, 97, 110, 100, 32, 50, 44, 32, 110, 111, 116, 32, 37, 100, 0 ], "i8", ALLOC_NORMAL);
    __str30 = allocate([ 115, 101, 101, 107, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str31 = allocate([ 124, 79, 58, 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str32 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str33 = allocate([ 60, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    __str34 = allocate([ 60, 37, 115, 32, 110, 97, 109, 101, 61, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    _bufferedreader_doc = allocate([ 67, 114, 101, 97, 116, 101, 32, 97, 32, 110, 101, 119, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 101, 97, 100, 101, 114, 32, 117, 115, 105, 110, 103, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 114, 101, 97, 100, 97, 98, 108, 101, 32, 114, 97, 119, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    __str35 = allocate([ 114, 97, 119, 0 ], "i8", ALLOC_NORMAL);
    __str36 = allocate([ 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37 = allocate([ 79, 124, 110, 58, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str38 = allocate([ 114, 97, 119, 32, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 118, 97, 108, 105, 100, 32, 108, 101, 110, 103, 116, 104, 32, 37, 122, 100, 32, 40, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 98, 101, 101, 110, 32, 98, 101, 116, 119, 101, 101, 110, 32, 48, 32, 97, 110, 100, 32, 37, 122, 100, 41, 0 ], "i8", ALLOC_NORMAL);
    __str39 = allocate([ 114, 101, 109, 97, 105, 110, 105, 110, 103, 32, 60, 61, 32, 115, 101, 108, 102, 45, 62, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10369 = allocate([ 95, 98, 117, 102, 102, 101, 114, 101, 100, 114, 101, 97, 100, 101, 114, 95, 114, 101, 97, 100, 95, 103, 101, 110, 101, 114, 105, 99, 0 ], "i8", ALLOC_NORMAL);
    __str40 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __str41 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str42 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str43 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str45 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    __str46 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str47 = allocate([ 112, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str48 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str49 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str50 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str51 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _bufferedreader_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedreader_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str52 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    _bufferedreader_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str53 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedReader_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str54 = allocate([ 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    _bufferedwriter_doc = allocate([ 65, 32, 98, 117, 102, 102, 101, 114, 32, 102, 111, 114, 32, 97, 32, 119, 114, 105, 116, 101, 97, 98, 108, 101, 32, 115, 101, 113, 117, 101, 110, 116, 105, 97, 108, 32, 82, 97, 119, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 10, 10, 84, 104, 101, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 32, 99, 114, 101, 97, 116, 101, 115, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 32, 102, 111, 114, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 119, 114, 105, 116, 101, 97, 98, 108, 101, 32, 114, 97, 119, 10, 115, 116, 114, 101, 97, 109, 46, 32, 73, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 110, 111, 116, 32, 103, 105, 118, 101, 110, 44, 32, 105, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 10, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 46, 32, 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 110, 39, 116, 32, 117, 115, 101, 100, 32, 97, 110, 121, 109, 111, 114, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str55 = allocate([ 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    __str56 = allocate([ 79, 124, 110, 110, 58, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str57 = allocate([ 114, 97, 119, 32, 119, 114, 105, 116, 101, 40, 41, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 118, 97, 108, 105, 100, 32, 108, 101, 110, 103, 116, 104, 32, 37, 122, 100, 32, 40, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 98, 101, 101, 110, 32, 98, 101, 116, 119, 101, 101, 110, 32, 48, 32, 97, 110, 100, 32, 37, 122, 100, 41, 0 ], "i8", ALLOC_NORMAL);
    __str58 = allocate([ 115, 42, 58, 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str59 = allocate([ 119, 114, 105, 116, 101, 32, 116, 111, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str60 = allocate([ 40, 115, 101, 108, 102, 45, 62, 119, 114, 105, 116, 97, 98, 108, 101, 32, 38, 38, 32, 115, 101, 108, 102, 45, 62, 119, 114, 105, 116, 101, 95, 101, 110, 100, 32, 33, 61, 32, 45, 49, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10762 = allocate([ 98, 117, 102, 102, 101, 114, 101, 100, 119, 114, 105, 116, 101, 114, 95, 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _bufferedwriter_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedwriter_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedwriter_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str61 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedWriter_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrwpair_doc = allocate([ 65, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 101, 97, 100, 101, 114, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 116, 111, 103, 101, 116, 104, 101, 114, 46, 10, 10, 65, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 101, 97, 100, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 97, 110, 100, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 119, 114, 105, 116, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 112, 117, 116, 32, 116, 111, 103, 101, 116, 104, 101, 114, 32, 116, 111, 10, 102, 111, 114, 109, 32, 97, 32, 115, 101, 113, 117, 101, 110, 116, 105, 97, 108, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 32, 116, 104, 97, 116, 32, 99, 97, 110, 32, 114, 101, 97, 100, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 46, 32, 84, 104, 105, 115, 32, 105, 115, 32, 116, 121, 112, 105, 99, 97, 108, 108, 121, 10, 117, 115, 101, 100, 32, 119, 105, 116, 104, 32, 97, 32, 115, 111, 99, 107, 101, 116, 32, 111, 114, 32, 116, 119, 111, 45, 119, 97, 121, 32, 112, 105, 112, 101, 46, 10, 10, 114, 101, 97, 100, 101, 114, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 114, 32, 97, 114, 101, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 111, 98, 106, 101, 99, 116, 115, 32, 116, 104, 97, 116, 32, 97, 114, 101, 32, 114, 101, 97, 100, 97, 98, 108, 101, 32, 97, 110, 100, 10, 119, 114, 105, 116, 101, 97, 98, 108, 101, 32, 114, 101, 115, 112, 101, 99, 116, 105, 118, 101, 108, 121, 46, 32, 73, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 111, 109, 105, 116, 116, 101, 100, 32, 105, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 10, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str62 = allocate([ 79, 79, 124, 110, 110, 58, 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 0 ], "i8", ALLOC_NORMAL);
    __str63 = allocate([ 79, 110, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___11129 = allocate([ 98, 117, 102, 102, 101, 114, 101, 100, 114, 119, 112, 97, 105, 114, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    _bufferedrwpair_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrwpair_getset = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str64 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedRWPair_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrandom_doc = allocate([ 65, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 114, 97, 110, 100, 111, 109, 32, 97, 99, 99, 101, 115, 115, 32, 115, 116, 114, 101, 97, 109, 115, 46, 10, 10, 84, 104, 101, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 32, 99, 114, 101, 97, 116, 101, 115, 32, 97, 32, 114, 101, 97, 100, 101, 114, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 114, 32, 102, 111, 114, 32, 97, 32, 115, 101, 101, 107, 97, 98, 108, 101, 32, 115, 116, 114, 101, 97, 109, 44, 10, 114, 97, 119, 44, 32, 103, 105, 118, 101, 110, 32, 105, 110, 32, 116, 104, 101, 32, 102, 105, 114, 115, 116, 32, 97, 114, 103, 117, 109, 101, 110, 116, 46, 32, 73, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 111, 109, 105, 116, 116, 101, 100, 32, 105, 116, 10, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 46, 32, 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 110, 39, 116, 32, 117, 115, 101, 100, 32, 97, 110, 121, 109, 111, 114, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _bufferedrandom_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrandom_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrandom_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str65 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedRandom_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str66 = allocate([ 115, 101, 108, 102, 45, 62, 98, 117, 102, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str167 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 98, 121, 116, 101, 115, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8438 = allocate([ 103, 101, 116, 95, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str268 = allocate([ 108, 101, 110, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    __str369 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 60, 32, 40, 40, 80, 121, 95, 115, 115, 105, 122, 101, 95, 116, 41, 40, 40, 40, 115, 105, 122, 101, 95, 116, 41, 45, 49, 41, 62, 62, 49, 41, 41, 32, 45, 32, 108, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8477 = allocate([ 114, 101, 115, 105, 122, 101, 95, 98, 117, 102, 102, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str470 = allocate([ 110, 101, 119, 32, 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8514 = allocate([ 119, 114, 105, 116, 101, 95, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str571 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    _flush_doc = allocate([ 102, 108, 117, 115, 104, 40, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 68, 111, 101, 115, 32, 110, 111, 116, 104, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    __str672 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _getval_doc = allocate([ 103, 101, 116, 118, 97, 108, 117, 101, 40, 41, 32, 45, 62, 32, 98, 121, 116, 101, 115, 46, 10, 10, 82, 101, 116, 114, 105, 101, 118, 101, 32, 116, 104, 101, 32, 101, 110, 116, 105, 114, 101, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 111, 102, 32, 116, 104, 101, 32, 66, 121, 116, 101, 115, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    _isatty_doc = allocate([ 105, 115, 97, 116, 116, 121, 40, 41, 32, 45, 62, 32, 70, 97, 108, 115, 101, 46, 10, 10, 65, 108, 119, 97, 121, 115, 32, 114, 101, 116, 117, 114, 110, 115, 32, 70, 97, 108, 115, 101, 32, 115, 105, 110, 99, 101, 32, 66, 121, 116, 101, 115, 73, 79, 32, 111, 98, 106, 101, 99, 116, 115, 32, 97, 114, 101, 32, 110, 111, 116, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 10, 116, 111, 32, 97, 32, 116, 116, 121, 45, 108, 105, 107, 101, 32, 100, 101, 118, 105, 99, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _tell_doc = allocate([ 116, 101, 108, 108, 40, 41, 32, 45, 62, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 10, 0 ], "i8", ALLOC_NORMAL);
    _read_doc = allocate([ 114, 101, 97, 100, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 114, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 32, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 46, 10, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 0 ], "i8", ALLOC_NORMAL);
    __str773 = allocate([ 124, 79, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str874 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8642 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    _read1_doc = allocate([ 114, 101, 97, 100, 49, 40, 115, 105, 122, 101, 41, 32, 45, 62, 32, 114, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 32, 111, 114, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 32, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 46, 10, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 0 ], "i8", ALLOC_NORMAL);
    _readline_doc = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 110, 101, 120, 116, 32, 108, 105, 110, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 102, 105, 108, 101, 44, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 82, 101, 116, 97, 105, 110, 32, 110, 101, 119, 108, 105, 110, 101, 46, 32, 32, 65, 32, 110, 111, 110, 45, 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 108, 105, 109, 105, 116, 115, 32, 116, 104, 101, 32, 109, 97, 120, 105, 109, 117, 109, 10, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 116, 111, 32, 114, 101, 116, 117, 114, 110, 32, 40, 97, 110, 32, 105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 108, 105, 110, 101, 32, 109, 97, 121, 32, 98, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 104, 101, 110, 41, 46, 10, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str975 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    _readlines_doc = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 115, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 108, 105, 115, 116, 32, 111, 102, 32, 115, 116, 114, 105, 110, 103, 115, 44, 32, 101, 97, 99, 104, 32, 97, 32, 108, 105, 110, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 102, 105, 108, 101, 46, 10, 10, 67, 97, 108, 108, 32, 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 114, 101, 112, 101, 97, 116, 101, 100, 108, 121, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 108, 105, 115, 116, 32, 111, 102, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 115, 111, 32, 114, 101, 97, 100, 46, 10, 84, 104, 101, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 44, 32, 105, 102, 32, 103, 105, 118, 101, 110, 44, 32, 105, 115, 32, 97, 110, 32, 97, 112, 112, 114, 111, 120, 105, 109, 97, 116, 101, 32, 98, 111, 117, 110, 100, 32, 111, 110, 32, 116, 104, 101, 10, 116, 111, 116, 97, 108, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 105, 110, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str1076 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    _readinto_doc = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 40, 98, 121, 116, 101, 97, 114, 114, 97, 121, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 82, 101, 97, 100, 32, 117, 112, 32, 116, 111, 32, 108, 101, 110, 40, 98, 41, 32, 98, 121, 116, 101, 115, 32, 105, 110, 116, 111, 32, 98, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 114, 101, 97, 100, 32, 40, 48, 32, 102, 111, 114, 32, 69, 79, 70, 41, 44, 32, 111, 114, 32, 78, 111, 110, 101, 32, 105, 102, 32, 116, 104, 101, 32, 111, 98, 106, 101, 99, 116, 10, 105, 115, 32, 115, 101, 116, 32, 110, 111, 116, 32, 116, 111, 32, 98, 108, 111, 99, 107, 32, 97, 115, 32, 104, 97, 115, 32, 110, 111, 32, 100, 97, 116, 97, 32, 116, 111, 32, 114, 101, 97, 100, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1177 = allocate([ 119, 42, 0 ], "i8", ALLOC_NORMAL);
    __str1278 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 43, 32, 108, 101, 110, 32, 60, 32, 40, 40, 80, 121, 95, 115, 115, 105, 122, 101, 95, 116, 41, 40, 40, 40, 115, 105, 122, 101, 95, 116, 41, 45, 49, 41, 62, 62, 49, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8844 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    _truncate_doc = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 84, 114, 117, 110, 99, 97, 116, 101, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 46, 10, 10, 83, 105, 122, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 10, 84, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 115, 32, 117, 110, 99, 104, 97, 110, 103, 101, 100, 46, 32, 32, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 115, 105, 122, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str1480 = allocate([ 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 105, 122, 101, 32, 118, 97, 108, 117, 101, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    _seek_doc = allocate([ 115, 101, 101, 107, 40, 112, 111, 115, 44, 32, 119, 104, 101, 110, 99, 101, 61, 48, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 67, 104, 97, 110, 103, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 83, 101, 101, 107, 32, 116, 111, 32, 98, 121, 116, 101, 32, 111, 102, 102, 115, 101, 116, 32, 112, 111, 115, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 110, 100, 105, 99, 97, 116, 101, 100, 32, 98, 121, 32, 119, 104, 101, 110, 99, 101, 58, 10, 32, 32, 32, 32, 32, 48, 32, 32, 83, 116, 97, 114, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 41, 46, 32, 32, 112, 111, 115, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 62, 61, 32, 48, 59, 10, 32, 32, 32, 32, 32, 49, 32, 32, 67, 117, 114, 114, 101, 110, 116, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 45, 32, 112, 111, 115, 32, 109, 97, 121, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 59, 10, 32, 32, 32, 32, 32, 50, 32, 32, 69, 110, 100, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 45, 32, 112, 111, 115, 32, 117, 115, 117, 97, 108, 108, 121, 32, 110, 101, 103, 97, 116, 105, 118, 101, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1682 = allocate([ 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 32, 118, 97, 108, 117, 101, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    __str1783 = allocate([ 110, 101, 119, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    __str1884 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 119, 104, 101, 110, 99, 101, 32, 40, 37, 105, 44, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 48, 44, 32, 49, 32, 111, 114, 32, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    _write_doc = allocate([ 119, 114, 105, 116, 101, 40, 98, 121, 116, 101, 115, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 87, 114, 105, 116, 101, 32, 98, 121, 116, 101, 115, 32, 116, 111, 32, 102, 105, 108, 101, 46, 10, 10, 82, 101, 116, 117, 114, 110, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 119, 114, 105, 116, 116, 101, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    _writelines_doc = allocate([ 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 40, 115, 101, 113, 117, 101, 110, 99, 101, 95, 111, 102, 95, 115, 116, 114, 105, 110, 103, 115, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 87, 114, 105, 116, 101, 32, 115, 116, 114, 105, 110, 103, 115, 32, 116, 111, 32, 116, 104, 101, 32, 102, 105, 108, 101, 46, 10, 10, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 97, 114, 101, 32, 110, 111, 116, 32, 97, 100, 100, 101, 100, 46, 32, 32, 84, 104, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101, 32, 99, 97, 110, 32, 98, 101, 32, 97, 110, 121, 32, 105, 116, 101, 114, 97, 98, 108, 101, 10, 111, 98, 106, 101, 99, 116, 32, 112, 114, 111, 100, 117, 99, 105, 110, 103, 32, 115, 116, 114, 105, 110, 103, 115, 46, 32, 84, 104, 105, 115, 32, 105, 115, 32, 101, 113, 117, 105, 118, 97, 108, 101, 110, 116, 32, 116, 111, 32, 99, 97, 108, 108, 105, 110, 103, 32, 119, 114, 105, 116, 101, 40, 41, 32, 102, 111, 114, 10, 101, 97, 99, 104, 32, 115, 116, 114, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    _close_doc = allocate([ 99, 108, 111, 115, 101, 40, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 68, 105, 115, 97, 98, 108, 101, 32, 97, 108, 108, 32, 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1985 = allocate([ 40, 79, 110, 78, 41, 0 ], "i8", ALLOC_NORMAL);
    __str2086 = allocate([ 115, 116, 97, 116, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9134 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str2187 = allocate([ 37, 46, 50, 48, 48, 115, 46, 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 51, 45, 116, 117, 112, 108, 101, 44, 32, 103, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str2288 = allocate([ 115, 101, 99, 111, 110, 100, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 44, 32, 110, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str2389 = allocate([ 112, 111, 115, 105, 116, 105, 111, 110, 32, 118, 97, 108, 117, 101, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    __str2490 = allocate([ 116, 104, 105, 114, 100, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 97, 32, 100, 105, 99, 116, 44, 32, 103, 111, 116, 32, 97, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9218 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str2692 = allocate([ 116, 121, 112, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 38, 38, 32, 116, 121, 112, 101, 45, 62, 116, 112, 95, 97, 108, 108, 111, 99, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9255 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 110, 101, 119, 0 ], "i8", ALLOC_NORMAL);
    __str2793 = allocate([ 105, 110, 105, 116, 105, 97, 108, 95, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str2894 = allocate([ 124, 79, 58, 66, 121, 116, 101, 115, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str3096 = allocate([ 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 46, 0 ], "i8", ALLOC_NORMAL);
    _bytesio_getsetlist = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str39105 = allocate([ 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str43109 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str45111 = allocate([ 103, 101, 116, 118, 97, 108, 117, 101, 0 ], "i8", ALLOC_NORMAL);
    __str48114 = allocate([ 95, 95, 103, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str49115 = allocate([ 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    _bytesio_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bytesio_doc = allocate([ 66, 121, 116, 101, 115, 73, 79, 40, 91, 98, 117, 102, 102, 101, 114, 93, 41, 32, 45, 62, 32, 111, 98, 106, 101, 99, 116, 10, 10, 67, 114, 101, 97, 116, 101, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 73, 47, 79, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 117, 115, 105, 110, 103, 32, 97, 110, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 98, 121, 116, 101, 115, 10, 98, 117, 102, 102, 101, 114, 44, 32, 114, 101, 97, 100, 121, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    __str50116 = allocate([ 95, 105, 111, 46, 66, 121, 116, 101, 115, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    _PyBytesIO_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str117 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str1118 = allocate([ 79, 0 ], "i8", ALLOC_NORMAL);
    __str2119 = allocate([ 116, 121, 112, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 38, 38, 32, 116, 121, 112, 101, 45, 62, 116, 112, 95, 97, 108, 108, 111, 99, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str3120 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 102, 105, 108, 101, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8576 = allocate([ 102, 105, 108, 101, 105, 111, 95, 110, 101, 119, 0 ], "i8", ALLOC_NORMAL);
    __str4121 = allocate([ 40, 105, 115, 115, 41, 0 ], "i8", ALLOC_NORMAL);
    __str5122 = allocate([ 40, 105, 115, 41, 0 ], "i8", ALLOC_NORMAL);
    __str6123 = allocate([ 114, 0 ], "i8", ALLOC_NORMAL);
    __str7124 = allocate([ 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 40, 111, 115, 101, 108, 102, 41, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 32, 61, 61, 32, 40, 38, 80, 121, 70, 105, 108, 101, 73, 79, 95, 84, 121, 112, 101, 41, 32, 124, 124, 32, 80, 121, 84, 121, 112, 101, 95, 73, 115, 83, 117, 98, 116, 121, 112, 101, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 40, 111, 115, 101, 108, 102, 41, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 44, 32, 40, 38, 80, 121, 70, 105, 108, 101, 73, 79, 95, 84, 121, 112, 101, 41, 41, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8670 = allocate([ 102, 105, 108, 101, 105, 111, 95, 105, 110, 105, 116, 0 ], "i8", ALLOC_NORMAL);
    __str8125 = allocate([ 79, 124, 115, 105, 58, 102, 105, 108, 101, 105, 111, 0 ], "i8", ALLOC_NORMAL);
    _kwlist_8657 = allocate(16, "i8*", ALLOC_NORMAL);
    __str9126 = allocate([ 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str11128 = allocate([ 99, 108, 111, 115, 101, 102, 100, 0 ], "i8", ALLOC_NORMAL);
    __str12129 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 102, 108, 111, 97, 116, 0 ], "i8", ALLOC_NORMAL);
    __str13130 = allocate([ 78, 101, 103, 97, 116, 105, 118, 101, 32, 102, 105, 108, 101, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0 ], "i8", ALLOC_NORMAL);
    __str14131 = allocate([ 101, 110, 99, 111, 100, 101, 114, 32, 102, 97, 105, 108, 101, 100, 32, 116, 111, 32, 114, 101, 116, 117, 114, 110, 32, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str15132 = allocate([ 77, 117, 115, 116, 32, 104, 97, 118, 101, 32, 101, 120, 97, 99, 116, 108, 121, 32, 111, 110, 101, 32, 111, 102, 32, 114, 101, 97, 100, 47, 119, 114, 105, 116, 101, 47, 97, 112, 112, 101, 110, 100, 32, 109, 111, 100, 101, 32, 97, 110, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 111, 110, 101, 32, 112, 108, 117, 115, 0 ], "i8", ALLOC_NORMAL);
    __str16133 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 109, 111, 100, 101, 58, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str17134 = allocate([ 67, 97, 110, 110, 111, 116, 32, 117, 115, 101, 32, 99, 108, 111, 115, 101, 102, 100, 61, 70, 97, 108, 115, 101, 32, 119, 105, 116, 104, 32, 102, 105, 108, 101, 32, 110, 97, 109, 101, 0 ], "i8", ALLOC_NORMAL);
    __str19136 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8879 = allocate([ 102, 105, 108, 101, 105, 111, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str20137 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str21138 = allocate([ 70, 105, 108, 101, 32, 110, 111, 116, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str22139 = allocate([ 114, 101, 97, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str23140 = allocate([ 119, 42, 0 ], "i8", ALLOC_NORMAL);
    __str24141 = allocate([ 117, 110, 98, 111, 117, 110, 100, 101, 100, 32, 114, 101, 97, 100, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 109, 111, 114, 101, 32, 98, 121, 116, 101, 115, 32, 116, 104, 97, 110, 32, 97, 32, 80, 121, 116, 104, 111, 110, 32, 115, 116, 114, 105, 110, 103, 32, 99, 97, 110, 32, 104, 111, 108, 100, 32, 0 ], "i8", ALLOC_NORMAL);
    __str25142 = allocate([ 124, 79, 38, 0 ], "i8", ALLOC_NORMAL);
    __str26143 = allocate([ 119, 114, 105, 116, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str27144 = allocate([ 115, 42, 0 ], "i8", ALLOC_NORMAL);
    __str28145 = allocate([ 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 32, 105, 115, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str29146 = allocate([ 79, 124, 105, 0 ], "i8", ALLOC_NORMAL);
    __str30147 = allocate([ 124, 79, 0 ], "i8", ALLOC_NORMAL);
    __str31148 = allocate([ 114, 98, 43, 0 ], "i8", ALLOC_NORMAL);
    __str32149 = allocate([ 114, 98, 0 ], "i8", ALLOC_NORMAL);
    __str33150 = allocate([ 119, 98, 0 ], "i8", ALLOC_NORMAL);
    __str34151 = allocate([ 60, 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 32, 91, 99, 108, 111, 115, 101, 100, 93, 62, 0 ], "i8", ALLOC_NORMAL);
    __str35152 = allocate([ 60, 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 32, 102, 100, 61, 37, 100, 32, 109, 111, 100, 101, 61, 39, 37, 115, 39, 62, 0 ], "i8", ALLOC_NORMAL);
    __str36153 = allocate([ 60, 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 32, 110, 97, 109, 101, 61, 37, 115, 32, 109, 111, 100, 101, 61, 39, 37, 115, 39, 62, 0 ], "i8", ALLOC_NORMAL);
    _fileio_doc = allocate([ 102, 105, 108, 101, 40, 110, 97, 109, 101, 58, 32, 115, 116, 114, 91, 44, 32, 109, 111, 100, 101, 58, 32, 115, 116, 114, 93, 41, 32, 45, 62, 32, 102, 105, 108, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 10, 10, 79, 112, 101, 110, 32, 97, 32, 102, 105, 108, 101, 46, 32, 32, 84, 104, 101, 32, 109, 111, 100, 101, 32, 99, 97, 110, 32, 98, 101, 32, 39, 114, 39, 44, 32, 39, 119, 39, 32, 111, 114, 32, 39, 97, 39, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 40, 100, 101, 102, 97, 117, 108, 116, 41, 44, 10, 119, 114, 105, 116, 105, 110, 103, 32, 111, 114, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 46, 32, 32, 84, 104, 101, 32, 102, 105, 108, 101, 32, 119, 105, 108, 108, 32, 98, 101, 32, 99, 114, 101, 97, 116, 101, 100, 32, 105, 102, 32, 105, 116, 32, 100, 111, 101, 115, 110, 39, 116, 32, 101, 120, 105, 115, 116, 10, 119, 104, 101, 110, 32, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 32, 111, 114, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 59, 32, 105, 116, 32, 119, 105, 108, 108, 32, 98, 101, 32, 116, 114, 117, 110, 99, 97, 116, 101, 100, 32, 119, 104, 101, 110, 10, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 46, 32, 32, 65, 100, 100, 32, 97, 32, 39, 43, 39, 32, 116, 111, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 116, 111, 32, 97, 108, 108, 111, 119, 32, 115, 105, 109, 117, 108, 116, 97, 110, 101, 111, 117, 115, 10, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    _read_doc154 = allocate([ 114, 101, 97, 100, 40, 115, 105, 122, 101, 58, 32, 105, 110, 116, 41, 32, 45, 62, 32, 98, 121, 116, 101, 115, 46, 32, 32, 114, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 98, 121, 116, 101, 115, 46, 10, 10, 79, 110, 108, 121, 32, 109, 97, 107, 101, 115, 32, 111, 110, 101, 32, 115, 121, 115, 116, 101, 109, 32, 99, 97, 108, 108, 44, 32, 115, 111, 32, 108, 101, 115, 115, 32, 100, 97, 116, 97, 32, 109, 97, 121, 32, 98, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 104, 97, 110, 32, 114, 101, 113, 117, 101, 115, 116, 101, 100, 10, 73, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 109, 111, 100, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 78, 111, 110, 101, 32, 105, 102, 32, 110, 111, 32, 100, 97, 116, 97, 32, 105, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 46, 10, 79, 110, 32, 101, 110, 100, 45, 111, 102, 45, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 39, 39, 46, 0 ], "i8", ALLOC_NORMAL);
    _readall_doc = allocate([ 114, 101, 97, 100, 97, 108, 108, 40, 41, 32, 45, 62, 32, 98, 121, 116, 101, 115, 46, 32, 32, 114, 101, 97, 100, 32, 97, 108, 108, 32, 100, 97, 116, 97, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 98, 121, 116, 101, 115, 46, 10, 10, 73, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 109, 111, 100, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 115, 32, 109, 117, 99, 104, 32, 97, 115, 32, 105, 115, 32, 105, 109, 109, 101, 100, 105, 97, 116, 101, 108, 121, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 44, 10, 111, 114, 32, 78, 111, 110, 101, 32, 105, 102, 32, 110, 111, 32, 100, 97, 116, 97, 32, 105, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 46, 32, 32, 79, 110, 32, 101, 110, 100, 45, 111, 102, 45, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 39, 39, 46, 0 ], "i8", ALLOC_NORMAL);
    _write_doc155 = allocate([ 119, 114, 105, 116, 101, 40, 98, 58, 32, 98, 121, 116, 101, 115, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 87, 114, 105, 116, 101, 32, 98, 121, 116, 101, 115, 32, 98, 32, 116, 111, 32, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 32, 110, 117, 109, 98, 101, 114, 32, 119, 114, 105, 116, 116, 101, 110, 46, 10, 10, 79, 110, 108, 121, 32, 109, 97, 107, 101, 115, 32, 111, 110, 101, 32, 115, 121, 115, 116, 101, 109, 32, 99, 97, 108, 108, 44, 32, 115, 111, 32, 110, 111, 116, 32, 97, 108, 108, 32, 111, 102, 32, 116, 104, 101, 32, 100, 97, 116, 97, 32, 109, 97, 121, 32, 98, 101, 32, 119, 114, 105, 116, 116, 101, 110, 46, 10, 84, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 97, 99, 116, 117, 97, 108, 108, 121, 32, 119, 114, 105, 116, 116, 101, 110, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 46, 0 ], "i8", ALLOC_NORMAL);
    _fileno_doc = allocate([ 102, 105, 108, 101, 110, 111, 40, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 34, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 34, 46, 10, 10, 84, 104, 105, 115, 32, 105, 115, 32, 110, 101, 101, 100, 101, 100, 32, 102, 111, 114, 32, 108, 111, 119, 101, 114, 45, 108, 101, 118, 101, 108, 32, 102, 105, 108, 101, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 115, 44, 32, 115, 117, 99, 104, 32, 116, 104, 101, 32, 102, 99, 110, 116, 108, 32, 109, 111, 100, 117, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _seek_doc156 = allocate([ 115, 101, 101, 107, 40, 111, 102, 102, 115, 101, 116, 58, 32, 105, 110, 116, 91, 44, 32, 119, 104, 101, 110, 99, 101, 58, 32, 105, 110, 116, 93, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 77, 111, 118, 101, 32, 116, 111, 32, 110, 101, 119, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 65, 114, 103, 117, 109, 101, 110, 116, 32, 111, 102, 102, 115, 101, 116, 32, 105, 115, 32, 97, 32, 98, 121, 116, 101, 32, 99, 111, 117, 110, 116, 46, 32, 32, 79, 112, 116, 105, 111, 110, 97, 108, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 119, 104, 101, 110, 99, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 10, 48, 32, 40, 111, 102, 102, 115, 101, 116, 32, 102, 114, 111, 109, 32, 115, 116, 97, 114, 116, 32, 111, 102, 32, 102, 105, 108, 101, 44, 32, 111, 102, 102, 115, 101, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 62, 61, 32, 48, 41, 59, 32, 111, 116, 104, 101, 114, 32, 118, 97, 108, 117, 101, 115, 32, 97, 114, 101, 32, 49, 10, 40, 109, 111, 118, 101, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 99, 117, 114, 114, 101, 110, 116, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 112, 111, 115, 105, 116, 105, 118, 101, 32, 111, 114, 32, 110, 101, 103, 97, 116, 105, 118, 101, 41, 44, 32, 97, 110, 100, 32, 50, 32, 40, 109, 111, 118, 101, 10, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 101, 110, 100, 32, 111, 102, 32, 102, 105, 108, 101, 44, 32, 117, 115, 117, 97, 108, 108, 121, 32, 110, 101, 103, 97, 116, 105, 118, 101, 44, 32, 97, 108, 116, 104, 111, 117, 103, 104, 32, 109, 97, 110, 121, 32, 112, 108, 97, 116, 102, 111, 114, 109, 115, 32, 97, 108, 108, 111, 119, 10, 115, 101, 101, 107, 105, 110, 103, 32, 98, 101, 121, 111, 110, 100, 32, 116, 104, 101, 32, 101, 110, 100, 32, 111, 102, 32, 97, 32, 102, 105, 108, 101, 41, 46, 10, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 110, 111, 116, 32, 97, 108, 108, 32, 102, 105, 108, 101, 32, 111, 98, 106, 101, 99, 116, 115, 32, 97, 114, 101, 32, 115, 101, 101, 107, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _truncate_doc157 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 40, 91, 115, 105, 122, 101, 58, 32, 105, 110, 116, 93, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 84, 114, 117, 110, 99, 97, 116, 101, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 46, 10, 10, 83, 105, 122, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 84, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 115, 32, 99, 104, 97, 110, 103, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 118, 97, 108, 117, 101, 32, 111, 102, 32, 115, 105, 122, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _tell_doc158 = allocate([ 116, 101, 108, 108, 40, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 67, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    _readinto_doc159 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 32, 45, 62, 32, 83, 97, 109, 101, 32, 97, 115, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 46, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 46, 0 ], "i8", ALLOC_NORMAL);
    _close_doc160 = allocate([ 99, 108, 111, 115, 101, 40, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 67, 108, 111, 115, 101, 32, 116, 104, 101, 32, 102, 105, 108, 101, 46, 10, 10, 65, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 117, 115, 101, 100, 32, 102, 111, 114, 32, 102, 117, 114, 116, 104, 101, 114, 32, 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 46, 32, 32, 99, 108, 111, 115, 101, 40, 41, 32, 109, 97, 121, 32, 98, 101, 10, 99, 97, 108, 108, 101, 100, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 111, 110, 99, 101, 32, 119, 105, 116, 104, 111, 117, 116, 32, 101, 114, 114, 111, 114, 46, 32, 32, 67, 104, 97, 110, 103, 101, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 110, 111, 32, 116, 111, 32, 45, 49, 46, 0 ], "i8", ALLOC_NORMAL);
    _isatty_doc161 = allocate([ 105, 115, 97, 116, 116, 121, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 32, 116, 111, 32, 97, 32, 116, 116, 121, 32, 100, 101, 118, 105, 99, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _seekable_doc = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 102, 105, 108, 101, 32, 115, 117, 112, 112, 111, 114, 116, 115, 32, 114, 97, 110, 100, 111, 109, 45, 97, 99, 99, 101, 115, 115, 46, 0 ], "i8", ALLOC_NORMAL);
    _readable_doc = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 102, 105, 108, 101, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 114, 101, 97, 100, 32, 109, 111, 100, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _writable_doc = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 102, 105, 108, 101, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 119, 114, 105, 116, 101, 32, 109, 111, 100, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    __str37162 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str38163 = allocate([ 114, 101, 97, 100, 97, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str39164 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    __str40165 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str41166 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str42167 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str43168 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44169 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str45170 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str46171 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str48173 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    _fileio_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str49174 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str50175 = allocate([ 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str51176 = allocate([ 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 119, 105, 108, 108, 32, 98, 101, 32, 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str52177 = allocate([ 83, 116, 114, 105, 110, 103, 32, 103, 105, 118, 105, 110, 103, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    _fileio_getsetlist = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str53178 = allocate([ 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    _PyFileIO_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "void (i8*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _iobase_doc = allocate([ 84, 104, 101, 32, 97, 98, 115, 116, 114, 97, 99, 116, 32, 98, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 97, 108, 108, 32, 73, 47, 79, 32, 99, 108, 97, 115, 115, 101, 115, 44, 32, 97, 99, 116, 105, 110, 103, 32, 111, 110, 32, 115, 116, 114, 101, 97, 109, 115, 32, 111, 102, 10, 98, 121, 116, 101, 115, 46, 32, 84, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 32, 112, 117, 98, 108, 105, 99, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 10, 10, 84, 104, 105, 115, 32, 99, 108, 97, 115, 115, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 100, 117, 109, 109, 121, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 102, 111, 114, 32, 109, 97, 110, 121, 32, 109, 101, 116, 104, 111, 100, 115, 32, 116, 104, 97, 116, 10, 100, 101, 114, 105, 118, 101, 100, 32, 99, 108, 97, 115, 115, 101, 115, 32, 99, 97, 110, 32, 111, 118, 101, 114, 114, 105, 100, 101, 32, 115, 101, 108, 101, 99, 116, 105, 118, 101, 108, 121, 59, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 10, 114, 101, 112, 114, 101, 115, 101, 110, 116, 32, 97, 32, 102, 105, 108, 101, 32, 116, 104, 97, 116, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 114, 101, 97, 100, 44, 32, 119, 114, 105, 116, 116, 101, 110, 32, 111, 114, 32, 115, 101, 101, 107, 101, 100, 46, 10, 10, 69, 118, 101, 110, 32, 116, 104, 111, 117, 103, 104, 32, 73, 79, 66, 97, 115, 101, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 100, 101, 99, 108, 97, 114, 101, 32, 114, 101, 97, 100, 44, 32, 114, 101, 97, 100, 105, 110, 116, 111, 44, 32, 111, 114, 32, 119, 114, 105, 116, 101, 32, 98, 101, 99, 97, 117, 115, 101, 10, 116, 104, 101, 105, 114, 32, 115, 105, 103, 110, 97, 116, 117, 114, 101, 115, 32, 119, 105, 108, 108, 32, 118, 97, 114, 121, 44, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 97, 110, 100, 32, 99, 108, 105, 101, 110, 116, 115, 32, 115, 104, 111, 117, 108, 100, 10, 99, 111, 110, 115, 105, 100, 101, 114, 32, 116, 104, 111, 115, 101, 32, 109, 101, 116, 104, 111, 100, 115, 32, 112, 97, 114, 116, 32, 111, 102, 32, 116, 104, 101, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 46, 32, 65, 108, 115, 111, 44, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 10, 109, 97, 121, 32, 114, 97, 105, 115, 101, 32, 97, 32, 73, 79, 69, 114, 114, 111, 114, 32, 119, 104, 101, 110, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 32, 116, 104, 101, 121, 32, 100, 111, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 97, 114, 101, 32, 99, 97, 108, 108, 101, 100, 46, 10, 10, 84, 104, 101, 32, 98, 97, 115, 105, 99, 32, 116, 121, 112, 101, 32, 117, 115, 101, 100, 32, 102, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 100, 97, 116, 97, 32, 114, 101, 97, 100, 32, 102, 114, 111, 109, 32, 111, 114, 32, 119, 114, 105, 116, 116, 101, 110, 32, 116, 111, 32, 97, 32, 102, 105, 108, 101, 32, 105, 115, 10, 98, 121, 116, 101, 115, 46, 32, 98, 121, 116, 101, 97, 114, 114, 97, 121, 115, 32, 97, 114, 101, 32, 97, 99, 99, 101, 112, 116, 101, 100, 32, 116, 111, 111, 44, 32, 97, 110, 100, 32, 105, 110, 32, 115, 111, 109, 101, 32, 99, 97, 115, 101, 115, 32, 40, 115, 117, 99, 104, 32, 97, 115, 10, 114, 101, 97, 100, 105, 110, 116, 111, 41, 32, 110, 101, 101, 100, 101, 100, 46, 32, 84, 101, 120, 116, 32, 73, 47, 79, 32, 99, 108, 97, 115, 115, 101, 115, 32, 119, 111, 114, 107, 32, 119, 105, 116, 104, 32, 115, 116, 114, 32, 100, 97, 116, 97, 46, 10, 10, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 99, 97, 108, 108, 105, 110, 103, 32, 97, 110, 121, 32, 109, 101, 116, 104, 111, 100, 32, 40, 101, 118, 101, 110, 32, 105, 110, 113, 117, 105, 114, 105, 101, 115, 41, 32, 111, 110, 32, 97, 32, 99, 108, 111, 115, 101, 100, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 10, 117, 110, 100, 101, 102, 105, 110, 101, 100, 46, 32, 73, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 109, 97, 121, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 32, 105, 110, 32, 116, 104, 105, 115, 32, 99, 97, 115, 101, 46, 10, 10, 73, 79, 66, 97, 115, 101, 32, 40, 97, 110, 100, 32, 105, 116, 115, 32, 115, 117, 98, 99, 108, 97, 115, 115, 101, 115, 41, 32, 115, 117, 112, 112, 111, 114, 116, 32, 116, 104, 101, 32, 105, 116, 101, 114, 97, 116, 111, 114, 32, 112, 114, 111, 116, 111, 99, 111, 108, 44, 32, 109, 101, 97, 110, 105, 110, 103, 10, 116, 104, 97, 116, 32, 97, 110, 32, 73, 79, 66, 97, 115, 101, 32, 111, 98, 106, 101, 99, 116, 32, 99, 97, 110, 32, 98, 101, 32, 105, 116, 101, 114, 97, 116, 101, 100, 32, 111, 118, 101, 114, 32, 121, 105, 101, 108, 100, 105, 110, 103, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 105, 110, 32, 97, 10, 115, 116, 114, 101, 97, 109, 46, 10, 10, 73, 79, 66, 97, 115, 101, 32, 97, 108, 115, 111, 32, 115, 117, 112, 112, 111, 114, 116, 115, 32, 116, 104, 101, 32, 58, 107, 101, 121, 119, 111, 114, 100, 58, 96, 119, 105, 116, 104, 96, 32, 115, 116, 97, 116, 101, 109, 101, 110, 116, 46, 32, 73, 110, 32, 116, 104, 105, 115, 32, 101, 120, 97, 109, 112, 108, 101, 44, 10, 102, 112, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 32, 97, 102, 116, 101, 114, 32, 116, 104, 101, 32, 115, 117, 105, 116, 101, 32, 111, 102, 32, 116, 104, 101, 32, 119, 105, 116, 104, 32, 115, 116, 97, 116, 101, 109, 101, 110, 116, 32, 105, 115, 32, 99, 111, 109, 112, 108, 101, 116, 101, 58, 10, 10, 119, 105, 116, 104, 32, 111, 112, 101, 110, 40, 39, 115, 112, 97, 109, 46, 116, 120, 116, 39, 44, 32, 39, 114, 39, 41, 32, 97, 115, 32, 102, 112, 58, 10, 32, 32, 32, 32, 102, 112, 46, 119, 114, 105, 116, 101, 40, 39, 83, 112, 97, 109, 32, 97, 110, 100, 32, 101, 103, 103, 115, 33, 39, 41, 10, 0 ], "i8", ALLOC_NORMAL);
    _iobase_seek_doc = allocate([ 67, 104, 97, 110, 103, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 67, 104, 97, 110, 103, 101, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 116, 111, 32, 98, 121, 116, 101, 32, 111, 102, 102, 115, 101, 116, 32, 111, 102, 102, 115, 101, 116, 46, 32, 111, 102, 102, 115, 101, 116, 32, 105, 115, 10, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 116, 104, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 110, 100, 105, 99, 97, 116, 101, 100, 32, 98, 121, 32, 119, 104, 101, 110, 99, 101, 46, 32, 32, 86, 97, 108, 117, 101, 115, 10, 102, 111, 114, 32, 119, 104, 101, 110, 99, 101, 32, 97, 114, 101, 58, 10, 10, 42, 32, 48, 32, 45, 45, 32, 115, 116, 97, 114, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 41, 59, 32, 111, 102, 102, 115, 101, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 122, 101, 114, 111, 32, 111, 114, 32, 112, 111, 115, 105, 116, 105, 118, 101, 10, 42, 32, 49, 32, 45, 45, 32, 99, 117, 114, 114, 101, 110, 116, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 59, 32, 111, 102, 102, 115, 101, 116, 32, 109, 97, 121, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 10, 42, 32, 50, 32, 45, 45, 32, 101, 110, 100, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 59, 32, 111, 102, 102, 115, 101, 116, 32, 105, 115, 32, 117, 115, 117, 97, 108, 108, 121, 32, 110, 101, 103, 97, 116, 105, 118, 101, 10, 10, 82, 101, 116, 117, 114, 110, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    __str181 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    _iobase_tell_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 99, 117, 114, 114, 101, 110, 116, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1182 = allocate([ 105, 105, 0 ], "i8", ALLOC_NORMAL);
    _iobase_truncate_doc = allocate([ 84, 114, 117, 110, 99, 97, 116, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 46, 10, 10, 70, 105, 108, 101, 32, 112, 111, 105, 110, 116, 101, 114, 32, 105, 115, 32, 108, 101, 102, 116, 32, 117, 110, 99, 104, 97, 110, 103, 101, 100, 46, 32, 32, 83, 105, 122, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 73, 79, 10, 112, 111, 115, 105, 116, 105, 111, 110, 32, 97, 115, 32, 114, 101, 112, 111, 114, 116, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 32, 32, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 115, 105, 122, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    __str2183 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _iobase_flush_doc = allocate([ 70, 108, 117, 115, 104, 32, 119, 114, 105, 116, 101, 32, 98, 117, 102, 102, 101, 114, 115, 44, 32, 105, 102, 32, 97, 112, 112, 108, 105, 99, 97, 98, 108, 101, 46, 10, 10, 84, 104, 105, 115, 32, 105, 115, 32, 110, 111, 116, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 101, 100, 32, 102, 111, 114, 32, 114, 101, 97, 100, 45, 111, 110, 108, 121, 32, 97, 110, 100, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 115, 116, 114, 101, 97, 109, 115, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str3184 = allocate([ 95, 95, 73, 79, 66, 97, 115, 101, 95, 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str4185 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_close_doc = allocate([ 70, 108, 117, 115, 104, 32, 97, 110, 100, 32, 99, 108, 111, 115, 101, 32, 116, 104, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 10, 10, 84, 104, 105, 115, 32, 109, 101, 116, 104, 111, 100, 32, 104, 97, 115, 32, 110, 111, 32, 101, 102, 102, 101, 99, 116, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 97, 108, 114, 101, 97, 100, 121, 32, 99, 108, 111, 115, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str5186 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str6187 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 105, 111, 98, 97, 115, 101, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8634 = allocate([ 105, 111, 98, 97, 115, 101, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    _iobase_seekable_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 115, 117, 112, 112, 111, 114, 116, 115, 32, 114, 97, 110, 100, 111, 109, 32, 97, 99, 99, 101, 115, 115, 46, 10, 10, 73, 102, 32, 70, 97, 108, 115, 101, 44, 32, 115, 101, 101, 107, 40, 41, 44, 32, 116, 101, 108, 108, 40, 41, 32, 97, 110, 100, 32, 116, 114, 117, 110, 99, 97, 116, 101, 40, 41, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 46, 10, 84, 104, 105, 115, 32, 109, 101, 116, 104, 111, 100, 32, 109, 97, 121, 32, 110, 101, 101, 100, 32, 116, 111, 32, 100, 111, 32, 97, 32, 116, 101, 115, 116, 32, 115, 101, 101, 107, 40, 41, 46, 0 ], "i8", ALLOC_NORMAL);
    __str7188 = allocate([ 70, 105, 108, 101, 32, 111, 114, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 115, 101, 101, 107, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_readable_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 46, 10, 10, 73, 102, 32, 70, 97, 108, 115, 101, 44, 32, 114, 101, 97, 100, 40, 41, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    __str8189 = allocate([ 70, 105, 108, 101, 32, 111, 114, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 114, 101, 97, 100, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_writable_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 46, 10, 10, 73, 102, 32, 70, 97, 108, 115, 101, 44, 32, 114, 101, 97, 100, 40, 41, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    __str9190 = allocate([ 70, 105, 108, 101, 32, 111, 114, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 119, 114, 105, 116, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_fileno_doc = allocate([ 82, 101, 116, 117, 114, 110, 115, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 105, 102, 32, 111, 110, 101, 32, 101, 120, 105, 115, 116, 115, 46, 10, 10, 65, 110, 32, 73, 79, 69, 114, 114, 111, 114, 32, 105, 115, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 116, 104, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 117, 115, 101, 32, 97, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str10191 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    _iobase_isatty_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 116, 104, 105, 115, 32, 105, 115, 32, 97, 110, 32, 39, 105, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 39, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 82, 101, 116, 117, 114, 110, 32, 70, 97, 108, 115, 101, 32, 105, 102, 32, 105, 116, 32, 99, 97, 110, 39, 116, 32, 98, 101, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _iobase_readline_doc = allocate([ 82, 101, 97, 100, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 108, 105, 110, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 73, 102, 32, 108, 105, 109, 105, 116, 32, 105, 115, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 44, 32, 97, 116, 32, 109, 111, 115, 116, 32, 108, 105, 109, 105, 116, 32, 98, 121, 116, 101, 115, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 101, 97, 100, 46, 10, 10, 84, 104, 101, 32, 108, 105, 110, 101, 32, 116, 101, 114, 109, 105, 110, 97, 116, 111, 114, 32, 105, 115, 32, 97, 108, 119, 97, 121, 115, 32, 98, 39, 10, 39, 32, 102, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 102, 105, 108, 101, 115, 59, 32, 102, 111, 114, 32, 116, 101, 120, 116, 10, 102, 105, 108, 101, 115, 44, 32, 116, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 116, 111, 32, 111, 112, 101, 110, 32, 99, 97, 110, 32, 98, 101, 32, 117, 115, 101, 100, 32, 116, 111, 32, 115, 101, 108, 101, 99, 116, 32, 116, 104, 101, 32, 108, 105, 110, 101, 10, 116, 101, 114, 109, 105, 110, 97, 116, 111, 114, 40, 115, 41, 32, 114, 101, 99, 111, 103, 110, 105, 122, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str13194 = allocate([ 105, 0 ], "i8", ALLOC_NORMAL);
    __str14195 = allocate([ 112, 101, 101, 107, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str15196 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str17198 = allocate([ 114, 101, 97, 100, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str18199 = allocate([ 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 98, 117, 102, 102, 101, 114, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 32, 61, 61, 32, 40, 38, 80, 121, 66, 121, 116, 101, 65, 114, 114, 97, 121, 95, 84, 121, 112, 101, 41, 32, 124, 124, 32, 80, 121, 84, 121, 112, 101, 95, 73, 115, 83, 117, 98, 116, 121, 112, 101, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 98, 117, 102, 102, 101, 114, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 44, 32, 40, 38, 80, 121, 66, 121, 116, 101, 65, 114, 114, 97, 121, 95, 84, 121, 112, 101, 41, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8875 = allocate([ 105, 111, 98, 97, 115, 101, 95, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    _iobase_readlines_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 97, 32, 108, 105, 115, 116, 32, 111, 102, 32, 108, 105, 110, 101, 115, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 104, 105, 110, 116, 32, 99, 97, 110, 32, 98, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 116, 111, 32, 99, 111, 110, 116, 114, 111, 108, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 108, 105, 110, 101, 115, 32, 114, 101, 97, 100, 58, 32, 110, 111, 32, 109, 111, 114, 101, 10, 108, 105, 110, 101, 115, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 101, 97, 100, 32, 105, 102, 32, 116, 104, 101, 32, 116, 111, 116, 97, 108, 32, 115, 105, 122, 101, 32, 40, 105, 110, 32, 98, 121, 116, 101, 115, 47, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 41, 32, 111, 102, 32, 97, 108, 108, 10, 108, 105, 110, 101, 115, 32, 115, 111, 32, 102, 97, 114, 32, 101, 120, 99, 101, 101, 100, 115, 32, 104, 105, 110, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    __str19200 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str20201 = allocate([ 101, 120, 116, 101, 110, 100, 0 ], "i8", ALLOC_NORMAL);
    __str21202 = allocate([ 79, 0 ], "i8", ALLOC_NORMAL);
    __str22203 = allocate([ 79, 58, 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str23204 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str24205 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __str25206 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str26207 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str27208 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str28209 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str29210 = allocate([ 95, 99, 104, 101, 99, 107, 67, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str30211 = allocate([ 95, 99, 104, 101, 99, 107, 83, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str31212 = allocate([ 95, 99, 104, 101, 99, 107, 82, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str32213 = allocate([ 95, 99, 104, 101, 99, 107, 87, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str33214 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str34215 = allocate([ 95, 95, 101, 110, 116, 101, 114, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str35216 = allocate([ 95, 95, 101, 120, 105, 116, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str36217 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37218 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str38219 = allocate([ 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    _iobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str39220 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    _iobase_getset = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str40221 = allocate([ 95, 105, 111, 46, 95, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _rawiobase_doc = allocate([ 66, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 114, 97, 119, 32, 98, 105, 110, 97, 114, 121, 32, 73, 47, 79, 46, 0 ], "i8", ALLOC_NORMAL);
    __str41223 = allocate([ 124, 110, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str42224 = allocate([ 114, 101, 97, 100, 97, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    _rawiobase_readall_doc = allocate([ 82, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 44, 32, 117, 115, 105, 110, 103, 32, 109, 117, 108, 116, 105, 112, 108, 101, 32, 114, 101, 97, 100, 40, 41, 32, 99, 97, 108, 108, 46, 0 ], "i8", ALLOC_NORMAL);
    _rawiobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str44226 = allocate([ 95, 105, 111, 46, 95, 82, 97, 119, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyRawIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _module_doc = allocate([ 84, 104, 101, 32, 105, 111, 32, 109, 111, 100, 117, 108, 101, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 116, 104, 101, 32, 80, 121, 116, 104, 111, 110, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 115, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 32, 104, 97, 110, 100, 108, 105, 110, 103, 46, 32, 84, 104, 101, 10, 98, 117, 105, 108, 116, 105, 110, 32, 111, 112, 101, 110, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 105, 115, 32, 100, 101, 102, 105, 110, 101, 100, 32, 105, 110, 32, 116, 104, 105, 115, 32, 109, 111, 100, 117, 108, 101, 46, 10, 10, 65, 116, 32, 116, 104, 101, 32, 116, 111, 112, 32, 111, 102, 32, 116, 104, 101, 32, 73, 47, 79, 32, 104, 105, 101, 114, 97, 114, 99, 104, 121, 32, 105, 115, 32, 116, 104, 101, 32, 97, 98, 115, 116, 114, 97, 99, 116, 32, 98, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 73, 79, 66, 97, 115, 101, 46, 32, 73, 116, 10, 100, 101, 102, 105, 110, 101, 115, 32, 116, 104, 101, 32, 98, 97, 115, 105, 99, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 97, 32, 115, 116, 114, 101, 97, 109, 46, 32, 78, 111, 116, 101, 44, 32, 104, 111, 119, 101, 118, 101, 114, 44, 32, 116, 104, 97, 116, 32, 116, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 10, 115, 101, 112, 101, 114, 97, 116, 105, 111, 110, 32, 98, 101, 116, 119, 101, 101, 110, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 115, 59, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 97, 114, 101, 10, 97, 108, 108, 111, 119, 101, 100, 32, 116, 111, 32, 116, 104, 114, 111, 119, 32, 97, 110, 32, 73, 79, 69, 114, 114, 111, 114, 32, 105, 102, 32, 116, 104, 101, 121, 32, 100, 111, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 97, 32, 103, 105, 118, 101, 110, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 46, 10, 10, 69, 120, 116, 101, 110, 100, 105, 110, 103, 32, 73, 79, 66, 97, 115, 101, 32, 105, 115, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 119, 104, 105, 99, 104, 32, 100, 101, 97, 108, 115, 32, 115, 105, 109, 112, 108, 121, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 10, 119, 114, 105, 116, 105, 110, 103, 32, 111, 102, 32, 114, 97, 119, 32, 98, 121, 116, 101, 115, 32, 116, 111, 32, 97, 32, 115, 116, 114, 101, 97, 109, 46, 32, 70, 105, 108, 101, 73, 79, 32, 115, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 116, 111, 32, 112, 114, 111, 118, 105, 100, 101, 10, 97, 110, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 79, 83, 32, 102, 105, 108, 101, 115, 46, 10, 10, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 32, 100, 101, 97, 108, 115, 32, 119, 105, 116, 104, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 111, 110, 32, 97, 32, 114, 97, 119, 32, 98, 121, 116, 101, 32, 115, 116, 114, 101, 97, 109, 32, 40, 82, 97, 119, 73, 79, 66, 97, 115, 101, 41, 46, 32, 73, 116, 115, 10, 115, 117, 98, 99, 108, 97, 115, 115, 101, 115, 44, 32, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 44, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 44, 32, 97, 110, 100, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 32, 98, 117, 102, 102, 101, 114, 10, 115, 116, 114, 101, 97, 109, 115, 32, 116, 104, 97, 116, 32, 97, 114, 101, 32, 114, 101, 97, 100, 97, 98, 108, 101, 44, 32, 119, 114, 105, 116, 97, 98, 108, 101, 44, 32, 97, 110, 100, 32, 98, 111, 116, 104, 32, 114, 101, 115, 112, 101, 99, 116, 105, 118, 101, 108, 121, 46, 10, 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 114, 97, 110, 100, 111, 109, 32, 97, 99, 99, 101, 115, 115, 10, 115, 116, 114, 101, 97, 109, 115, 46, 32, 66, 121, 116, 101, 115, 73, 79, 32, 105, 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 115, 116, 114, 101, 97, 109, 32, 111, 102, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 98, 121, 116, 101, 115, 46, 10, 10, 65, 110, 111, 116, 104, 101, 114, 32, 73, 79, 66, 97, 115, 101, 32, 115, 117, 98, 99, 108, 97, 115, 115, 44, 32, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 44, 32, 100, 101, 97, 108, 115, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 97, 110, 100, 32, 100, 101, 99, 111, 100, 105, 110, 103, 10, 111, 102, 32, 115, 116, 114, 101, 97, 109, 115, 32, 105, 110, 116, 111, 32, 116, 101, 120, 116, 46, 32, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 44, 32, 119, 104, 105, 99, 104, 32, 101, 120, 116, 101, 110, 100, 115, 32, 105, 116, 44, 32, 105, 115, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 116, 101, 120, 116, 10, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 40, 96, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 96, 41, 46, 32, 70, 105, 110, 97, 108, 108, 121, 44, 32, 83, 116, 114, 105, 110, 103, 73, 79, 10, 105, 115, 32, 97, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 115, 116, 114, 101, 97, 109, 32, 102, 111, 114, 32, 116, 101, 120, 116, 46, 10, 10, 65, 114, 103, 117, 109, 101, 110, 116, 32, 110, 97, 109, 101, 115, 32, 97, 114, 101, 32, 110, 111, 116, 32, 112, 97, 114, 116, 32, 111, 102, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 99, 97, 116, 105, 111, 110, 44, 32, 97, 110, 100, 32, 111, 110, 108, 121, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 115, 10, 111, 102, 32, 111, 112, 101, 110, 40, 41, 32, 97, 114, 101, 32, 105, 110, 116, 101, 110, 100, 101, 100, 32, 116, 111, 32, 98, 101, 32, 117, 115, 101, 100, 32, 97, 115, 32, 107, 101, 121, 119, 111, 114, 100, 32, 97, 114, 103, 117, 109, 101, 110, 116, 115, 46, 10, 10, 100, 97, 116, 97, 58, 10, 10, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 10, 10, 32, 32, 32, 65, 110, 32, 105, 110, 116, 32, 99, 111, 110, 116, 97, 105, 110, 105, 110, 103, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 117, 115, 101, 100, 32, 98, 121, 32, 116, 104, 101, 32, 109, 111, 100, 117, 108, 101, 39, 115, 32, 98, 117, 102, 102, 101, 114, 101, 100, 10, 32, 32, 32, 73, 47, 79, 32, 99, 108, 97, 115, 115, 101, 115, 46, 32, 111, 112, 101, 110, 40, 41, 32, 117, 115, 101, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 39, 115, 32, 98, 108, 107, 115, 105, 122, 101, 32, 40, 97, 115, 32, 111, 98, 116, 97, 105, 110, 101, 100, 32, 98, 121, 32, 111, 115, 46, 115, 116, 97, 116, 41, 32, 105, 102, 10, 32, 32, 32, 112, 111, 115, 115, 105, 98, 108, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str232 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 97, 114, 103, 115, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 54, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str1233 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 95, 105, 111, 109, 111, 100, 117, 108, 101, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8454 = allocate([ 98, 108, 111, 99, 107, 105, 110, 103, 105, 111, 101, 114, 114, 111, 114, 95, 105, 110, 105, 116, 0 ], "i8", ALLOC_NORMAL);
    __str2234 = allocate([ 79, 79, 124, 110, 58, 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 0 ], "i8", ALLOC_NORMAL);
    __str3235 = allocate([ 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 95, 119, 114, 105, 116, 116, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    _blockingioerror_members = allocate([ 0, 0, 0, 0, 19, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str4236 = allocate([ 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 0 ], "i8", ALLOC_NORMAL);
    __str5237 = allocate([ 69, 120, 99, 101, 112, 116, 105, 111, 110, 32, 114, 97, 105, 115, 101, 100, 32, 119, 104, 101, 110, 32, 73, 47, 79, 32, 119, 111, 117, 108, 100, 32, 98, 108, 111, 99, 107, 32, 111, 110, 32, 97, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 73, 47, 79, 32, 115, 116, 114, 101, 97, 109, 0 ], "i8", ALLOC_NORMAL);
    __PyExc_BlockingIOError = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _PyExc_BlockingIOError = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    _open_doc = allocate([ 79, 112, 101, 110, 32, 102, 105, 108, 101, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 115, 116, 114, 101, 97, 109, 46, 32, 32, 82, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 32, 117, 112, 111, 110, 32, 102, 97, 105, 108, 117, 114, 101, 46, 10, 10, 102, 105, 108, 101, 32, 105, 115, 32, 101, 105, 116, 104, 101, 114, 32, 97, 32, 116, 101, 120, 116, 32, 111, 114, 32, 98, 121, 116, 101, 32, 115, 116, 114, 105, 110, 103, 32, 103, 105, 118, 105, 110, 103, 32, 116, 104, 101, 32, 110, 97, 109, 101, 32, 40, 97, 110, 100, 32, 116, 104, 101, 32, 112, 97, 116, 104, 10, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 110, 39, 116, 32, 105, 110, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 119, 111, 114, 107, 105, 110, 103, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 41, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 10, 98, 101, 32, 111, 112, 101, 110, 101, 100, 32, 111, 114, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 98, 101, 10, 119, 114, 97, 112, 112, 101, 100, 46, 32, 40, 73, 102, 32, 97, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 105, 115, 32, 103, 105, 118, 101, 110, 44, 32, 105, 116, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 32, 119, 104, 101, 110, 32, 116, 104, 101, 10, 114, 101, 116, 117, 114, 110, 101, 100, 32, 73, 47, 79, 32, 111, 98, 106, 101, 99, 116, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 44, 32, 117, 110, 108, 101, 115, 115, 32, 99, 108, 111, 115, 101, 102, 100, 32, 105, 115, 32, 115, 101, 116, 32, 116, 111, 32, 70, 97, 108, 115, 101, 46, 41, 10, 10, 109, 111, 100, 101, 32, 105, 115, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 115, 116, 114, 105, 110, 103, 32, 116, 104, 97, 116, 32, 115, 112, 101, 99, 105, 102, 105, 101, 115, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 105, 110, 32, 119, 104, 105, 99, 104, 32, 116, 104, 101, 32, 102, 105, 108, 101, 10, 105, 115, 32, 111, 112, 101, 110, 101, 100, 46, 32, 73, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 39, 114, 39, 32, 119, 104, 105, 99, 104, 32, 109, 101, 97, 110, 115, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 105, 110, 32, 116, 101, 120, 116, 10, 109, 111, 100, 101, 46, 32, 32, 79, 116, 104, 101, 114, 32, 99, 111, 109, 109, 111, 110, 32, 118, 97, 108, 117, 101, 115, 32, 97, 114, 101, 32, 39, 119, 39, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 32, 40, 116, 114, 117, 110, 99, 97, 116, 105, 110, 103, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 102, 10, 105, 116, 32, 97, 108, 114, 101, 97, 100, 121, 32, 101, 120, 105, 115, 116, 115, 41, 44, 32, 97, 110, 100, 32, 39, 97, 39, 32, 102, 111, 114, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 32, 40, 119, 104, 105, 99, 104, 32, 111, 110, 32, 115, 111, 109, 101, 32, 85, 110, 105, 120, 32, 115, 121, 115, 116, 101, 109, 115, 44, 10, 109, 101, 97, 110, 115, 32, 116, 104, 97, 116, 32, 97, 108, 108, 32, 119, 114, 105, 116, 101, 115, 32, 97, 112, 112, 101, 110, 100, 32, 116, 111, 32, 116, 104, 101, 32, 101, 110, 100, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 114, 101, 103, 97, 114, 100, 108, 101, 115, 115, 32, 111, 102, 32, 116, 104, 101, 10, 99, 117, 114, 114, 101, 110, 116, 32, 115, 101, 101, 107, 32, 112, 111, 115, 105, 116, 105, 111, 110, 41, 46, 32, 73, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 44, 32, 105, 102, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 115, 32, 110, 111, 116, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 116, 104, 101, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 117, 115, 101, 100, 32, 105, 115, 32, 112, 108, 97, 116, 102, 111, 114, 109, 32, 100, 101, 112, 101, 110, 100, 101, 110, 116, 46, 32, 40, 70, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 32, 114, 97, 119, 10, 98, 121, 116, 101, 115, 32, 117, 115, 101, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 97, 110, 100, 32, 108, 101, 97, 118, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 117, 110, 115, 112, 101, 99, 105, 102, 105, 101, 100, 46, 41, 32, 84, 104, 101, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 10, 109, 111, 100, 101, 115, 32, 97, 114, 101, 58, 10, 10, 61, 61, 61, 61, 61, 61, 61, 61, 61, 32, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 10, 67, 104, 97, 114, 97, 99, 116, 101, 114, 32, 77, 101, 97, 110, 105, 110, 103, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 32, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 39, 114, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 40, 100, 101, 102, 97, 117, 108, 116, 41, 10, 39, 119, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 44, 32, 116, 114, 117, 110, 99, 97, 116, 105, 110, 103, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 102, 105, 114, 115, 116, 10, 39, 97, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 44, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 32, 116, 111, 32, 116, 104, 101, 32, 101, 110, 100, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 102, 32, 105, 116, 32, 101, 120, 105, 115, 116, 115, 10, 39, 98, 39, 32, 32, 32, 32, 32, 32, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 10, 39, 116, 39, 32, 32, 32, 32, 32, 32, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 32, 40, 100, 101, 102, 97, 117, 108, 116, 41, 10, 39, 43, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 97, 32, 100, 105, 115, 107, 32, 102, 105, 108, 101, 32, 102, 111, 114, 32, 117, 112, 100, 97, 116, 105, 110, 103, 32, 40, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 41, 10, 39, 85, 39, 32, 32, 32, 32, 32, 32, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 109, 111, 100, 101, 32, 40, 102, 111, 114, 32, 98, 97, 99, 107, 119, 97, 114, 100, 115, 32, 99, 111, 109, 112, 97, 116, 105, 98, 105, 108, 105, 116, 121, 59, 32, 117, 110, 110, 101, 101, 100, 101, 100, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 32, 110, 101, 119, 32, 99, 111, 100, 101, 41, 10, 61, 61, 61, 61, 61, 61, 61, 61, 61, 32, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 10, 10, 84, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 109, 111, 100, 101, 32, 105, 115, 32, 39, 114, 116, 39, 32, 40, 111, 112, 101, 110, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 116, 101, 120, 116, 41, 46, 32, 70, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 114, 97, 110, 100, 111, 109, 10, 97, 99, 99, 101, 115, 115, 44, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 39, 119, 43, 98, 39, 32, 111, 112, 101, 110, 115, 32, 97, 110, 100, 32, 116, 114, 117, 110, 99, 97, 116, 101, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 48, 32, 98, 121, 116, 101, 115, 44, 32, 119, 104, 105, 108, 101, 10, 39, 114, 43, 98, 39, 32, 111, 112, 101, 110, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 119, 105, 116, 104, 111, 117, 116, 32, 116, 114, 117, 110, 99, 97, 116, 105, 111, 110, 46, 10, 10, 80, 121, 116, 104, 111, 110, 32, 100, 105, 115, 116, 105, 110, 103, 117, 105, 115, 104, 101, 115, 32, 98, 101, 116, 119, 101, 101, 110, 32, 102, 105, 108, 101, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 98, 105, 110, 97, 114, 121, 32, 97, 110, 100, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 115, 44, 10, 101, 118, 101, 110, 32, 119, 104, 101, 110, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 111, 112, 101, 114, 97, 116, 105, 110, 103, 32, 115, 121, 115, 116, 101, 109, 32, 100, 111, 101, 115, 110, 39, 116, 46, 32, 70, 105, 108, 101, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 10, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 40, 97, 112, 112, 101, 110, 100, 105, 110, 103, 32, 39, 98, 39, 32, 116, 111, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 41, 32, 114, 101, 116, 117, 114, 110, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 97, 115, 10, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 115, 32, 119, 105, 116, 104, 111, 117, 116, 32, 97, 110, 121, 32, 100, 101, 99, 111, 100, 105, 110, 103, 46, 32, 73, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 44, 32, 111, 114, 32, 119, 104, 101, 110, 10, 39, 116, 39, 32, 105, 115, 32, 97, 112, 112, 101, 110, 100, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 41, 44, 32, 116, 104, 101, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 97, 114, 101, 10, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 115, 116, 114, 105, 110, 103, 115, 44, 32, 116, 104, 101, 32, 98, 121, 116, 101, 115, 32, 104, 97, 118, 105, 110, 103, 32, 98, 101, 101, 110, 32, 102, 105, 114, 115, 116, 32, 100, 101, 99, 111, 100, 101, 100, 32, 117, 115, 105, 110, 103, 32, 97, 10, 112, 108, 97, 116, 102, 111, 114, 109, 45, 100, 101, 112, 101, 110, 100, 101, 110, 116, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 111, 114, 32, 117, 115, 105, 110, 103, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 102, 32, 103, 105, 118, 101, 110, 46, 10, 10, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 105, 115, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 105, 110, 116, 101, 103, 101, 114, 32, 117, 115, 101, 100, 32, 116, 111, 32, 115, 101, 116, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 112, 111, 108, 105, 99, 121, 46, 10, 80, 97, 115, 115, 32, 48, 32, 116, 111, 32, 115, 119, 105, 116, 99, 104, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 111, 102, 102, 32, 40, 111, 110, 108, 121, 32, 97, 108, 108, 111, 119, 101, 100, 32, 105, 110, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 41, 44, 32, 49, 32, 116, 111, 32, 115, 101, 108, 101, 99, 116, 10, 108, 105, 110, 101, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 40, 111, 110, 108, 121, 32, 117, 115, 97, 98, 108, 101, 32, 105, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 41, 44, 32, 97, 110, 100, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 32, 62, 32, 49, 32, 116, 111, 32, 105, 110, 100, 105, 99, 97, 116, 101, 10, 116, 104, 101, 32, 115, 105, 122, 101, 32, 111, 102, 32, 97, 32, 102, 105, 120, 101, 100, 45, 115, 105, 122, 101, 32, 99, 104, 117, 110, 107, 32, 98, 117, 102, 102, 101, 114, 46, 32, 32, 87, 104, 101, 110, 32, 110, 111, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 10, 103, 105, 118, 101, 110, 44, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 112, 111, 108, 105, 99, 121, 32, 119, 111, 114, 107, 115, 32, 97, 115, 32, 102, 111, 108, 108, 111, 119, 115, 58, 10, 10, 42, 32, 66, 105, 110, 97, 114, 121, 32, 102, 105, 108, 101, 115, 32, 97, 114, 101, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 105, 110, 32, 102, 105, 120, 101, 100, 45, 115, 105, 122, 101, 32, 99, 104, 117, 110, 107, 115, 59, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 111, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 10, 32, 32, 105, 115, 32, 99, 104, 111, 115, 101, 110, 32, 117, 115, 105, 110, 103, 32, 97, 32, 104, 101, 117, 114, 105, 115, 116, 105, 99, 32, 116, 114, 121, 105, 110, 103, 32, 116, 111, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 100, 101, 118, 105, 99, 101, 39, 115, 10, 32, 32, 34, 98, 108, 111, 99, 107, 32, 115, 105, 122, 101, 34, 32, 97, 110, 100, 32, 102, 97, 108, 108, 105, 110, 103, 32, 98, 97, 99, 107, 32, 111, 110, 32, 96, 105, 111, 46, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 96, 46, 10, 32, 32, 79, 110, 32, 109, 97, 110, 121, 32, 115, 121, 115, 116, 101, 109, 115, 44, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 32, 119, 105, 108, 108, 32, 116, 121, 112, 105, 99, 97, 108, 108, 121, 32, 98, 101, 32, 52, 48, 57, 54, 32, 111, 114, 32, 56, 49, 57, 50, 32, 98, 121, 116, 101, 115, 32, 108, 111, 110, 103, 46, 10, 10, 42, 32, 34, 73, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 34, 32, 116, 101, 120, 116, 32, 102, 105, 108, 101, 115, 32, 40, 102, 105, 108, 101, 115, 32, 102, 111, 114, 32, 119, 104, 105, 99, 104, 32, 105, 115, 97, 116, 116, 121, 40, 41, 32, 114, 101, 116, 117, 114, 110, 115, 32, 84, 114, 117, 101, 41, 10, 32, 32, 117, 115, 101, 32, 108, 105, 110, 101, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 46, 32, 32, 79, 116, 104, 101, 114, 32, 116, 101, 120, 116, 32, 102, 105, 108, 101, 115, 32, 117, 115, 101, 32, 116, 104, 101, 32, 112, 111, 108, 105, 99, 121, 32, 100, 101, 115, 99, 114, 105, 98, 101, 100, 32, 97, 98, 111, 118, 101, 10, 32, 32, 102, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 102, 105, 108, 101, 115, 46, 10, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 115, 32, 116, 104, 101, 32, 110, 97, 109, 101, 32, 111, 102, 32, 116, 104, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 117, 115, 101, 100, 32, 116, 111, 32, 100, 101, 99, 111, 100, 101, 32, 111, 114, 32, 101, 110, 99, 111, 100, 101, 32, 116, 104, 101, 10, 102, 105, 108, 101, 46, 32, 84, 104, 105, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 110, 108, 121, 32, 98, 101, 32, 117, 115, 101, 100, 32, 105, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 46, 32, 84, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 115, 10, 112, 108, 97, 116, 102, 111, 114, 109, 32, 100, 101, 112, 101, 110, 100, 101, 110, 116, 44, 32, 98, 117, 116, 32, 97, 110, 121, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 32, 98, 121, 32, 80, 121, 116, 104, 111, 110, 32, 99, 97, 110, 32, 98, 101, 10, 112, 97, 115, 115, 101, 100, 46, 32, 32, 83, 101, 101, 32, 116, 104, 101, 32, 99, 111, 100, 101, 99, 115, 32, 109, 111, 100, 117, 108, 101, 32, 102, 111, 114, 32, 116, 104, 101, 32, 108, 105, 115, 116, 32, 111, 102, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 32, 101, 110, 99, 111, 100, 105, 110, 103, 115, 46, 10, 10, 101, 114, 114, 111, 114, 115, 32, 105, 115, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 115, 116, 114, 105, 110, 103, 32, 116, 104, 97, 116, 32, 115, 112, 101, 99, 105, 102, 105, 101, 115, 32, 104, 111, 119, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 115, 32, 97, 114, 101, 32, 116, 111, 10, 98, 101, 32, 104, 97, 110, 100, 108, 101, 100, 45, 45, 45, 116, 104, 105, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 104, 111, 117, 108, 100, 32, 110, 111, 116, 32, 98, 101, 32, 117, 115, 101, 100, 32, 105, 110, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 46, 32, 80, 97, 115, 115, 10, 39, 115, 116, 114, 105, 99, 116, 39, 32, 116, 111, 32, 114, 97, 105, 115, 101, 32, 97, 32, 86, 97, 108, 117, 101, 69, 114, 114, 111, 114, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 32, 105, 102, 32, 116, 104, 101, 114, 101, 32, 105, 115, 32, 97, 110, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 10, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 111, 102, 32, 78, 111, 110, 101, 32, 104, 97, 115, 32, 116, 104, 101, 32, 115, 97, 109, 101, 32, 101, 102, 102, 101, 99, 116, 41, 44, 32, 111, 114, 32, 112, 97, 115, 115, 32, 39, 105, 103, 110, 111, 114, 101, 39, 32, 116, 111, 32, 105, 103, 110, 111, 114, 101, 10, 101, 114, 114, 111, 114, 115, 46, 32, 40, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 105, 103, 110, 111, 114, 105, 110, 103, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 115, 32, 99, 97, 110, 32, 108, 101, 97, 100, 32, 116, 111, 32, 100, 97, 116, 97, 32, 108, 111, 115, 115, 46, 41, 10, 83, 101, 101, 32, 116, 104, 101, 32, 100, 111, 99, 117, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 102, 111, 114, 32, 99, 111, 100, 101, 99, 115, 46, 114, 101, 103, 105, 115, 116, 101, 114, 32, 102, 111, 114, 32, 97, 32, 108, 105, 115, 116, 32, 111, 102, 32, 116, 104, 101, 32, 112, 101, 114, 109, 105, 116, 116, 101, 100, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 32, 115, 116, 114, 105, 110, 103, 115, 46, 10, 10, 110, 101, 119, 108, 105, 110, 101, 32, 99, 111, 110, 116, 114, 111, 108, 115, 32, 104, 111, 119, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 119, 111, 114, 107, 115, 32, 40, 105, 116, 32, 111, 110, 108, 121, 32, 97, 112, 112, 108, 105, 101, 115, 32, 116, 111, 32, 116, 101, 120, 116, 10, 109, 111, 100, 101, 41, 46, 32, 73, 116, 32, 99, 97, 110, 32, 98, 101, 32, 78, 111, 110, 101, 44, 32, 39, 39, 44, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 32, 97, 110, 100, 32, 39, 92, 114, 92, 110, 39, 46, 32, 32, 73, 116, 32, 119, 111, 114, 107, 115, 32, 97, 115, 10, 102, 111, 108, 108, 111, 119, 115, 58, 10, 10, 42, 32, 79, 110, 32, 105, 110, 112, 117, 116, 44, 32, 105, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 78, 111, 110, 101, 44, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 109, 111, 100, 101, 32, 105, 115, 10, 32, 32, 101, 110, 97, 98, 108, 101, 100, 46, 32, 76, 105, 110, 101, 115, 32, 105, 110, 32, 116, 104, 101, 32, 105, 110, 112, 117, 116, 32, 99, 97, 110, 32, 101, 110, 100, 32, 105, 110, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 32, 111, 114, 32, 39, 92, 114, 92, 110, 39, 44, 32, 97, 110, 100, 10, 32, 32, 116, 104, 101, 115, 101, 32, 97, 114, 101, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 105, 110, 116, 111, 32, 39, 92, 110, 39, 32, 98, 101, 102, 111, 114, 101, 32, 98, 101, 105, 110, 103, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 10, 32, 32, 99, 97, 108, 108, 101, 114, 46, 32, 73, 102, 32, 105, 116, 32, 105, 115, 32, 39, 39, 44, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 109, 111, 100, 101, 32, 105, 115, 32, 101, 110, 97, 98, 108, 101, 100, 44, 32, 98, 117, 116, 32, 108, 105, 110, 101, 10, 32, 32, 101, 110, 100, 105, 110, 103, 115, 32, 97, 114, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 99, 97, 108, 108, 101, 114, 32, 117, 110, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 46, 32, 73, 102, 32, 105, 116, 32, 104, 97, 115, 32, 97, 110, 121, 32, 111, 102, 10, 32, 32, 116, 104, 101, 32, 111, 116, 104, 101, 114, 32, 108, 101, 103, 97, 108, 32, 118, 97, 108, 117, 101, 115, 44, 32, 105, 110, 112, 117, 116, 32, 108, 105, 110, 101, 115, 32, 97, 114, 101, 32, 111, 110, 108, 121, 32, 116, 101, 114, 109, 105, 110, 97, 116, 101, 100, 32, 98, 121, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 10, 32, 32, 115, 116, 114, 105, 110, 103, 44, 32, 97, 110, 100, 32, 116, 104, 101, 32, 108, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 99, 97, 108, 108, 101, 114, 32, 117, 110, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 46, 10, 10, 42, 32, 79, 110, 32, 111, 117, 116, 112, 117, 116, 44, 32, 105, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 78, 111, 110, 101, 44, 32, 97, 110, 121, 32, 39, 92, 110, 39, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 32, 97, 114, 101, 10, 32, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 115, 121, 115, 116, 101, 109, 32, 100, 101, 102, 97, 117, 108, 116, 32, 108, 105, 110, 101, 32, 115, 101, 112, 97, 114, 97, 116, 111, 114, 44, 32, 111, 115, 46, 108, 105, 110, 101, 115, 101, 112, 46, 32, 73, 102, 10, 32, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 39, 39, 44, 32, 110, 111, 32, 116, 114, 97, 110, 115, 108, 97, 116, 105, 111, 110, 32, 116, 97, 107, 101, 115, 32, 112, 108, 97, 99, 101, 46, 32, 73, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 97, 110, 121, 32, 111, 102, 32, 116, 104, 101, 10, 32, 32, 111, 116, 104, 101, 114, 32, 108, 101, 103, 97, 108, 32, 118, 97, 108, 117, 101, 115, 44, 32, 97, 110, 121, 32, 39, 92, 110, 39, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 32, 97, 114, 101, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 10, 32, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 99, 108, 111, 115, 101, 102, 100, 32, 105, 115, 32, 70, 97, 108, 115, 101, 44, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 119, 105, 108, 108, 32, 98, 101, 32, 107, 101, 112, 116, 32, 111, 112, 101, 110, 10, 119, 104, 101, 110, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 46, 32, 84, 104, 105, 115, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 119, 111, 114, 107, 32, 119, 104, 101, 110, 32, 97, 32, 102, 105, 108, 101, 32, 110, 97, 109, 101, 32, 105, 115, 32, 103, 105, 118, 101, 110, 10, 97, 110, 100, 32, 109, 117, 115, 116, 32, 98, 101, 32, 84, 114, 117, 101, 32, 105, 110, 32, 116, 104, 97, 116, 32, 99, 97, 115, 101, 46, 10, 10, 111, 112, 101, 110, 40, 41, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 102, 105, 108, 101, 32, 111, 98, 106, 101, 99, 116, 32, 119, 104, 111, 115, 101, 32, 116, 121, 112, 101, 32, 100, 101, 112, 101, 110, 100, 115, 32, 111, 110, 32, 116, 104, 101, 32, 109, 111, 100, 101, 44, 32, 97, 110, 100, 10, 116, 104, 114, 111, 117, 103, 104, 32, 119, 104, 105, 99, 104, 32, 116, 104, 101, 32, 115, 116, 97, 110, 100, 97, 114, 100, 32, 102, 105, 108, 101, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 32, 115, 117, 99, 104, 32, 97, 115, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 10, 97, 114, 101, 32, 112, 101, 114, 102, 111, 114, 109, 101, 100, 46, 32, 87, 104, 101, 110, 32, 111, 112, 101, 110, 40, 41, 32, 105, 115, 32, 117, 115, 101, 100, 32, 116, 111, 32, 111, 112, 101, 110, 32, 97, 32, 102, 105, 108, 101, 32, 105, 110, 32, 97, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 32, 40, 39, 119, 39, 44, 10, 39, 114, 39, 44, 32, 39, 119, 116, 39, 44, 32, 39, 114, 116, 39, 44, 32, 101, 116, 99, 46, 41, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 46, 32, 87, 104, 101, 110, 32, 117, 115, 101, 100, 32, 116, 111, 32, 111, 112, 101, 110, 10, 97, 32, 102, 105, 108, 101, 32, 105, 110, 32, 97, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 44, 32, 116, 104, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 99, 108, 97, 115, 115, 32, 118, 97, 114, 105, 101, 115, 58, 32, 105, 110, 32, 114, 101, 97, 100, 32, 98, 105, 110, 97, 114, 121, 10, 109, 111, 100, 101, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 59, 32, 105, 110, 32, 119, 114, 105, 116, 101, 32, 98, 105, 110, 97, 114, 121, 32, 97, 110, 100, 32, 97, 112, 112, 101, 110, 100, 32, 98, 105, 110, 97, 114, 121, 10, 109, 111, 100, 101, 115, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 44, 32, 97, 110, 100, 32, 105, 110, 32, 114, 101, 97, 100, 47, 119, 114, 105, 116, 101, 32, 109, 111, 100, 101, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 10, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 46, 10, 10, 73, 116, 32, 105, 115, 32, 97, 108, 115, 111, 32, 112, 111, 115, 115, 105, 98, 108, 101, 32, 116, 111, 32, 117, 115, 101, 32, 97, 32, 115, 116, 114, 105, 110, 103, 32, 111, 114, 32, 98, 121, 116, 101, 97, 114, 114, 97, 121, 32, 97, 115, 32, 97, 32, 102, 105, 108, 101, 32, 102, 111, 114, 32, 98, 111, 116, 104, 10, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 46, 32, 70, 111, 114, 32, 115, 116, 114, 105, 110, 103, 115, 32, 83, 116, 114, 105, 110, 103, 73, 79, 32, 99, 97, 110, 32, 98, 101, 32, 117, 115, 101, 100, 32, 108, 105, 107, 101, 32, 97, 32, 102, 105, 108, 101, 10, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 44, 32, 97, 110, 100, 32, 102, 111, 114, 32, 98, 121, 116, 101, 115, 32, 97, 32, 66, 121, 116, 101, 115, 73, 79, 32, 99, 97, 110, 32, 98, 101, 32, 117, 115, 101, 100, 32, 108, 105, 107, 101, 32, 97, 32, 102, 105, 108, 101, 10, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str6239 = allocate([ 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str7240 = allocate([ 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str8241 = allocate([ 98, 117, 102, 102, 101, 114, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str9242 = allocate([ 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str10243 = allocate([ 101, 114, 114, 111, 114, 115, 0 ], "i8", ALLOC_NORMAL);
    __str11244 = allocate([ 110, 101, 119, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str12245 = allocate([ 99, 108, 111, 115, 101, 102, 100, 0 ], "i8", ALLOC_NORMAL);
    __str13246 = allocate([ 114, 0 ], "i8", ALLOC_NORMAL);
    __str14247 = allocate([ 79, 124, 115, 105, 122, 122, 122, 105, 58, 111, 112, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    __str15248 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 102, 105, 108, 101, 58, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str16249 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 109, 111, 100, 101, 58, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str17250 = allocate([ 99, 97, 110, 39, 116, 32, 117, 115, 101, 32, 85, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 32, 109, 111, 100, 101, 32, 97, 116, 32, 111, 110, 99, 101, 0 ], "i8", ALLOC_NORMAL);
    __str18251 = allocate([ 99, 97, 110, 39, 116, 32, 104, 97, 118, 101, 32, 116, 101, 120, 116, 32, 97, 110, 100, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 97, 116, 32, 111, 110, 99, 101, 0 ], "i8", ALLOC_NORMAL);
    __str19252 = allocate([ 109, 117, 115, 116, 32, 104, 97, 118, 101, 32, 101, 120, 97, 99, 116, 108, 121, 32, 111, 110, 101, 32, 111, 102, 32, 114, 101, 97, 100, 47, 119, 114, 105, 116, 101, 47, 97, 112, 112, 101, 110, 100, 32, 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str20253 = allocate([ 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 100, 111, 101, 115, 110, 39, 116, 32, 116, 97, 107, 101, 32, 97, 110, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0 ], "i8", ALLOC_NORMAL);
    __str21254 = allocate([ 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 100, 111, 101, 115, 110, 39, 116, 32, 116, 97, 107, 101, 32, 97, 110, 32, 101, 114, 114, 111, 114, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0 ], "i8", ALLOC_NORMAL);
    __str22255 = allocate([ 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 100, 111, 101, 115, 110, 39, 116, 32, 116, 97, 107, 101, 32, 97, 32, 110, 101, 119, 108, 105, 110, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0 ], "i8", ALLOC_NORMAL);
    __str23256 = allocate([ 79, 115, 105, 0 ], "i8", ALLOC_NORMAL);
    __str24257 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str25258 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    __str26259 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    __str27260 = allocate([ 99, 97, 110, 39, 116, 32, 104, 97, 118, 101, 32, 117, 110, 98, 117, 102, 102, 101, 114, 101, 100, 32, 116, 101, 120, 116, 32, 73, 47, 79, 0 ], "i8", ALLOC_NORMAL);
    __str28261 = allocate([ 117, 110, 107, 110, 111, 119, 110, 32, 109, 111, 100, 101, 58, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str29262 = allocate([ 79, 105, 0 ], "i8", ALLOC_NORMAL);
    __str30263 = allocate([ 79, 115, 115, 115, 105, 0 ], "i8", ALLOC_NORMAL);
    __str31264 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 118, 97, 108, 117, 101, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 52, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8811 = allocate([ 80, 121, 78, 117, 109, 98, 101, 114, 95, 65, 115, 79, 102, 102, 95, 116, 0 ], "i8", ALLOC_NORMAL);
    __str32265 = allocate([ 99, 97, 110, 110, 111, 116, 32, 102, 105, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 32, 105, 110, 116, 111, 32, 97, 110, 32, 111, 102, 102, 115, 101, 116, 45, 115, 105, 122, 101, 100, 32, 105, 110, 116, 101, 103, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str33266 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_os_module = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_locale_module = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_unsupported_operation = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str34268 = allocate([ 111, 112, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    _module_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str35269 = allocate([ 95, 105, 111, 0 ], "i8", ALLOC_NORMAL);
    __str36270 = allocate([ 111, 115, 0 ], "i8", ALLOC_NORMAL);
    __str37271 = allocate([ 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 0 ], "i8", ALLOC_NORMAL);
    __str38272 = allocate([ 115, 40, 79, 79, 41, 123, 125, 0 ], "i8", ALLOC_NORMAL);
    __str39273 = allocate([ 85, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100, 79, 112, 101, 114, 97, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    __str40274 = allocate([ 95, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str41275 = allocate([ 95, 82, 97, 119, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str42276 = allocate([ 95, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str43277 = allocate([ 95, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44278 = allocate([ 70, 105, 108, 101, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str45279 = allocate([ 66, 121, 116, 101, 115, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str46280 = allocate([ 83, 116, 114, 105, 110, 103, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str47281 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str48282 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str49283 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 0 ], "i8", ALLOC_NORMAL);
    __str50284 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 0 ], "i8", ALLOC_NORMAL);
    __str51285 = allocate([ 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str52286 = allocate([ 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str53287 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_close = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str54289 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_closed = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str55291 = allocate([ 100, 101, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_decode = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str56292 = allocate([ 101, 110, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_encode = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_str_fileno = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str57294 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_flush = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str58296 = allocate([ 103, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_getstate = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_str_isatty = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str59298 = allocate([ 110, 101, 119, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_newlines = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str60299 = allocate([ 10, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_nl = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str61300 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_read = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str62302 = allocate([ 114, 101, 97, 100, 49, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_read1 = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str63303 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_readable = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str64305 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_readinto = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str65307 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_readline = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str66309 = allocate([ 114, 101, 115, 101, 116, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_reset = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str67 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_seek = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str68 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_seekable = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str69 = allocate([ 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_setstate = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str70 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_tell = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str71 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_truncate = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str72 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_write = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str73 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_writable = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_empty_str = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_empty_bytes = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_zero = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    _stringio_doc = allocate([ 84, 101, 120, 116, 32, 73, 47, 79, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 117, 115, 105, 110, 103, 32, 97, 110, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 98, 117, 102, 102, 101, 114, 46, 10, 10, 84, 104, 101, 32, 105, 110, 105, 116, 105, 97, 108, 95, 118, 97, 108, 117, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 101, 116, 115, 32, 116, 104, 101, 32, 118, 97, 108, 117, 101, 32, 111, 102, 32, 111, 98, 106, 101, 99, 116, 46, 32, 32, 84, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 10, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 108, 105, 107, 101, 32, 116, 104, 101, 32, 111, 110, 101, 32, 111, 102, 32, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 39, 115, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    __str319 = allocate([ 115, 101, 108, 102, 45, 62, 98, 117, 102, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str1320 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 115, 116, 114, 105, 110, 103, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8442 = allocate([ 114, 101, 115, 105, 122, 101, 95, 98, 117, 102, 102, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str2321 = allocate([ 110, 101, 119, 32, 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8484 = allocate([ 119, 114, 105, 116, 101, 95, 115, 116, 114, 0 ], "i8", ALLOC_NORMAL);
    __str3322 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    __str4323 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 100, 101, 99, 111, 100, 101, 100, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 56, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str5324 = allocate([ 108, 101, 110, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    __str6325 = allocate([ 110, 101, 119, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    _stringio_getvalue_doc = allocate([ 82, 101, 116, 114, 105, 101, 118, 101, 32, 116, 104, 101, 32, 101, 110, 116, 105, 114, 101, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 111, 102, 32, 116, 104, 101, 32, 111, 98, 106, 101, 99, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    __str8327 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    _stringio_tell_doc = allocate([ 84, 101, 108, 108, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    _stringio_read_doc = allocate([ 82, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 110, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 32, 111, 114, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 10, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 46, 32, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str9328 = allocate([ 124, 79, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str10329 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str11330 = allocate(1, "i8", ALLOC_NORMAL);
    _stringio_readline_doc = allocate([ 82, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 111, 114, 32, 69, 79, 70, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 105, 102, 32, 69, 79, 70, 32, 105, 115, 32, 104, 105, 116, 32, 105, 109, 109, 101, 100, 105, 97, 116, 101, 108, 121, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str12331 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str13332 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 110, 32, 115, 116, 114, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    _stringio_truncate_doc = allocate([ 84, 114, 117, 110, 99, 97, 116, 101, 32, 115, 105, 122, 101, 32, 116, 111, 32, 112, 111, 115, 46, 10, 10, 84, 104, 101, 32, 112, 111, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 115, 10, 114, 101, 116, 117, 114, 110, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 32, 32, 84, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 115, 32, 117, 110, 99, 104, 97, 110, 103, 101, 100, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str14333 = allocate([ 124, 79, 58, 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str15334 = allocate([ 78, 101, 103, 97, 116, 105, 118, 101, 32, 115, 105, 122, 101, 32, 118, 97, 108, 117, 101, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    _stringio_seek_doc = allocate([ 67, 104, 97, 110, 103, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 83, 101, 101, 107, 32, 116, 111, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 32, 111, 102, 102, 115, 101, 116, 32, 112, 111, 115, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 110, 100, 105, 99, 97, 116, 101, 100, 32, 98, 121, 32, 119, 104, 101, 110, 99, 101, 58, 10, 32, 32, 32, 32, 48, 32, 32, 83, 116, 97, 114, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 41, 46, 32, 32, 112, 111, 115, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 62, 61, 32, 48, 59, 10, 32, 32, 32, 32, 49, 32, 32, 67, 117, 114, 114, 101, 110, 116, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 45, 32, 112, 111, 115, 32, 109, 117, 115, 116, 32, 98, 101, 32, 48, 59, 10, 32, 32, 32, 32, 50, 32, 32, 69, 110, 100, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 45, 32, 112, 111, 115, 32, 109, 117, 115, 116, 32, 98, 101, 32, 48, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str16335 = allocate([ 79, 124, 105, 58, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str17336 = allocate([ 73, 110, 118, 97, 108, 105, 100, 32, 119, 104, 101, 110, 99, 101, 32, 40, 37, 105, 44, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 48, 44, 32, 49, 32, 111, 114, 32, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str18337 = allocate([ 78, 101, 103, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    __str19338 = allocate([ 67, 97, 110, 39, 116, 32, 100, 111, 32, 110, 111, 110, 122, 101, 114, 111, 32, 99, 117, 114, 45, 114, 101, 108, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 115, 0 ], "i8", ALLOC_NORMAL);
    _stringio_write_doc = allocate([ 87, 114, 105, 116, 101, 32, 115, 116, 114, 105, 110, 103, 32, 116, 111, 32, 102, 105, 108, 101, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 44, 32, 119, 104, 105, 99, 104, 32, 105, 115, 32, 97, 108, 119, 97, 121, 115, 32, 101, 113, 117, 97, 108, 32, 116, 111, 10, 116, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 101, 32, 115, 116, 114, 105, 110, 103, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str20339 = allocate([ 115, 116, 114, 105, 110, 103, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    _stringio_close_doc = allocate([ 67, 108, 111, 115, 101, 32, 116, 104, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 32, 65, 116, 116, 101, 109, 112, 116, 105, 110, 103, 32, 97, 110, 121, 32, 102, 117, 114, 116, 104, 101, 114, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 97, 102, 116, 101, 114, 32, 116, 104, 101, 10, 111, 98, 106, 101, 99, 116, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 97, 32, 86, 97, 108, 117, 101, 69, 114, 114, 111, 114, 46, 10, 10, 84, 104, 105, 115, 32, 109, 101, 116, 104, 111, 100, 32, 104, 97, 115, 32, 110, 111, 32, 101, 102, 102, 101, 99, 116, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 97, 108, 114, 101, 97, 100, 121, 32, 99, 108, 111, 115, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str21340 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9021 = allocate([ 115, 116, 114, 105, 110, 103, 105, 111, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str22341 = allocate([ 116, 121, 112, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 38, 38, 32, 116, 121, 112, 101, 45, 62, 116, 112, 95, 97, 108, 108, 111, 99, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9091 = allocate([ 115, 116, 114, 105, 110, 103, 105, 111, 95, 110, 101, 119, 0 ], "i8", ALLOC_NORMAL);
    __str23342 = allocate([ 105, 110, 105, 116, 105, 97, 108, 95, 118, 97, 108, 117, 101, 0 ], "i8", ALLOC_NORMAL);
    __str24343 = allocate([ 110, 101, 119, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str25344 = allocate([ 10, 0 ], "i8", ALLOC_NORMAL);
    __str26345 = allocate([ 124, 79, 122, 58, 95, 95, 105, 110, 105, 116, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str27346 = allocate([ 105, 108, 108, 101, 103, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 118, 97, 108, 117, 101, 58, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str28347 = allocate([ 105, 110, 105, 116, 105, 97, 108, 95, 118, 97, 108, 117, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 117, 110, 105, 99, 111, 100, 101, 32, 111, 114, 32, 78, 111, 110, 101, 44, 32, 110, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str29348 = allocate([ 79, 105, 0 ], "i8", ALLOC_NORMAL);
    __str30349 = allocate([ 40, 79, 79, 110, 78, 41, 0 ], "i8", ALLOC_NORMAL);
    __str31350 = allocate([ 115, 116, 97, 116, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9352 = allocate([ 115, 116, 114, 105, 110, 103, 105, 111, 95, 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str32351 = allocate([ 37, 46, 50, 48, 48, 115, 46, 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 52, 45, 116, 117, 112, 108, 101, 44, 32, 103, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str33352 = allocate([ 116, 104, 105, 114, 100, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 44, 32, 103, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str34353 = allocate([ 112, 111, 115, 105, 116, 105, 111, 110, 32, 118, 97, 108, 117, 101, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    __str35354 = allocate([ 102, 111, 117, 114, 116, 104, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 97, 32, 100, 105, 99, 116, 44, 32, 103, 111, 116, 32, 97, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str36355 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37356 = allocate([ 103, 101, 116, 118, 97, 108, 117, 101, 0 ], "i8", ALLOC_NORMAL);
    __str38357 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str39358 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str40359 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str41360 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str42361 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str43362 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44363 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str45364 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str46365 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str47366 = allocate([ 95, 95, 103, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str48367 = allocate([ 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    _stringio_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str49368 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str50369 = allocate([ 110, 101, 119, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str51370 = allocate([ 108, 105, 110, 101, 95, 98, 117, 102, 102, 101, 114, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    _stringio_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str52371 = allocate([ 95, 105, 111, 46, 83, 116, 114, 105, 110, 103, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    _PyStringIO_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _textiobase_doc = allocate([ 66, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 116, 101, 120, 116, 32, 73, 47, 79, 46, 10, 10, 84, 104, 105, 115, 32, 99, 108, 97, 115, 115, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 97, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 32, 97, 110, 100, 32, 108, 105, 110, 101, 32, 98, 97, 115, 101, 100, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 10, 73, 47, 79, 46, 32, 84, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 32, 114, 101, 97, 100, 105, 110, 116, 111, 32, 109, 101, 116, 104, 111, 100, 32, 98, 101, 99, 97, 117, 115, 101, 32, 80, 121, 116, 104, 111, 110, 39, 115, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 32, 115, 116, 114, 105, 110, 103, 115, 10, 97, 114, 101, 32, 105, 109, 109, 117, 116, 97, 98, 108, 101, 46, 32, 84, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 32, 112, 117, 98, 108, 105, 99, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_detach_doc = allocate([ 83, 101, 112, 97, 114, 97, 116, 101, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 105, 116, 46, 10, 10, 65, 102, 116, 101, 114, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 44, 32, 116, 104, 101, 32, 84, 101, 120, 116, 73, 79, 32, 105, 115, 32, 105, 110, 32, 97, 110, 10, 117, 110, 117, 115, 97, 98, 108, 101, 32, 115, 116, 97, 116, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_read_doc = allocate([ 82, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 110, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 102, 114, 111, 109, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 82, 101, 97, 100, 32, 102, 114, 111, 109, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 117, 110, 116, 105, 108, 32, 119, 101, 32, 104, 97, 118, 101, 32, 110, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 111, 114, 32, 119, 101, 32, 104, 105, 116, 32, 69, 79, 70, 46, 10, 73, 102, 32, 110, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 32, 111, 114, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str1375 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_readline_doc = allocate([ 82, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 111, 114, 32, 69, 79, 70, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 105, 102, 32, 69, 79, 70, 32, 105, 115, 32, 104, 105, 116, 32, 105, 109, 109, 101, 100, 105, 97, 116, 101, 108, 121, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str2376 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_write_doc = allocate([ 87, 114, 105, 116, 101, 32, 115, 116, 114, 105, 110, 103, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 32, 40, 119, 104, 105, 99, 104, 32, 105, 115, 32, 97, 108, 119, 97, 121, 115, 32, 101, 113, 117, 97, 108, 32, 116, 111, 10, 116, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 101, 32, 115, 116, 114, 105, 110, 103, 41, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str3377 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_encoding_doc = allocate([ 69, 110, 99, 111, 100, 105, 110, 103, 32, 111, 102, 32, 116, 104, 101, 32, 116, 101, 120, 116, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 83, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 118, 101, 114, 114, 105, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_newlines_doc = allocate([ 76, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 115, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 115, 111, 32, 102, 97, 114, 46, 10, 10, 79, 110, 108, 121, 32, 108, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 115, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 100, 117, 114, 105, 110, 103, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 114, 101, 32, 99, 111, 110, 115, 105, 100, 101, 114, 101, 100, 46, 10, 10, 83, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 118, 101, 114, 114, 105, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_errors_doc = allocate([ 84, 104, 101, 32, 101, 114, 114, 111, 114, 32, 115, 101, 116, 116, 105, 110, 103, 32, 111, 102, 32, 116, 104, 101, 32, 100, 101, 99, 111, 100, 101, 114, 32, 111, 114, 32, 101, 110, 99, 111, 100, 101, 114, 46, 10, 10, 83, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 118, 101, 114, 114, 105, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str4378 = allocate([ 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str5379 = allocate([ 110, 101, 119, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str6380 = allocate([ 101, 114, 114, 111, 114, 115, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str7381 = allocate([ 95, 105, 111, 46, 95, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyTextIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _incrementalnewlinedecoder_doc = allocate([ 67, 111, 100, 101, 99, 32, 117, 115, 101, 100, 32, 119, 104, 101, 110, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 32, 102, 105, 108, 101, 32, 105, 110, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 109, 111, 100, 101, 46, 32, 32, 73, 116, 32, 119, 114, 97, 112, 115, 10, 97, 110, 111, 116, 104, 101, 114, 32, 105, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 32, 100, 101, 99, 111, 100, 101, 114, 44, 32, 116, 114, 97, 110, 115, 108, 97, 116, 105, 110, 103, 32, 92, 114, 92, 110, 32, 97, 110, 100, 32, 92, 114, 32, 105, 110, 116, 111, 32, 92, 110, 46, 32, 32, 73, 116, 32, 97, 108, 115, 111, 10, 114, 101, 99, 111, 114, 100, 115, 32, 116, 104, 101, 32, 116, 121, 112, 101, 115, 32, 111, 102, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 101, 110, 99, 111, 117, 110, 116, 101, 114, 101, 100, 46, 32, 32, 87, 104, 101, 110, 32, 117, 115, 101, 100, 32, 119, 105, 116, 104, 10, 116, 114, 97, 110, 115, 108, 97, 116, 101, 61, 70, 97, 108, 115, 101, 44, 32, 105, 116, 32, 101, 110, 115, 117, 114, 101, 115, 32, 116, 104, 97, 116, 32, 116, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 10, 111, 110, 101, 32, 112, 105, 101, 99, 101, 46, 32, 87, 104, 101, 110, 32, 117, 115, 101, 100, 32, 119, 105, 116, 104, 32, 100, 101, 99, 111, 100, 101, 114, 61, 78, 111, 110, 101, 44, 32, 105, 116, 32, 101, 120, 112, 101, 99, 116, 115, 32, 117, 110, 105, 99, 111, 100, 101, 32, 115, 116, 114, 105, 110, 103, 115, 32, 97, 115, 10, 100, 101, 99, 111, 100, 101, 32, 105, 110, 112, 117, 116, 32, 97, 110, 100, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 115, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 119, 105, 116, 104, 111, 117, 116, 32, 102, 105, 114, 115, 116, 32, 105, 110, 118, 111, 107, 105, 110, 103, 32, 97, 110, 32, 101, 120, 116, 101, 114, 110, 97, 108, 10, 100, 101, 99, 111, 100, 101, 114, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str8383 = allocate([ 100, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str9384 = allocate([ 116, 114, 97, 110, 115, 108, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str10385 = allocate([ 79, 105, 124, 79, 58, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str11386 = allocate([ 115, 116, 114, 105, 99, 116, 0 ], "i8", ALLOC_NORMAL);
    __str12387 = allocate([ 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 46, 95, 95, 105, 110, 105, 116, 95, 95, 32, 110, 111, 116, 32, 99, 97, 108, 108, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str13388 = allocate([ 100, 101, 99, 111, 100, 101, 114, 32, 115, 104, 111, 117, 108, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 115, 116, 114, 105, 110, 103, 32, 114, 101, 115, 117, 108, 116, 0 ], "i8", ALLOC_NORMAL);
    __str14389 = allocate([ 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 41, 41, 45, 62, 111, 98, 95, 114, 101, 102, 99, 110, 116, 41, 32, 61, 61, 32, 49, 0 ], "i8", ALLOC_NORMAL);
    __str15390 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 116, 101, 120, 116, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8596 = allocate([ 95, 80, 121, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 95, 100, 101, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str16391 = allocate([ 105, 110, 112, 117, 116, 0 ], "i8", ALLOC_NORMAL);
    __str17392 = allocate([ 102, 105, 110, 97, 108, 0 ], "i8", ALLOC_NORMAL);
    __str18393 = allocate([ 79, 124, 105, 58, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str19394 = allocate([ 40, 79, 75, 41, 0 ], "i8", ALLOC_NORMAL);
    __str20395 = allocate(1, "i8", ALLOC_NORMAL);
    __str21396 = allocate([ 78, 75, 0 ], "i8", ALLOC_NORMAL);
    __str22397 = allocate([ 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str23398 = allocate([ 40, 40, 79, 75, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    __str24399 = allocate([ 13, 0 ], "i8", ALLOC_NORMAL);
    __str25400 = allocate([ 10, 0 ], "i8", ALLOC_NORMAL);
    __str26401 = allocate([ 13, 10, 0 ], "i8", ALLOC_NORMAL);
    __str27402 = allocate([ 115, 115, 0 ], "i8", ALLOC_NORMAL);
    __str28403 = allocate([ 115, 115, 115, 0 ], "i8", ALLOC_NORMAL);
    __str29404 = allocate([ 100, 101, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str30405 = allocate([ 103, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str31406 = allocate([ 114, 101, 115, 101, 116, 0 ], "i8", ALLOC_NORMAL);
    _incrementalnewlinedecoder_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _incrementalnewlinedecoder_getset = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str32407 = allocate([ 95, 105, 111, 46, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyIncrementalNewlineDecoder_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _textiowrapper_doc = allocate([ 67, 104, 97, 114, 97, 99, 116, 101, 114, 32, 97, 110, 100, 32, 108, 105, 110, 101, 32, 98, 97, 115, 101, 100, 32, 108, 97, 121, 101, 114, 32, 111, 118, 101, 114, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 32, 111, 98, 106, 101, 99, 116, 44, 32, 98, 117, 102, 102, 101, 114, 46, 10, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 103, 105, 118, 101, 115, 32, 116, 104, 101, 32, 110, 97, 109, 101, 32, 111, 102, 32, 116, 104, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 116, 104, 97, 116, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 32, 119, 105, 108, 108, 32, 98, 101, 10, 100, 101, 99, 111, 100, 101, 100, 32, 111, 114, 32, 101, 110, 99, 111, 100, 101, 100, 32, 119, 105, 116, 104, 46, 32, 73, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 108, 111, 99, 97, 108, 101, 46, 103, 101, 116, 112, 114, 101, 102, 101, 114, 114, 101, 100, 101, 110, 99, 111, 100, 105, 110, 103, 46, 10, 10, 101, 114, 114, 111, 114, 115, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 115, 32, 116, 104, 101, 32, 115, 116, 114, 105, 99, 116, 110, 101, 115, 115, 32, 111, 102, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 97, 110, 100, 32, 100, 101, 99, 111, 100, 105, 110, 103, 32, 40, 115, 101, 101, 32, 116, 104, 101, 10, 99, 111, 100, 101, 99, 115, 46, 114, 101, 103, 105, 115, 116, 101, 114, 41, 32, 97, 110, 100, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 34, 115, 116, 114, 105, 99, 116, 34, 46, 10, 10, 110, 101, 119, 108, 105, 110, 101, 32, 99, 97, 110, 32, 98, 101, 32, 78, 111, 110, 101, 44, 32, 39, 39, 44, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 32, 111, 114, 32, 39, 92, 114, 92, 110, 39, 46, 32, 32, 73, 116, 32, 99, 111, 110, 116, 114, 111, 108, 115, 32, 116, 104, 101, 10, 104, 97, 110, 100, 108, 105, 110, 103, 32, 111, 102, 32, 108, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 115, 46, 32, 73, 102, 32, 105, 116, 32, 105, 115, 32, 78, 111, 110, 101, 44, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 105, 115, 10, 101, 110, 97, 98, 108, 101, 100, 46, 32, 32, 87, 105, 116, 104, 32, 116, 104, 105, 115, 32, 101, 110, 97, 98, 108, 101, 100, 44, 32, 111, 110, 32, 105, 110, 112, 117, 116, 44, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 101, 110, 100, 105, 110, 103, 115, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 10, 111, 114, 32, 39, 92, 114, 92, 110, 39, 32, 97, 114, 101, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 32, 39, 92, 110, 39, 32, 98, 101, 102, 111, 114, 101, 32, 98, 101, 105, 110, 103, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 10, 99, 97, 108, 108, 101, 114, 46, 32, 67, 111, 110, 118, 101, 114, 115, 101, 108, 121, 44, 32, 111, 110, 32, 111, 117, 116, 112, 117, 116, 44, 32, 39, 92, 110, 39, 32, 105, 115, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 115, 121, 115, 116, 101, 109, 10, 100, 101, 102, 97, 117, 108, 116, 32, 108, 105, 110, 101, 32, 115, 101, 112, 101, 114, 97, 116, 111, 114, 44, 32, 111, 115, 46, 108, 105, 110, 101, 115, 101, 112, 46, 32, 73, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 97, 110, 121, 32, 111, 116, 104, 101, 114, 32, 111, 102, 32, 105, 116, 115, 10, 108, 101, 103, 97, 108, 32, 118, 97, 108, 117, 101, 115, 44, 32, 116, 104, 97, 116, 32, 110, 101, 119, 108, 105, 110, 101, 32, 98, 101, 99, 111, 109, 101, 115, 32, 116, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 32, 119, 104, 101, 110, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 114, 101, 97, 100, 10, 97, 110, 100, 32, 105, 116, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 117, 110, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 46, 32, 79, 110, 32, 111, 117, 116, 112, 117, 116, 44, 32, 39, 92, 110, 39, 32, 105, 115, 32, 99, 111, 110, 118, 101, 114, 116, 101, 100, 32, 116, 111, 32, 116, 104, 101, 10, 110, 101, 119, 108, 105, 110, 101, 46, 10, 10, 73, 102, 32, 108, 105, 110, 101, 95, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 105, 115, 32, 84, 114, 117, 101, 44, 32, 97, 32, 99, 97, 108, 108, 32, 116, 111, 32, 102, 108, 117, 115, 104, 32, 105, 115, 32, 105, 109, 112, 108, 105, 101, 100, 32, 119, 104, 101, 110, 32, 97, 32, 99, 97, 108, 108, 32, 116, 111, 10, 119, 114, 105, 116, 101, 32, 99, 111, 110, 116, 97, 105, 110, 115, 32, 97, 32, 110, 101, 119, 108, 105, 110, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    _encodefuncs = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0 ], ALLOC_NORMAL);
    __str33409 = allocate([ 97, 115, 99, 105, 105, 0 ], "i8", ALLOC_NORMAL);
    __str34410 = allocate([ 105, 115, 111, 56, 56, 53, 57, 45, 49, 0 ], "i8", ALLOC_NORMAL);
    __str35411 = allocate([ 117, 116, 102, 45, 56, 0 ], "i8", ALLOC_NORMAL);
    __str36412 = allocate([ 117, 116, 102, 45, 49, 54, 45, 98, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37413 = allocate([ 117, 116, 102, 45, 49, 54, 45, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str38414 = allocate([ 117, 116, 102, 45, 49, 54, 0 ], "i8", ALLOC_NORMAL);
    __str39415 = allocate([ 117, 116, 102, 45, 51, 50, 45, 98, 101, 0 ], "i8", ALLOC_NORMAL);
    __str40416 = allocate([ 117, 116, 102, 45, 51, 50, 45, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str41417 = allocate([ 117, 116, 102, 45, 51, 50, 0 ], "i8", ALLOC_NORMAL);
    __str42418 = allocate([ 98, 117, 102, 102, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str43419 = allocate([ 110, 101, 119, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44420 = allocate([ 108, 105, 110, 101, 95, 98, 117, 102, 102, 101, 114, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str45421 = allocate([ 79, 124, 122, 122, 122, 105, 58, 102, 105, 108, 101, 105, 111, 0 ], "i8", ALLOC_NORMAL);
    __str46422 = allocate([ 105, 108, 108, 101, 103, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 118, 97, 108, 117, 101, 58, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str47423 = allocate([ 108, 111, 99, 97, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str48424 = allocate([ 103, 101, 116, 112, 114, 101, 102, 101, 114, 114, 101, 100, 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str49425 = allocate([ 99, 111, 117, 108, 100, 32, 110, 111, 116, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str50426 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str51427 = allocate([ 79, 105, 0 ], "i8", ALLOC_NORMAL);
    __str52428 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str53429 = allocate([ 110, 97, 109, 101, 0 ], "i8", ALLOC_NORMAL);
    __str55431 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str56432 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9695 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str57433 = allocate([ 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str58434 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 117, 110, 105, 110, 105, 116, 105, 97, 108, 105, 122, 101, 100, 32, 111, 98, 106, 101, 99, 116, 0 ], "i8", ALLOC_NORMAL);
    __str59435 = allocate([ 85, 58, 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str60436 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    __str61437 = allocate([ 110, 111, 116, 32, 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str62438 = allocate([ 114, 101, 112, 108, 97, 99, 101, 0 ], "i8", ALLOC_NORMAL);
    __str63439 = allocate([ 97, 118, 97, 105, 108, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10189 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 103, 101, 116, 95, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 0 ], "i8", ALLOC_NORMAL);
    __str64440 = allocate([ 110, 111, 116, 32, 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str65441 = allocate([ 40, 79, 79, 41, 0 ], "i8", ALLOC_NORMAL);
    __str66442 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 105, 110, 112, 117, 116, 95, 99, 104, 117, 110, 107, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 55, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10233 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 114, 101, 97, 100, 95, 99, 104, 117, 110, 107, 0 ], "i8", ALLOC_NORMAL);
    __str67443 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 110, 101, 120, 116, 95, 105, 110, 112, 117, 116, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 55, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str68444 = allocate([ 78, 78, 0 ], "i8", ALLOC_NORMAL);
    __str70446 = allocate([ 115, 101, 108, 102, 45, 62, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 95, 117, 115, 101, 100, 32, 61, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10735 = allocate([ 95, 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str71447 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str72448 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str73449 = allocate([ 40, 40, 115, 105, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    __str74 = allocate([ 79, 124, 105, 58, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str75 = allocate([ 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str76 = allocate([ 99, 97, 110, 39, 116, 32, 100, 111, 32, 110, 111, 110, 122, 101, 114, 111, 32, 99, 117, 114, 45, 114, 101, 108, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 115, 0 ], "i8", ALLOC_NORMAL);
    __str77 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str78 = allocate([ 99, 97, 110, 39, 116, 32, 100, 111, 32, 110, 111, 110, 122, 101, 114, 111, 32, 101, 110, 100, 45, 114, 101, 108, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 115, 0 ], "i8", ALLOC_NORMAL);
    __str79 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __str80 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str81 = allocate([ 105, 105, 0 ], "i8", ALLOC_NORMAL);
    __str82 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 119, 104, 101, 110, 99, 101, 32, 40, 37, 100, 44, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 48, 44, 32, 49, 32, 111, 114, 32, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str83 = allocate([ 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str84 = allocate([ 105, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___11188 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str85 = allocate([ 105, 78, 0 ], "i8", ALLOC_NORMAL);
    __str86 = allocate([ 99, 97, 110, 39, 116, 32, 114, 101, 115, 116, 111, 114, 101, 32, 108, 111, 103, 105, 99, 97, 108, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    __str87 = allocate([ 105, 115, 0 ], "i8", ALLOC_NORMAL);
    __str88 = allocate([ 116, 101, 108, 108, 105, 110, 103, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 100, 105, 115, 97, 98, 108, 101, 100, 32, 98, 121, 32, 110, 101, 120, 116, 40, 41, 32, 99, 97, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str89 = allocate([ 115, 101, 108, 102, 45, 62, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 32, 61, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 124, 124, 32, 80, 121, 85, 110, 105, 99, 111, 100, 101, 85, 67, 83, 50, 95, 71, 101, 116, 83, 105, 122, 101, 40, 115, 101, 108, 102, 45, 62, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 41, 32, 61, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___11475 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str90 = allocate([ 40, 105, 79, 41, 0 ], "i8", ALLOC_NORMAL);
    __str91 = allocate([ 115, 35, 0 ], "i8", ALLOC_NORMAL);
    __str92 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 100, 101, 99, 111, 100, 101, 100, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 56, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str93 = allocate([ 40, 115, 35, 105, 41, 0 ], "i8", ALLOC_NORMAL);
    __str94 = allocate([ 115, 105, 0 ], "i8", ALLOC_NORMAL);
    __str95 = allocate([ 99, 97, 110, 39, 116, 32, 114, 101, 99, 111, 110, 115, 116, 114, 117, 99, 116, 32, 108, 111, 103, 105, 99, 97, 108, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    __str96 = allocate([ 40, 79, 41, 0 ], "i8", ALLOC_NORMAL);
    __str97 = allocate([ 124, 79, 58, 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str98 = allocate([ 60, 95, 105, 111, 46, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 32, 101, 110, 99, 111, 100, 105, 110, 103, 61, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    __str99 = allocate([ 60, 95, 105, 111, 46, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 32, 110, 97, 109, 101, 61, 37, 115, 32, 101, 110, 99, 111, 100, 105, 110, 103, 61, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    __str100 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    __str101 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str102 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str103 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 110, 32, 115, 116, 114, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str104 = allocate([ 97, 32, 115, 116, 114, 105, 99, 116, 108, 121, 32, 112, 111, 115, 105, 116, 105, 118, 101, 32, 105, 110, 116, 101, 103, 101, 114, 32, 105, 115, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str105 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _textiowrapper_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _textiowrapper_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 24, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 20, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 48, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str106 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str107 = allocate([ 95, 67, 72, 85, 78, 75, 95, 83, 73, 90, 69, 0 ], "i8", ALLOC_NORMAL);
    _textiowrapper_getset = allocate(120, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str108 = allocate([ 95, 105, 111, 46, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyTextIOWrapper_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    HEAP[_bufferediobase_methods] = __str4;
    HEAP[_bufferediobase_methods + 4] = FUNCTION_TABLE_OFFSET + 4;
    HEAP[_bufferediobase_methods + 12] = _bufferediobase_detach_doc;
    HEAP[_bufferediobase_methods + 16] = __str1;
    HEAP[_bufferediobase_methods + 20] = FUNCTION_TABLE_OFFSET + 6;
    HEAP[_bufferediobase_methods + 28] = _bufferediobase_read_doc;
    HEAP[_bufferediobase_methods + 32] = __str5;
    HEAP[_bufferediobase_methods + 36] = FUNCTION_TABLE_OFFSET + 8;
    HEAP[_bufferediobase_methods + 44] = _bufferediobase_read1_doc;
    HEAP[_bufferediobase_methods + 48] = __str7;
    HEAP[_bufferediobase_methods + 52] = FUNCTION_TABLE_OFFSET + 10;
    HEAP[_bufferediobase_methods + 64] = __str6;
    HEAP[_bufferediobase_methods + 68] = FUNCTION_TABLE_OFFSET + 12;
    HEAP[_bufferediobase_methods + 76] = _bufferediobase_write_doc;
    HEAP[_PyBufferedIOBase_Type + 12] = __str8;
    HEAP[_PyBufferedIOBase_Type + 88] = _bufferediobase_doc;
    HEAP[_PyBufferedIOBase_Type + 116] = _bufferediobase_methods;
    HEAP[_PyBufferedIOBase_Type + 128] = _PyIOBase_Type;
    HEAP[_bufferedreader_methods] = __str4;
    HEAP[_bufferedreader_methods + 4] = FUNCTION_TABLE_OFFSET + 14;
    HEAP[_bufferedreader_methods + 16] = __str40;
    HEAP[_bufferedreader_methods + 20] = FUNCTION_TABLE_OFFSET + 16;
    HEAP[_bufferedreader_methods + 32] = __str41;
    HEAP[_bufferedreader_methods + 36] = FUNCTION_TABLE_OFFSET + 18;
    HEAP[_bufferedreader_methods + 48] = __str42;
    HEAP[_bufferedreader_methods + 52] = FUNCTION_TABLE_OFFSET + 20;
    HEAP[_bufferedreader_methods + 64] = __str43;
    HEAP[_bufferedreader_methods + 68] = FUNCTION_TABLE_OFFSET + 22;
    HEAP[_bufferedreader_methods + 80] = __str44;
    HEAP[_bufferedreader_methods + 84] = FUNCTION_TABLE_OFFSET + 24;
    HEAP[_bufferedreader_methods + 96] = __str45;
    HEAP[_bufferedreader_methods + 100] = FUNCTION_TABLE_OFFSET + 26;
    HEAP[_bufferedreader_methods + 112] = __str46;
    HEAP[_bufferedreader_methods + 116] = FUNCTION_TABLE_OFFSET + 28;
    HEAP[_bufferedreader_methods + 128] = __str1;
    HEAP[_bufferedreader_methods + 132] = FUNCTION_TABLE_OFFSET + 30;
    HEAP[_bufferedreader_methods + 144] = __str47;
    HEAP[_bufferedreader_methods + 148] = FUNCTION_TABLE_OFFSET + 32;
    HEAP[_bufferedreader_methods + 160] = __str5;
    HEAP[_bufferedreader_methods + 164] = FUNCTION_TABLE_OFFSET + 34;
    HEAP[_bufferedreader_methods + 176] = __str48;
    HEAP[_bufferedreader_methods + 180] = FUNCTION_TABLE_OFFSET + 36;
    HEAP[_bufferedreader_methods + 192] = __str49;
    HEAP[_bufferedreader_methods + 196] = FUNCTION_TABLE_OFFSET + 38;
    HEAP[_bufferedreader_methods + 208] = __str50;
    HEAP[_bufferedreader_methods + 212] = FUNCTION_TABLE_OFFSET + 40;
    HEAP[_bufferedreader_methods + 224] = __str51;
    HEAP[_bufferedreader_methods + 228] = FUNCTION_TABLE_OFFSET + 42;
    HEAP[_bufferedreader_members] = __str35;
    HEAP[_bufferedreader_getset] = __str52;
    HEAP[_bufferedreader_getset + 4] = FUNCTION_TABLE_OFFSET + 44;
    HEAP[_bufferedreader_getset + 20] = __str13;
    HEAP[_bufferedreader_getset + 24] = FUNCTION_TABLE_OFFSET + 46;
    HEAP[_bufferedreader_getset + 40] = __str14;
    HEAP[_bufferedreader_getset + 44] = FUNCTION_TABLE_OFFSET + 48;
    HEAP[_PyBufferedReader_Type + 12] = __str53;
    HEAP[_PyBufferedReader_Type + 24] = FUNCTION_TABLE_OFFSET + 50;
    HEAP[_PyBufferedReader_Type + 44] = FUNCTION_TABLE_OFFSET + 52;
    HEAP[_PyBufferedReader_Type + 88] = _bufferedreader_doc;
    HEAP[_PyBufferedReader_Type + 92] = FUNCTION_TABLE_OFFSET + 54;
    HEAP[_PyBufferedReader_Type + 96] = FUNCTION_TABLE_OFFSET + 56;
    HEAP[_PyBufferedReader_Type + 112] = FUNCTION_TABLE_OFFSET + 58;
    HEAP[_PyBufferedReader_Type + 116] = _bufferedreader_methods;
    HEAP[_PyBufferedReader_Type + 120] = _bufferedreader_members;
    HEAP[_PyBufferedReader_Type + 124] = _bufferedreader_getset;
    HEAP[_PyBufferedReader_Type + 148] = FUNCTION_TABLE_OFFSET + 60;
    HEAP[_PyBufferedReader_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_bufferedwriter_methods] = __str41;
    HEAP[_bufferedwriter_methods + 4] = FUNCTION_TABLE_OFFSET + 18;
    HEAP[_bufferedwriter_methods + 16] = __str4;
    HEAP[_bufferedwriter_methods + 20] = FUNCTION_TABLE_OFFSET + 14;
    HEAP[_bufferedwriter_methods + 32] = __str42;
    HEAP[_bufferedwriter_methods + 36] = FUNCTION_TABLE_OFFSET + 20;
    HEAP[_bufferedwriter_methods + 48] = __str43;
    HEAP[_bufferedwriter_methods + 52] = FUNCTION_TABLE_OFFSET + 22;
    HEAP[_bufferedwriter_methods + 64] = __str44;
    HEAP[_bufferedwriter_methods + 68] = FUNCTION_TABLE_OFFSET + 24;
    HEAP[_bufferedwriter_methods + 80] = __str45;
    HEAP[_bufferedwriter_methods + 84] = FUNCTION_TABLE_OFFSET + 26;
    HEAP[_bufferedwriter_methods + 96] = __str46;
    HEAP[_bufferedwriter_methods + 100] = FUNCTION_TABLE_OFFSET + 28;
    HEAP[_bufferedwriter_methods + 112] = __str6;
    HEAP[_bufferedwriter_methods + 116] = FUNCTION_TABLE_OFFSET + 64;
    HEAP[_bufferedwriter_methods + 128] = __str51;
    HEAP[_bufferedwriter_methods + 132] = FUNCTION_TABLE_OFFSET + 42;
    HEAP[_bufferedwriter_methods + 144] = __str40;
    HEAP[_bufferedwriter_methods + 148] = FUNCTION_TABLE_OFFSET + 66;
    HEAP[_bufferedwriter_methods + 160] = __str49;
    HEAP[_bufferedwriter_methods + 164] = FUNCTION_TABLE_OFFSET + 38;
    HEAP[_bufferedwriter_methods + 176] = __str50;
    HEAP[_bufferedwriter_methods + 180] = FUNCTION_TABLE_OFFSET + 40;
    HEAP[_bufferedwriter_members] = __str35;
    HEAP[_bufferedwriter_getset] = __str52;
    HEAP[_bufferedwriter_getset + 4] = FUNCTION_TABLE_OFFSET + 44;
    HEAP[_bufferedwriter_getset + 20] = __str13;
    HEAP[_bufferedwriter_getset + 24] = FUNCTION_TABLE_OFFSET + 46;
    HEAP[_bufferedwriter_getset + 40] = __str14;
    HEAP[_bufferedwriter_getset + 44] = FUNCTION_TABLE_OFFSET + 48;
    HEAP[_PyBufferedWriter_Type + 12] = __str61;
    HEAP[_PyBufferedWriter_Type + 24] = FUNCTION_TABLE_OFFSET + 50;
    HEAP[_PyBufferedWriter_Type + 44] = FUNCTION_TABLE_OFFSET + 52;
    HEAP[_PyBufferedWriter_Type + 88] = _bufferedwriter_doc;
    HEAP[_PyBufferedWriter_Type + 92] = FUNCTION_TABLE_OFFSET + 54;
    HEAP[_PyBufferedWriter_Type + 96] = FUNCTION_TABLE_OFFSET + 56;
    HEAP[_PyBufferedWriter_Type + 116] = _bufferedwriter_methods;
    HEAP[_PyBufferedWriter_Type + 120] = _bufferedwriter_members;
    HEAP[_PyBufferedWriter_Type + 124] = _bufferedwriter_getset;
    HEAP[_PyBufferedWriter_Type + 148] = FUNCTION_TABLE_OFFSET + 68;
    HEAP[_PyBufferedWriter_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_bufferedrwpair_methods] = __str1;
    HEAP[_bufferedrwpair_methods + 4] = FUNCTION_TABLE_OFFSET + 70;
    HEAP[_bufferedrwpair_methods + 16] = __str47;
    HEAP[_bufferedrwpair_methods + 20] = FUNCTION_TABLE_OFFSET + 72;
    HEAP[_bufferedrwpair_methods + 32] = __str5;
    HEAP[_bufferedrwpair_methods + 36] = FUNCTION_TABLE_OFFSET + 74;
    HEAP[_bufferedrwpair_methods + 48] = __str7;
    HEAP[_bufferedrwpair_methods + 52] = FUNCTION_TABLE_OFFSET + 76;
    HEAP[_bufferedrwpair_methods + 64] = __str6;
    HEAP[_bufferedrwpair_methods + 68] = FUNCTION_TABLE_OFFSET + 78;
    HEAP[_bufferedrwpair_methods + 80] = __str40;
    HEAP[_bufferedrwpair_methods + 84] = FUNCTION_TABLE_OFFSET + 80;
    HEAP[_bufferedrwpair_methods + 96] = __str43;
    HEAP[_bufferedrwpair_methods + 100] = FUNCTION_TABLE_OFFSET + 82;
    HEAP[_bufferedrwpair_methods + 112] = __str44;
    HEAP[_bufferedrwpair_methods + 116] = FUNCTION_TABLE_OFFSET + 84;
    HEAP[_bufferedrwpair_methods + 128] = __str41;
    HEAP[_bufferedrwpair_methods + 132] = FUNCTION_TABLE_OFFSET + 86;
    HEAP[_bufferedrwpair_methods + 144] = __str46;
    HEAP[_bufferedrwpair_methods + 148] = FUNCTION_TABLE_OFFSET + 88;
    HEAP[_bufferedrwpair_getset] = __str52;
    HEAP[_bufferedrwpair_getset + 4] = FUNCTION_TABLE_OFFSET + 90;
    HEAP[_PyBufferedRWPair_Type + 12] = __str64;
    HEAP[_PyBufferedRWPair_Type + 24] = FUNCTION_TABLE_OFFSET + 92;
    HEAP[_PyBufferedRWPair_Type + 88] = _bufferedrwpair_doc;
    HEAP[_PyBufferedRWPair_Type + 92] = FUNCTION_TABLE_OFFSET + 94;
    HEAP[_PyBufferedRWPair_Type + 96] = FUNCTION_TABLE_OFFSET + 96;
    HEAP[_PyBufferedRWPair_Type + 116] = _bufferedrwpair_methods;
    HEAP[_PyBufferedRWPair_Type + 124] = _bufferedrwpair_getset;
    HEAP[_PyBufferedRWPair_Type + 148] = FUNCTION_TABLE_OFFSET + 98;
    HEAP[_PyBufferedRWPair_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_bufferedrandom_methods] = __str41;
    HEAP[_bufferedrandom_methods + 4] = FUNCTION_TABLE_OFFSET + 18;
    HEAP[_bufferedrandom_methods + 16] = __str4;
    HEAP[_bufferedrandom_methods + 20] = FUNCTION_TABLE_OFFSET + 14;
    HEAP[_bufferedrandom_methods + 32] = __str42;
    HEAP[_bufferedrandom_methods + 36] = FUNCTION_TABLE_OFFSET + 20;
    HEAP[_bufferedrandom_methods + 48] = __str43;
    HEAP[_bufferedrandom_methods + 52] = FUNCTION_TABLE_OFFSET + 22;
    HEAP[_bufferedrandom_methods + 64] = __str44;
    HEAP[_bufferedrandom_methods + 68] = FUNCTION_TABLE_OFFSET + 24;
    HEAP[_bufferedrandom_methods + 80] = __str45;
    HEAP[_bufferedrandom_methods + 84] = FUNCTION_TABLE_OFFSET + 26;
    HEAP[_bufferedrandom_methods + 96] = __str46;
    HEAP[_bufferedrandom_methods + 100] = FUNCTION_TABLE_OFFSET + 28;
    HEAP[_bufferedrandom_methods + 112] = __str40;
    HEAP[_bufferedrandom_methods + 116] = FUNCTION_TABLE_OFFSET + 66;
    HEAP[_bufferedrandom_methods + 128] = __str49;
    HEAP[_bufferedrandom_methods + 132] = FUNCTION_TABLE_OFFSET + 38;
    HEAP[_bufferedrandom_methods + 144] = __str50;
    HEAP[_bufferedrandom_methods + 148] = FUNCTION_TABLE_OFFSET + 40;
    HEAP[_bufferedrandom_methods + 160] = __str51;
    HEAP[_bufferedrandom_methods + 164] = FUNCTION_TABLE_OFFSET + 42;
    HEAP[_bufferedrandom_methods + 176] = __str1;
    HEAP[_bufferedrandom_methods + 180] = FUNCTION_TABLE_OFFSET + 30;
    HEAP[_bufferedrandom_methods + 192] = __str5;
    HEAP[_bufferedrandom_methods + 196] = FUNCTION_TABLE_OFFSET + 34;
    HEAP[_bufferedrandom_methods + 208] = __str7;
    HEAP[_bufferedrandom_methods + 212] = FUNCTION_TABLE_OFFSET + 100;
    HEAP[_bufferedrandom_methods + 224] = __str48;
    HEAP[_bufferedrandom_methods + 228] = FUNCTION_TABLE_OFFSET + 36;
    HEAP[_bufferedrandom_methods + 240] = __str47;
    HEAP[_bufferedrandom_methods + 244] = FUNCTION_TABLE_OFFSET + 32;
    HEAP[_bufferedrandom_methods + 256] = __str6;
    HEAP[_bufferedrandom_methods + 260] = FUNCTION_TABLE_OFFSET + 64;
    HEAP[_bufferedrandom_members] = __str35;
    HEAP[_bufferedrandom_getset] = __str52;
    HEAP[_bufferedrandom_getset + 4] = FUNCTION_TABLE_OFFSET + 44;
    HEAP[_bufferedrandom_getset + 20] = __str13;
    HEAP[_bufferedrandom_getset + 24] = FUNCTION_TABLE_OFFSET + 46;
    HEAP[_bufferedrandom_getset + 40] = __str14;
    HEAP[_bufferedrandom_getset + 44] = FUNCTION_TABLE_OFFSET + 48;
    HEAP[_PyBufferedRandom_Type + 12] = __str65;
    HEAP[_PyBufferedRandom_Type + 24] = FUNCTION_TABLE_OFFSET + 50;
    HEAP[_PyBufferedRandom_Type + 44] = FUNCTION_TABLE_OFFSET + 52;
    HEAP[_PyBufferedRandom_Type + 88] = _bufferedrandom_doc;
    HEAP[_PyBufferedRandom_Type + 92] = FUNCTION_TABLE_OFFSET + 54;
    HEAP[_PyBufferedRandom_Type + 96] = FUNCTION_TABLE_OFFSET + 56;
    HEAP[_PyBufferedRandom_Type + 112] = FUNCTION_TABLE_OFFSET + 58;
    HEAP[_PyBufferedRandom_Type + 116] = _bufferedrandom_methods;
    HEAP[_PyBufferedRandom_Type + 120] = _bufferedrandom_members;
    HEAP[_PyBufferedRandom_Type + 124] = _bufferedrandom_getset;
    HEAP[_PyBufferedRandom_Type + 148] = FUNCTION_TABLE_OFFSET + 102;
    HEAP[_PyBufferedRandom_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_bytesio_getsetlist] = __str52;
    HEAP[_bytesio_getsetlist + 4] = FUNCTION_TABLE_OFFSET + 104;
    HEAP[_bytesio_getsetlist + 12] = __str3096;
    HEAP[_bytesio_methods] = __str43;
    HEAP[_bytesio_methods + 4] = FUNCTION_TABLE_OFFSET + 106;
    HEAP[_bytesio_methods + 16] = __str42;
    HEAP[_bytesio_methods + 20] = FUNCTION_TABLE_OFFSET + 106;
    HEAP[_bytesio_methods + 32] = __str44;
    HEAP[_bytesio_methods + 36] = FUNCTION_TABLE_OFFSET + 106;
    HEAP[_bytesio_methods + 48] = __str41;
    HEAP[_bytesio_methods + 52] = FUNCTION_TABLE_OFFSET + 108;
    HEAP[_bytesio_methods + 60] = _close_doc;
    HEAP[_bytesio_methods + 64] = __str40;
    HEAP[_bytesio_methods + 68] = FUNCTION_TABLE_OFFSET + 110;
    HEAP[_bytesio_methods + 76] = _flush_doc;
    HEAP[_bytesio_methods + 80] = __str46;
    HEAP[_bytesio_methods + 84] = FUNCTION_TABLE_OFFSET + 112;
    HEAP[_bytesio_methods + 92] = _isatty_doc;
    HEAP[_bytesio_methods + 96] = __str50;
    HEAP[_bytesio_methods + 100] = FUNCTION_TABLE_OFFSET + 114;
    HEAP[_bytesio_methods + 108] = _tell_doc;
    HEAP[_bytesio_methods + 112] = __str6;
    HEAP[_bytesio_methods + 116] = FUNCTION_TABLE_OFFSET + 116;
    HEAP[_bytesio_methods + 124] = _write_doc;
    HEAP[_bytesio_methods + 128] = __str39105;
    HEAP[_bytesio_methods + 132] = FUNCTION_TABLE_OFFSET + 118;
    HEAP[_bytesio_methods + 140] = _writelines_doc;
    HEAP[_bytesio_methods + 144] = __str5;
    HEAP[_bytesio_methods + 148] = FUNCTION_TABLE_OFFSET + 120;
    HEAP[_bytesio_methods + 156] = _read1_doc;
    HEAP[_bytesio_methods + 160] = __str7;
    HEAP[_bytesio_methods + 164] = FUNCTION_TABLE_OFFSET + 122;
    HEAP[_bytesio_methods + 172] = _readinto_doc;
    HEAP[_bytesio_methods + 176] = __str48;
    HEAP[_bytesio_methods + 180] = FUNCTION_TABLE_OFFSET + 124;
    HEAP[_bytesio_methods + 188] = _readline_doc;
    HEAP[_bytesio_methods + 192] = __str43109;
    HEAP[_bytesio_methods + 196] = FUNCTION_TABLE_OFFSET + 126;
    HEAP[_bytesio_methods + 204] = _readlines_doc;
    HEAP[_bytesio_methods + 208] = __str1;
    HEAP[_bytesio_methods + 212] = FUNCTION_TABLE_OFFSET + 128;
    HEAP[_bytesio_methods + 220] = _read_doc;
    HEAP[_bytesio_methods + 224] = __str45111;
    HEAP[_bytesio_methods + 228] = FUNCTION_TABLE_OFFSET + 130;
    HEAP[_bytesio_methods + 236] = _getval_doc;
    HEAP[_bytesio_methods + 240] = __str49;
    HEAP[_bytesio_methods + 244] = FUNCTION_TABLE_OFFSET + 132;
    HEAP[_bytesio_methods + 252] = _seek_doc;
    HEAP[_bytesio_methods + 256] = __str51;
    HEAP[_bytesio_methods + 260] = FUNCTION_TABLE_OFFSET + 134;
    HEAP[_bytesio_methods + 268] = _truncate_doc;
    HEAP[_bytesio_methods + 272] = __str48114;
    HEAP[_bytesio_methods + 276] = FUNCTION_TABLE_OFFSET + 136;
    HEAP[_bytesio_methods + 288] = __str49115;
    HEAP[_bytesio_methods + 292] = FUNCTION_TABLE_OFFSET + 138;
    HEAP[_PyBytesIO_Type + 12] = __str50116;
    HEAP[_PyBytesIO_Type + 24] = FUNCTION_TABLE_OFFSET + 140;
    HEAP[_PyBytesIO_Type + 88] = _bytesio_doc;
    HEAP[_PyBytesIO_Type + 92] = FUNCTION_TABLE_OFFSET + 142;
    HEAP[_PyBytesIO_Type + 96] = FUNCTION_TABLE_OFFSET + 144;
    HEAP[_PyBytesIO_Type + 108] = FUNCTION_TABLE_OFFSET + 146;
    HEAP[_PyBytesIO_Type + 112] = FUNCTION_TABLE_OFFSET + 148;
    HEAP[_PyBytesIO_Type + 116] = _bytesio_methods;
    HEAP[_PyBytesIO_Type + 124] = _bytesio_getsetlist;
    HEAP[_PyBytesIO_Type + 148] = FUNCTION_TABLE_OFFSET + 150;
    HEAP[_PyBytesIO_Type + 156] = FUNCTION_TABLE_OFFSET + 152;
    HEAP[_kwlist_8657] = __str9126;
    HEAP[_kwlist_8657 + 4] = __str14;
    HEAP[_kwlist_8657 + 8] = __str11128;
    HEAP[_fileio_methods] = __str37162;
    HEAP[_fileio_methods + 4] = FUNCTION_TABLE_OFFSET + 154;
    HEAP[_fileio_methods + 12] = _read_doc154;
    HEAP[_fileio_methods + 16] = __str38163;
    HEAP[_fileio_methods + 20] = FUNCTION_TABLE_OFFSET + 156;
    HEAP[_fileio_methods + 28] = _readall_doc;
    HEAP[_fileio_methods + 32] = __str39164;
    HEAP[_fileio_methods + 36] = FUNCTION_TABLE_OFFSET + 158;
    HEAP[_fileio_methods + 44] = _readinto_doc159;
    HEAP[_fileio_methods + 48] = __str40165;
    HEAP[_fileio_methods + 52] = FUNCTION_TABLE_OFFSET + 160;
    HEAP[_fileio_methods + 60] = _write_doc155;
    HEAP[_fileio_methods + 64] = __str41166;
    HEAP[_fileio_methods + 68] = FUNCTION_TABLE_OFFSET + 162;
    HEAP[_fileio_methods + 76] = _seek_doc156;
    HEAP[_fileio_methods + 80] = __str42167;
    HEAP[_fileio_methods + 84] = FUNCTION_TABLE_OFFSET + 164;
    HEAP[_fileio_methods + 92] = _tell_doc158;
    HEAP[_fileio_methods + 96] = __str43168;
    HEAP[_fileio_methods + 100] = FUNCTION_TABLE_OFFSET + 166;
    HEAP[_fileio_methods + 108] = _truncate_doc157;
    HEAP[_fileio_methods + 112] = __str117;
    HEAP[_fileio_methods + 116] = FUNCTION_TABLE_OFFSET + 168;
    HEAP[_fileio_methods + 124] = _close_doc160;
    HEAP[_fileio_methods + 128] = __str44169;
    HEAP[_fileio_methods + 132] = FUNCTION_TABLE_OFFSET + 170;
    HEAP[_fileio_methods + 140] = _seekable_doc;
    HEAP[_fileio_methods + 144] = __str45170;
    HEAP[_fileio_methods + 148] = FUNCTION_TABLE_OFFSET + 172;
    HEAP[_fileio_methods + 156] = _readable_doc;
    HEAP[_fileio_methods + 160] = __str46171;
    HEAP[_fileio_methods + 164] = FUNCTION_TABLE_OFFSET + 174;
    HEAP[_fileio_methods + 172] = _writable_doc;
    HEAP[_fileio_methods + 176] = __str45;
    HEAP[_fileio_methods + 180] = FUNCTION_TABLE_OFFSET + 176;
    HEAP[_fileio_methods + 188] = _fileno_doc;
    HEAP[_fileio_methods + 192] = __str48173;
    HEAP[_fileio_methods + 196] = FUNCTION_TABLE_OFFSET + 178;
    HEAP[_fileio_methods + 204] = _isatty_doc161;
    HEAP[_fileio_getsetlist] = __str49174;
    HEAP[_fileio_getsetlist + 4] = FUNCTION_TABLE_OFFSET + 180;
    HEAP[_fileio_getsetlist + 12] = __str50175;
    HEAP[_fileio_getsetlist + 20] = __str11128;
    HEAP[_fileio_getsetlist + 24] = FUNCTION_TABLE_OFFSET + 182;
    HEAP[_fileio_getsetlist + 32] = __str51176;
    HEAP[_fileio_getsetlist + 40] = __str14;
    HEAP[_fileio_getsetlist + 44] = FUNCTION_TABLE_OFFSET + 184;
    HEAP[_fileio_getsetlist + 52] = __str52177;
    HEAP[_PyFileIO_Type + 12] = __str53178;
    HEAP[_PyFileIO_Type + 24] = FUNCTION_TABLE_OFFSET + 186;
    HEAP[_PyFileIO_Type + 44] = FUNCTION_TABLE_OFFSET + 188;
    HEAP[_PyFileIO_Type + 72] = FUNCTION_TABLE_OFFSET + 190;
    HEAP[_PyFileIO_Type + 88] = _fileio_doc;
    HEAP[_PyFileIO_Type + 92] = FUNCTION_TABLE_OFFSET + 192;
    HEAP[_PyFileIO_Type + 96] = FUNCTION_TABLE_OFFSET + 194;
    HEAP[_PyFileIO_Type + 116] = _fileio_methods;
    HEAP[_PyFileIO_Type + 124] = _fileio_getsetlist;
    HEAP[_PyFileIO_Type + 148] = FUNCTION_TABLE_OFFSET + 196;
    HEAP[_PyFileIO_Type + 152] = FUNCTION_TABLE_OFFSET + 198;
    HEAP[_PyFileIO_Type + 156] = FUNCTION_TABLE_OFFSET + 200;
    HEAP[_PyFileIO_Type + 160] = FUNCTION_TABLE_OFFSET + 202;
    HEAP[_iobase_methods] = __str181;
    HEAP[_iobase_methods + 4] = FUNCTION_TABLE_OFFSET + 204;
    HEAP[_iobase_methods + 12] = _iobase_seek_doc;
    HEAP[_iobase_methods + 16] = __str23204;
    HEAP[_iobase_methods + 20] = FUNCTION_TABLE_OFFSET + 206;
    HEAP[_iobase_methods + 28] = _iobase_tell_doc;
    HEAP[_iobase_methods + 32] = __str2183;
    HEAP[_iobase_methods + 36] = FUNCTION_TABLE_OFFSET + 208;
    HEAP[_iobase_methods + 44] = _iobase_truncate_doc;
    HEAP[_iobase_methods + 48] = __str24205;
    HEAP[_iobase_methods + 52] = FUNCTION_TABLE_OFFSET + 210;
    HEAP[_iobase_methods + 60] = _iobase_flush_doc;
    HEAP[_iobase_methods + 64] = __str25206;
    HEAP[_iobase_methods + 68] = FUNCTION_TABLE_OFFSET + 212;
    HEAP[_iobase_methods + 76] = _iobase_close_doc;
    HEAP[_iobase_methods + 80] = __str26207;
    HEAP[_iobase_methods + 84] = FUNCTION_TABLE_OFFSET + 214;
    HEAP[_iobase_methods + 92] = _iobase_seekable_doc;
    HEAP[_iobase_methods + 96] = __str27208;
    HEAP[_iobase_methods + 100] = FUNCTION_TABLE_OFFSET + 216;
    HEAP[_iobase_methods + 108] = _iobase_readable_doc;
    HEAP[_iobase_methods + 112] = __str28209;
    HEAP[_iobase_methods + 116] = FUNCTION_TABLE_OFFSET + 218;
    HEAP[_iobase_methods + 124] = _iobase_writable_doc;
    HEAP[_iobase_methods + 128] = __str29210;
    HEAP[_iobase_methods + 132] = FUNCTION_TABLE_OFFSET + 220;
    HEAP[_iobase_methods + 144] = __str30211;
    HEAP[_iobase_methods + 148] = FUNCTION_TABLE_OFFSET + 222;
    HEAP[_iobase_methods + 160] = __str31212;
    HEAP[_iobase_methods + 164] = FUNCTION_TABLE_OFFSET + 224;
    HEAP[_iobase_methods + 176] = __str32213;
    HEAP[_iobase_methods + 180] = FUNCTION_TABLE_OFFSET + 226;
    HEAP[_iobase_methods + 192] = __str10191;
    HEAP[_iobase_methods + 196] = FUNCTION_TABLE_OFFSET + 228;
    HEAP[_iobase_methods + 204] = _iobase_fileno_doc;
    HEAP[_iobase_methods + 208] = __str33214;
    HEAP[_iobase_methods + 212] = FUNCTION_TABLE_OFFSET + 230;
    HEAP[_iobase_methods + 220] = _iobase_isatty_doc;
    HEAP[_iobase_methods + 224] = __str34215;
    HEAP[_iobase_methods + 228] = FUNCTION_TABLE_OFFSET + 232;
    HEAP[_iobase_methods + 240] = __str35216;
    HEAP[_iobase_methods + 244] = FUNCTION_TABLE_OFFSET + 234;
    HEAP[_iobase_methods + 256] = __str36217;
    HEAP[_iobase_methods + 260] = FUNCTION_TABLE_OFFSET + 236;
    HEAP[_iobase_methods + 268] = _iobase_readline_doc;
    HEAP[_iobase_methods + 272] = __str37218;
    HEAP[_iobase_methods + 276] = FUNCTION_TABLE_OFFSET + 238;
    HEAP[_iobase_methods + 284] = _iobase_readlines_doc;
    HEAP[_iobase_methods + 288] = __str38219;
    HEAP[_iobase_methods + 292] = FUNCTION_TABLE_OFFSET + 240;
    HEAP[_iobase_getset] = __str39220;
    HEAP[_iobase_getset + 4] = FUNCTION_TABLE_OFFSET + 242;
    HEAP[_PyIOBase_Type + 12] = __str40221;
    HEAP[_PyIOBase_Type + 24] = FUNCTION_TABLE_OFFSET + 244;
    HEAP[_PyIOBase_Type + 88] = _iobase_doc;
    HEAP[_PyIOBase_Type + 92] = FUNCTION_TABLE_OFFSET + 246;
    HEAP[_PyIOBase_Type + 96] = FUNCTION_TABLE_OFFSET + 248;
    HEAP[_PyIOBase_Type + 108] = FUNCTION_TABLE_OFFSET + 250;
    HEAP[_PyIOBase_Type + 112] = FUNCTION_TABLE_OFFSET + 252;
    HEAP[_PyIOBase_Type + 116] = _iobase_methods;
    HEAP[_PyIOBase_Type + 124] = _iobase_getset;
    HEAP[_PyIOBase_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_rawiobase_methods] = __str15196;
    HEAP[_rawiobase_methods + 4] = FUNCTION_TABLE_OFFSET + 254;
    HEAP[_rawiobase_methods + 16] = __str42224;
    HEAP[_rawiobase_methods + 20] = FUNCTION_TABLE_OFFSET + 256;
    HEAP[_rawiobase_methods + 28] = _rawiobase_readall_doc;
    HEAP[_PyRawIOBase_Type + 12] = __str44226;
    HEAP[_PyRawIOBase_Type + 88] = _rawiobase_doc;
    HEAP[_PyRawIOBase_Type + 116] = _rawiobase_methods;
    HEAP[_PyRawIOBase_Type + 128] = _PyIOBase_Type;
    HEAP[_blockingioerror_members] = __str3235;
    HEAP[__PyExc_BlockingIOError + 12] = __str4236;
    HEAP[__PyExc_BlockingIOError + 88] = __str5237;
    HEAP[__PyExc_BlockingIOError + 120] = _blockingioerror_members;
    HEAP[__PyExc_BlockingIOError + 148] = FUNCTION_TABLE_OFFSET + 258;
    HEAP[_PyExc_BlockingIOError] = __PyExc_BlockingIOError;
    HEAP[_module_methods] = __str34268;
    HEAP[_module_methods + 4] = FUNCTION_TABLE_OFFSET + 260;
    HEAP[_module_methods + 12] = _open_doc;
    HEAP[_stringio_methods] = __str36355;
    HEAP[_stringio_methods + 4] = FUNCTION_TABLE_OFFSET + 262;
    HEAP[_stringio_methods + 12] = _stringio_close_doc;
    HEAP[_stringio_methods + 16] = __str37356;
    HEAP[_stringio_methods + 20] = FUNCTION_TABLE_OFFSET + 264;
    HEAP[_stringio_methods + 28] = _stringio_getvalue_doc;
    HEAP[_stringio_methods + 32] = __str38357;
    HEAP[_stringio_methods + 36] = FUNCTION_TABLE_OFFSET + 266;
    HEAP[_stringio_methods + 44] = _stringio_read_doc;
    HEAP[_stringio_methods + 48] = __str39358;
    HEAP[_stringio_methods + 52] = FUNCTION_TABLE_OFFSET + 268;
    HEAP[_stringio_methods + 60] = _stringio_readline_doc;
    HEAP[_stringio_methods + 64] = __str40359;
    HEAP[_stringio_methods + 68] = FUNCTION_TABLE_OFFSET + 270;
    HEAP[_stringio_methods + 76] = _stringio_tell_doc;
    HEAP[_stringio_methods + 80] = __str41360;
    HEAP[_stringio_methods + 84] = FUNCTION_TABLE_OFFSET + 272;
    HEAP[_stringio_methods + 92] = _stringio_truncate_doc;
    HEAP[_stringio_methods + 96] = __str42361;
    HEAP[_stringio_methods + 100] = FUNCTION_TABLE_OFFSET + 274;
    HEAP[_stringio_methods + 108] = _stringio_seek_doc;
    HEAP[_stringio_methods + 112] = __str43362;
    HEAP[_stringio_methods + 116] = FUNCTION_TABLE_OFFSET + 276;
    HEAP[_stringio_methods + 124] = _stringio_write_doc;
    HEAP[_stringio_methods + 128] = __str44363;
    HEAP[_stringio_methods + 132] = FUNCTION_TABLE_OFFSET + 278;
    HEAP[_stringio_methods + 144] = __str45364;
    HEAP[_stringio_methods + 148] = FUNCTION_TABLE_OFFSET + 280;
    HEAP[_stringio_methods + 160] = __str46365;
    HEAP[_stringio_methods + 164] = FUNCTION_TABLE_OFFSET + 282;
    HEAP[_stringio_methods + 176] = __str47366;
    HEAP[_stringio_methods + 180] = FUNCTION_TABLE_OFFSET + 284;
    HEAP[_stringio_methods + 192] = __str48367;
    HEAP[_stringio_methods + 196] = FUNCTION_TABLE_OFFSET + 286;
    HEAP[_stringio_getset] = __str49368;
    HEAP[_stringio_getset + 4] = FUNCTION_TABLE_OFFSET + 288;
    HEAP[_stringio_getset + 20] = __str50369;
    HEAP[_stringio_getset + 24] = FUNCTION_TABLE_OFFSET + 290;
    HEAP[_stringio_getset + 40] = __str51370;
    HEAP[_stringio_getset + 44] = FUNCTION_TABLE_OFFSET + 292;
    HEAP[_PyStringIO_Type + 12] = __str52371;
    HEAP[_PyStringIO_Type + 24] = FUNCTION_TABLE_OFFSET + 294;
    HEAP[_PyStringIO_Type + 88] = _stringio_doc;
    HEAP[_PyStringIO_Type + 92] = FUNCTION_TABLE_OFFSET + 296;
    HEAP[_PyStringIO_Type + 96] = FUNCTION_TABLE_OFFSET + 298;
    HEAP[_PyStringIO_Type + 112] = FUNCTION_TABLE_OFFSET + 300;
    HEAP[_PyStringIO_Type + 116] = _stringio_methods;
    HEAP[_PyStringIO_Type + 124] = _stringio_getset;
    HEAP[_PyStringIO_Type + 148] = FUNCTION_TABLE_OFFSET + 302;
    HEAP[_PyStringIO_Type + 156] = FUNCTION_TABLE_OFFSET + 304;
    HEAP[_textiobase_methods] = __str4;
    HEAP[_textiobase_methods + 4] = FUNCTION_TABLE_OFFSET + 306;
    HEAP[_textiobase_methods + 12] = _textiobase_detach_doc;
    HEAP[_textiobase_methods + 16] = __str1375;
    HEAP[_textiobase_methods + 20] = FUNCTION_TABLE_OFFSET + 308;
    HEAP[_textiobase_methods + 28] = _textiobase_read_doc;
    HEAP[_textiobase_methods + 32] = __str2376;
    HEAP[_textiobase_methods + 36] = FUNCTION_TABLE_OFFSET + 310;
    HEAP[_textiobase_methods + 44] = _textiobase_readline_doc;
    HEAP[_textiobase_methods + 48] = __str3377;
    HEAP[_textiobase_methods + 52] = FUNCTION_TABLE_OFFSET + 312;
    HEAP[_textiobase_methods + 60] = _textiobase_write_doc;
    HEAP[_textiobase_getset] = __str4378;
    HEAP[_textiobase_getset + 4] = FUNCTION_TABLE_OFFSET + 314;
    HEAP[_textiobase_getset + 12] = _textiobase_encoding_doc;
    HEAP[_textiobase_getset + 20] = __str5379;
    HEAP[_textiobase_getset + 24] = FUNCTION_TABLE_OFFSET + 316;
    HEAP[_textiobase_getset + 32] = _textiobase_newlines_doc;
    HEAP[_textiobase_getset + 40] = __str6380;
    HEAP[_textiobase_getset + 44] = FUNCTION_TABLE_OFFSET + 318;
    HEAP[_textiobase_getset + 52] = _textiobase_errors_doc;
    HEAP[_PyTextIOBase_Type + 12] = __str7381;
    HEAP[_PyTextIOBase_Type + 88] = _textiobase_doc;
    HEAP[_PyTextIOBase_Type + 116] = _textiobase_methods;
    HEAP[_PyTextIOBase_Type + 124] = _textiobase_getset;
    HEAP[_PyTextIOBase_Type + 128] = _PyIOBase_Type;
    HEAP[_incrementalnewlinedecoder_methods] = __str29404;
    HEAP[_incrementalnewlinedecoder_methods + 4] = FUNCTION_TABLE_OFFSET + 320;
    HEAP[_incrementalnewlinedecoder_methods + 16] = __str30405;
    HEAP[_incrementalnewlinedecoder_methods + 20] = FUNCTION_TABLE_OFFSET + 322;
    HEAP[_incrementalnewlinedecoder_methods + 32] = __str22397;
    HEAP[_incrementalnewlinedecoder_methods + 36] = FUNCTION_TABLE_OFFSET + 324;
    HEAP[_incrementalnewlinedecoder_methods + 48] = __str31406;
    HEAP[_incrementalnewlinedecoder_methods + 52] = FUNCTION_TABLE_OFFSET + 326;
    HEAP[_incrementalnewlinedecoder_getset] = __str5379;
    HEAP[_incrementalnewlinedecoder_getset + 4] = FUNCTION_TABLE_OFFSET + 328;
    HEAP[_PyIncrementalNewlineDecoder_Type + 12] = __str32407;
    HEAP[_PyIncrementalNewlineDecoder_Type + 24] = FUNCTION_TABLE_OFFSET + 330;
    HEAP[_PyIncrementalNewlineDecoder_Type + 88] = _incrementalnewlinedecoder_doc;
    HEAP[_PyIncrementalNewlineDecoder_Type + 116] = _incrementalnewlinedecoder_methods;
    HEAP[_PyIncrementalNewlineDecoder_Type + 124] = _incrementalnewlinedecoder_getset;
    HEAP[_PyIncrementalNewlineDecoder_Type + 148] = FUNCTION_TABLE_OFFSET + 332;
    HEAP[_PyIncrementalNewlineDecoder_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_encodefuncs] = __str33409;
    HEAP[_encodefuncs + 4] = FUNCTION_TABLE_OFFSET + 334;
    HEAP[_encodefuncs + 8] = __str34410;
    HEAP[_encodefuncs + 12] = FUNCTION_TABLE_OFFSET + 336;
    HEAP[_encodefuncs + 16] = __str35411;
    HEAP[_encodefuncs + 20] = FUNCTION_TABLE_OFFSET + 338;
    HEAP[_encodefuncs + 24] = __str36412;
    HEAP[_encodefuncs + 28] = FUNCTION_TABLE_OFFSET + 340;
    HEAP[_encodefuncs + 32] = __str37413;
    HEAP[_encodefuncs + 36] = FUNCTION_TABLE_OFFSET + 342;
    HEAP[_encodefuncs + 40] = __str38414;
    HEAP[_encodefuncs + 44] = FUNCTION_TABLE_OFFSET + 344;
    HEAP[_encodefuncs + 48] = __str39415;
    HEAP[_encodefuncs + 52] = FUNCTION_TABLE_OFFSET + 346;
    HEAP[_encodefuncs + 56] = __str40416;
    HEAP[_encodefuncs + 60] = FUNCTION_TABLE_OFFSET + 348;
    HEAP[_encodefuncs + 64] = __str41417;
    HEAP[_encodefuncs + 68] = FUNCTION_TABLE_OFFSET + 350;
    HEAP[_textiowrapper_methods] = __str4;
    HEAP[_textiowrapper_methods + 4] = FUNCTION_TABLE_OFFSET + 352;
    HEAP[_textiowrapper_methods + 16] = __str3377;
    HEAP[_textiowrapper_methods + 20] = FUNCTION_TABLE_OFFSET + 354;
    HEAP[_textiowrapper_methods + 32] = __str1375;
    HEAP[_textiowrapper_methods + 36] = FUNCTION_TABLE_OFFSET + 356;
    HEAP[_textiowrapper_methods + 48] = __str2376;
    HEAP[_textiowrapper_methods + 52] = FUNCTION_TABLE_OFFSET + 358;
    HEAP[_textiowrapper_methods + 64] = __str79;
    HEAP[_textiowrapper_methods + 68] = FUNCTION_TABLE_OFFSET + 360;
    HEAP[_textiowrapper_methods + 80] = __str102;
    HEAP[_textiowrapper_methods + 84] = FUNCTION_TABLE_OFFSET + 362;
    HEAP[_textiowrapper_methods + 96] = __str100;
    HEAP[_textiowrapper_methods + 100] = FUNCTION_TABLE_OFFSET + 364;
    HEAP[_textiowrapper_methods + 112] = __str55431;
    HEAP[_textiowrapper_methods + 116] = FUNCTION_TABLE_OFFSET + 366;
    HEAP[_textiowrapper_methods + 128] = __str50426;
    HEAP[_textiowrapper_methods + 132] = FUNCTION_TABLE_OFFSET + 368;
    HEAP[_textiowrapper_methods + 144] = __str52428;
    HEAP[_textiowrapper_methods + 148] = FUNCTION_TABLE_OFFSET + 370;
    HEAP[_textiowrapper_methods + 160] = __str101;
    HEAP[_textiowrapper_methods + 164] = FUNCTION_TABLE_OFFSET + 372;
    HEAP[_textiowrapper_methods + 176] = __str80;
    HEAP[_textiowrapper_methods + 180] = FUNCTION_TABLE_OFFSET + 374;
    HEAP[_textiowrapper_methods + 192] = __str77;
    HEAP[_textiowrapper_methods + 196] = FUNCTION_TABLE_OFFSET + 376;
    HEAP[_textiowrapper_methods + 208] = __str105;
    HEAP[_textiowrapper_methods + 212] = FUNCTION_TABLE_OFFSET + 378;
    HEAP[_textiowrapper_members] = __str4378;
    HEAP[_textiowrapper_members + 20] = __str42418;
    HEAP[_textiowrapper_members + 40] = __str44420;
    HEAP[_textiowrapper_getset] = __str53429;
    HEAP[_textiowrapper_getset + 4] = FUNCTION_TABLE_OFFSET + 380;
    HEAP[_textiowrapper_getset + 20] = __str106;
    HEAP[_textiowrapper_getset + 24] = FUNCTION_TABLE_OFFSET + 382;
    HEAP[_textiowrapper_getset + 40] = __str5379;
    HEAP[_textiowrapper_getset + 44] = FUNCTION_TABLE_OFFSET + 384;
    HEAP[_textiowrapper_getset + 60] = __str6380;
    HEAP[_textiowrapper_getset + 64] = FUNCTION_TABLE_OFFSET + 386;
    HEAP[_textiowrapper_getset + 80] = __str107;
    HEAP[_textiowrapper_getset + 84] = FUNCTION_TABLE_OFFSET + 388;
    HEAP[_textiowrapper_getset + 88] = FUNCTION_TABLE_OFFSET + 390;
    HEAP[_PyTextIOWrapper_Type + 12] = __str108;
    HEAP[_PyTextIOWrapper_Type + 24] = FUNCTION_TABLE_OFFSET + 392;
    HEAP[_PyTextIOWrapper_Type + 44] = FUNCTION_TABLE_OFFSET + 394;
    HEAP[_PyTextIOWrapper_Type + 88] = _textiowrapper_doc;
    HEAP[_PyTextIOWrapper_Type + 92] = FUNCTION_TABLE_OFFSET + 396;
    HEAP[_PyTextIOWrapper_Type + 96] = FUNCTION_TABLE_OFFSET + 398;
    HEAP[_PyTextIOWrapper_Type + 112] = FUNCTION_TABLE_OFFSET + 400;
    HEAP[_PyTextIOWrapper_Type + 116] = _textiowrapper_methods;
    HEAP[_PyTextIOWrapper_Type + 120] = _textiowrapper_members;
    HEAP[_PyTextIOWrapper_Type + 124] = _textiowrapper_getset;
    HEAP[_PyTextIOWrapper_Type + 148] = FUNCTION_TABLE_OFFSET + 402;
    HEAP[_PyTextIOWrapper_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    __globalConstructor__();
  }
  Module["run"] = run;
  run();
  return Module;
});
