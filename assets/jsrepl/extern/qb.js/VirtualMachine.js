/**
  Copyright 2010 Steve Hanov

  This file is part of qb.js

  qb.js is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  qb.js is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with qb.js.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
  Defines:
    QBasic.VirtualMachine
    QBasic.SystemFunctions
    QBasic.SystemSubroutines
  Uses:
    # Types.js
    QBasic.ScalarVariable
    QBasic.ArrayVariable
    QBasic.Dimension
    QBasic.IsNumericType
    QBasic.DeriveTypeNameFromVariable
*/

(function () { 
  /** @constructor */
  function StackFrame(pc) {
    // Address to return to when the subroutine has ended.
    this.pc = pc;

    // map from name to the Scalar or Array variable.
    this.variables = {};
  }

  /**
    The VirtualMachine runs the bytecode given to it. It can run in one of two
    modes: Synchronously or Asynchronously.

    In synchronous mode, the program is run to completion before returning from
    the run() function. This can cause a browser window to freeze until
    execution completes.

    In asynchronous mode, a javascript interval is used. Every so often, we run
    some instructions and then stop. That way, the program appears to run while
    letting the user use the browser window.

    @constructor
    @param console A Console object that will be used as the screen.
  */
  QBasic.VirtualMachine = function(console) {
    // Stack
    this.stack = [];

    // program counter.
    this.pc = 0;

    // list of StackFrames. The last one is searched for variable references.
    // Failing that, the first one ( the main procedure ) is searched for any
    // shared variables matching the name.
    this.callstack = [];

    // The console.
    this.cons = console;

    // The bytecode (array of Instruction objects)
    this.instructions = [];

    // Array of user defined times.
    this.types = [];

    // set of names of shared variables.
    this.shared = {};

    // Index of next data statement to be read.
    this.dataPtr = 0;

    // Array of strings or numbers from the data statements.
    this.data = [];

    // True if the virtual machine is suspended for some reason (for example,
    // waiting for user input)
    this.suspended = false;

    // The last random number generated by a RND function. We have to remember
    // it because RND 0 returns the last one generated.
    this.lastRandomNumber = 0;

    // The last program loaded into this VM.
    this.lastProgram = null;
  };

  QBasic.VirtualMachine.prototype = {
    /** Loads a new program into the VM keeping existing state. */
    loadProgram: function (program) {
      this.pc = this.lastProgram ? this.lastProgram.instructions.length : 0;
      this.defaultType = program.defaultType;

      this.instructions = program.instructions;
      this.data = program.data;

      this.shared = program.shared;
      this.types = program.types;

      if (this.callstack.length == 0) {
        this.callstack.push(new StackFrame(this.instructions.length));
      }
      this.frame = this.callstack[0];
      this.suspended = false;

      this.lastProgram = program;
    },
    /** Load and start running a program. */
    run: function (program, callback) {
      if (!(program instanceof QBasic.Program)) {
        program = new QBasic.Program(program, this.lastProgram)
      }
      this.loadProgram(program);
      this.callback = callback;
      this.resume();
    },
    /**
      Suspend the CPU, maintaining all state. This happens when the program
      is waiting for user input.
    */
    suspend: function () {
      this.suspended = true;
    },
    /** Resume the CPU, after previously being suspended. */
    resume: function () {
      this.suspended = false;
      while (this.pc < this.instructions.length && !this.suspended) {
        this.runOneInstruction();
      }
      if (this.pc == this.instructions.length && this.callback) this.callback();
    },
    runOneInstruction: function () {
      var instr = this.instructions[this.pc++];
      instr.instr.execute(this, instr.arg);
    },
    setVariable: function (name, value) {
      if (this.shared[name]) {
        this.callstack[0].variables[name] = value;
      } else {
        this.frame.variables[name] = value;
      }
    },
    getVariable: function (name) {
      var frame;
      if (this.shared[name]) {
        frame = this.callstack[0];
      } else {
        frame = this.frame;
      }

      if (frame.variables[name]) {
        return frame.variables[name];
      } else {
        // must create variable
        var typeName = QBasic.DeriveTypeNameFromVariable(name);
        var type;
        if (typeName === null) {
          type = this.defaultType;
        } else {
          type = this.types[typeName];
        }

        var scalar = new QBasic.ScalarVariable(type, type.createInstance());
        frame.variables[name] = scalar;
        return scalar;
      }
    },
    printStack: function () {
      for (var i = 0; i < this.stack.length; i++) {
        var item = this.stack[i];
        var name = /*getObjectClass*/(item);
        if (name == 'ScalarVariable') {
          name += " " + item.value;
        }
        console.log("TRACE: stack[" + i + "]: " + name);
      }
    },
    pushScalar: function (value, typeName) {
      this.stack.push(new QBasic.ScalarVariable(this.types[typeName], value));
    }
  };

  /**
    Defines the functions that can be called from a BASIC program. Functions
    must return a value. System subs, which do not return a value, are defined
    elsewhere. Some BASIC keywords, such as SCREEN, are both a function and a
    sub, and may do different things in the two contexts.

    Each entry is indexed by function name. The record contains:
      type: The name of the type of the return value of the function.
      args: An array of names of types of each argument.
      minArgs: the number of arguments required.
      action: A function taking the virtual machine as an argument. To implement
        the function, it should pop its arguments off the stack, and push its
        return value onto the stack. If minArgs is not equal to args.length,
        then the top of the stack is an integer variable that indicates how many
        arguments were passed to the function.
  */
  QBasic.SystemFunctions = {
    "RND": {
      type: "SINGLE",
      args: ["INTEGER"],
      minArgs: 0,
      action: function (vm) {
        var numArgs = vm.stack.pop();
        var n = 1;
        if (numArgs == 1) {
          n = vm.stack.pop();
        }
        if (n != 0) {
          vm.lastRandomNumber = Math.random();
        }
        vm.stack.push(vm.lastRandomNumber);
      }
    },
    "CHR$": {
      type: "STRING",
      args: ["INTEGER"],
      minArgs: 1,
      action: function (vm) {
        var num = vm.stack.pop();
        vm.stack.push(String.fromCharCode(num));
      }
    },
    "INKEY$": {
      type: "STRING",
      args: [],
      minArgs: 0,
      action: function(vm) {
        // TODO(max99x): Find out how we can implement this in a REPL context.
        // Here's the original implementation:
        /*
        var code = vm.cons.getKeyFromBuffer();
        var result = "";
        if ( code != -1 ) {
          result = String.fromCharCode(code);
          if ( code === 0 ) {
            result += String.fromCharCode(vm.cons.getKeyFromBuffer());
          }
        }
        vm.stack.push(result);
        */
      }
    },
    "LEN": {
      type: "INTEGER",
      args: ["STRING"],
      minArgs: 1,
      action: function (vm) {
        vm.stack.push(vm.stack.pop().length);
      }
    },
    "MID$": {
      type: "STRING",
      args: ["STRING", "INTEGER", "INTEGER"],
      minArgs: 2,
      action: function (vm) {
        var numArgs = vm.stack.pop();
        var len;
        if (numArgs == 3) {
          len = vm.stack.pop();
        }
        var start = vm.stack.pop();
        var str = vm.stack.pop();
        vm.stack.push(str.substr(start - 1, len));
      }
    },
    "LEFT$": {
      type: "STRING",
      args: ["STRING", "INTEGER"],
      minArgs: 2,
      action: function (vm) {
        var num = vm.stack.pop();
        var str = vm.stack.pop();
        vm.stack.push(str.substr(0, num));
      }
    },
    "RIGHT$": {
      type: "STRING",
      args: ["STRING", "INTEGER"],
      minArgs: 2,
      action: function (vm) {
        var num = vm.stack.pop();
        var str = vm.stack.pop();
        vm.stack.push(str.substr(str.length - num));
      }
    },
    "TIMER": {
      type: "INTEGER",
      args: [],
      minArgs: 0,
      action: function (vm) {
        // return number of seconds since midnight. DEVIATION: We return a
        // floating point value rather than an integer, so that nibbles
        // will work properly when its timing loop returns a value less
        // than one second.
        var date = new Date();
        var result = (date.getMilliseconds() / 1000 +
                      date.getSeconds() + 
                      date.getMinutes() * 60 +
                      date.getHours() * 60 * 60);
        vm.stack.push(result);
      }
    },
    "PEEK": {
      type: "INTEGER",
      args: ["INTEGER"],
      minArgs: 1,
      action: function (vm) {
        // pop one argument off the stack and replace it with 0.
        vm.stack.pop();
        vm.stack.push(0);
      }
    },
    "LCASE$": {
      type: "STRING",
      args: ["STRING"],
      minArgs: 1,
      "action": function (vm) {
        var str = vm.stack.pop();
        vm.stack.push(str.toLowerCase());
      }
    },
    "UCASE$": {
      type: "STRING",
      args: ["STRING"],
      minArgs: 1,
      action: function (vm) {
        vm.stack.push(vm.stack.pop().toUpperCase());
      }
    },
    "STR$": {
      type: "STRING",
      args: ["SINGLE"],
      minArgs: 1,
      action: function (vm) {
        var num = vm.stack.pop();
        vm.stack.push("" + num);
      }
    },
    "SPACE$": {
      type: "STRING",
      args: ["INTEGER"],
      minArgs: 1,
      action: function (vm) {
        var numSpaces = vm.stack.pop();
        var str = "";
        for (var i = 0; i < numSpaces; i++) {
          str += " ";
        }
        vm.stack.push(str);
      }
    },
    "STRING$": {
      type: "STRING",
      args: ["INTEGER", "STRING"],
      minArgs: 2,
      action: function (vm) {
        var chr = vm.stack.pop();
        var numChars = vm.stack.pop();
        var str = "";
        for (var i = 0; i < numChars; i++) {
          str += chr;
        }
        vm.stack.push(str);
      }
    },
    "VAL": {
      type: "SINGLE",
      args: ["STRING"],
      minArgs: 1,
      action: function (vm) {
        vm.stack.push(parseFloat(vm.stack.pop()));
      }
    },
    "INT": {
      type: "INTEGER",
      args: ["SINGLE"],
      minArgs: 1,
      action: function (vm) {
        vm.stack.push(Math.floor(vm.stack.pop()));
      }
    }
  };

  /**
    Defines the system subroutines that can be called from a basic program.
    Subroutines must not return a value. System functions, which return a value,
    are defined elsewhere.

    Each entry is indexed by the name of the subroutine. The record contains:
      args: An array of names of types of each argument.
      minArgs: (optional) the number of arguments required.
      action: A function taking the virtual machine as an argument. To implement
        the function, it should pop its arguments off the stack, and push its
        return value onto the stack. If minArgs is present, and not equal to
        args.length, then the top of the stack is an integer variable that
        indicates how many arguments were passed to the function.
  */
  QBasic.SystemSubroutines = {
    "RANDOMIZE": {
      args: ["INTEGER"],
      minArgs: 0,
      action: function (vm) {
        // Uses the injected Mersenne Twister randomizer.
        var argCount = vm.stack.pop();
        if (argCount == 0) {
          Math.seed();
        } else if (argCount == 1) {
          Math.seed(vm.stack.pop().value);
        } else {
          throw new Error("RANDOMIZE takes at most 1 argument.");
        }
      }
    },
    "CLS": {
      action: function (vm) {
        // TODO(max99x): Implement.
      }
    },
    BEEP: {
      "action": function (vm) {
        // TODO(max99x): Implement.
      }
    },
    "PLAY": {
      args: ["STRING"],
      action: function (vm) {
        // TODO(max99x): Implement.
        vm.stack.pop();
      }
    },
    "SLEEP": {
      args: ["INTEGER"],
      action: function (vm) {
        // TODO(max99x): Implement.
        vm.stack.pop();
      }
    },
    "SYSTEM": {
      args: ["INTEGER"],
      action: function (vm) {
        // TODO(max99x): Implement.
        vm.stack.pop();
      }
    },
    // TODO(max99x): Move this out of system calls and merge with print_*.
    "__print_using": {
      action: function (vm) {
        // pop # args
        var argCount = vm.stack.pop();

        // pop terminator
        var terminator = vm.stack.pop();

        var args = [];
        for (var i = 0; i < argCount - 1; i++) {
          args.unshift(vm.stack.pop());
        }

        var formatString = args.shift().value;

        var curArg = 0;
        var output = "";

        // for each character in the string,
        for (var pos = 0; pos < formatString.length; pos++) {
          var ch = formatString.charAt(pos);

          // if the character is '#',
          if (ch === '#') {
            // if out of arguments, then type mismatch error.
            if (curArg === args.length ||
                !QBasic.IsNumericType(args[curArg].type)) {
              // TODO(max99x): Handle errors.
              throw new Error("Type mismatch error.");
              break;
            }

            // store character position
            var backup_pos = pos;
            var digitCount = 0;
            // for each character of the string,
            for (; pos < formatString.length; pos++) {
              ch = formatString.charAt(pos);
              if (ch === '#') {
                // if the character is '#', increase digit count
                digitCount++;
              } else if (ch === ',') {
                // if the character is ',' do nothing
              } else {
                // break out of loop
                break;
              }
            }

            // convert current arg to a string. Truncate or pad to
            // appropriate number of digits.
            var argAsString = "" + args[curArg].value;
            if (argAsString.length > digitCount) {
              argAsString = argAsString.substr(argAsString.length - digitCount);
            } else {
              while (argAsString.length < digitCount) {
                argAsString = " " + argAsString;
              }
            }

            var curDigit = 0;

            // go back to old character position.
            // for each character of the string,
            for (pos = backup_pos; pos < formatString.length; pos++) {
              ch = formatString.charAt(pos);
              // if the character is a '#'
              if (ch === '#') {
                // output the next digit.
                output += argAsString[curDigit++];
                // if the character is a ',',
              } else if (ch === ',') {
                // output a comma.
                output += ch;
              } else {
                // break out.
                break;
              }
            }

            // increment current argument.
            curArg += 1;
            pos -= 1;
          } else {
            // character was not #. output it verbatim.
            output += ch;
          }
        }
        vm.cons.print(output);
        if (terminator === ',') {
          // This should really align the cursor to the next 14-space boundary
          // but that is not possible with the current API.
          vm.cons.print('\t');
        } else if (terminator !== ';') {
          vm.cons.print("\n");
        }
      }
    },
    "LOCATE": {
      args: ["INTEGER", "INTEGER"],
      action: function (vm) {
        // TODO(max99x): Implement - move cursor.
        vm.stack.pop();
        vm.stack.pop();
      }
    },
    "COLOR": {
      args: ["ANY", "ANY"],
      minArgs: 1,
      action: function (vm) {
        // TODO(max99x): Implement - set background and foreground color.
        vm.stack.pop();
        vm.stack.pop();
      }
    },
    "READ": {
      // Actually, arguments must be STRING or NUMBER, but there is no way to
      // indicate that to the type checker at the moment.
      args: ["ANY", "ANY"],
      minArgs: 1,
      action: function (vm) {
        var argCount = vm.stack.pop();
        var args = [];
        var i;

        for (i = 0; i < argCount; i++) {
          args.unshift(vm.stack.pop());
        }

        // TODO(max99x): Handle out of data error.
        for (i = 0; i < argCount; i++) {
          if (vm.debug) console.log("READ " + vm.data[vm.dataPtr]);
          args[i].value = vm.data[vm.dataPtr++];
          if (args[i].value === null) {
            // user specified ,, in a data statement
            args[i].value = args[i].type.createInstance();
          }
        }
      }
    },
    "SCREEN": {
      action: function (vm) {
        // TODO(max99x): Implement.
        vm.stack.pop();
      }
    },
    "INPUT": {
      action: function (vm) {
        var argCount = vm.stack.pop();
        var args = [];

        for (var i = 0; i < argCount; i++) {
          args.unshift(vm.stack.pop());
        }

        vm.suspend();

        var curArg = 0;
        var callback = function(result) {
          var parts = result.split(/\s*,\s*/);
          for (var i = 0; i < parts.length; i++) {
            var value = parts[i];
            // TODO(max99x): Verify conversion strictness.
            switch (args[curArg].type.name) {
            case 'INTEGER':
            case 'LONG':
              value = parseInt(value, 10) || value;
              break;
            case 'DOUBLE':
            case 'SINGLE':
              value = parseFloat(value) || value;
              break;
            }
            args[curArg++].value = value;
          }
          if (curArg < argCount) {
            vm.cons.input(callback);
          } else {
            vm.resume();
          }
        }
        vm.cons.input(callback);
      }
    },
    "SWAP": {
      action: function (vm) {
        var lhs = vm.stack.pop();
        var rhs = vm.stack.pop();
        var temp = lhs.value;
        lhs.value = rhs.value;
        rhs.value = temp;
        // TODO(max99x): Type checking.
      }
    },
    "WIDTH": {
      args: ["ANY", "ANY"],
      action: function (vm) {
        // TODO(max99x): Implement or remove.
        vm.stack.pop();
        vm.stack.pop();
      }
    }
  };

  /**
    Defines the instruction set of the virtual machine. Each entry is indexed by
    the name of the instruction, and consists of the following fields:
      name: The name of the instruction for display purposes.
      addrLabel: If present, and set to "true", the argument of the instruction
        is interpretted as an address during the linking stage.
      dataLabel: If present, and set to "true", the argument of the instruction
        is the index of a DATA statement.
      numArgs: If present and set to 0, the instruction takes no arguments.
        Otherwise, it is assumed to take 1 argument.
      execute: A function taking as its first argument the virtual machine, and
        as its second argument the parameter of the instruction. It should
        manipulate the virtual machine's stack or program counter to implement
        the instruction.
  */
  QBasic.Instructions = {
    FORLOOP: {
      name: "forloop",
      addrLabel: true,
      execute: function (vm, arg) {
        /**
          For loops are tedious to implement in bytecode, because depending on
          whether STEP is positive or negative we either compare the counter
          with < or >. To simplify things, we create the forloop instruction to
          perform this comparison.
            argument is the address of the end of the for loop.
            stack is:
              end value
              step expression
              loop variable REFERENCE
          If the for loop is ended, then all three of its arguments are popped
          off the stack, and we jump to the end address. Otherwise, only the
          loop variable is popped and no branch is performed.
        */
        var counter = vm.stack[vm.stack.length - 1];
        var step = vm.stack[vm.stack.length - 2];
        var end = vm.stack[vm.stack.length - 3];

        if (step < 0 && counter < end || step > 0 && counter > end) {
          vm.stack.length -= 3;
          vm.pc = arg;
        } else {
          vm.stack.pop();
        }
      }
    },
    COPYTOP: {
      name: "copytop",
      numArgs: 0,
      execute: function (vm, arg) {
        // Duplicates the top of the stack
        vm.stack.push(vm.stack[vm.stack.length - 1]);
      }
    },
    RESTORE: {
      name: "restore",
      dataLabel: true,
      execute: function (vm, arg) {
        // Restore the data pointer to the given value.
        if (vm.debug) console.log("TRACE: RESTORE to " + arg);
        vm.dataPtr = arg;
      }
    },
    POPVAL: {
      name: "popval",
      execute: function (vm, arg) {
        // Argument is the name of the variable. Sets that variable's value
        // to the top of the stack.
        vm.getVariable(arg).value = vm.stack.pop();
      }
    },
    POP: {
      name: "pop",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.pop();
      }
    },
    PUSHREF: {
      name: "pushref",
      execute: function (vm, arg) {
        // The argument is the name of a variable. Push a reference to that
        // variable onto the top of the stack.
        vm.stack.push(vm.getVariable(arg));
      }
    },
    PUSHVALUE: {
      name: "pushvalue",
      execute: function (vm, arg) {
        // The argument is the name of a variable. Push the value of that
        // variable to the top of the stack.
        vm.stack.push(vm.getVariable(arg).value);
      }
    },
    PUSHTYPE: {
      name: "pushtype",
      execute: function (vm, arg) {
        // The argument is the name of a built-in or user defined type.
        // Push the type object onto the stack, for later use in an alloc
        // system call.
        vm.stack.push(vm.types[arg]);
      }
    },
    POPVAR: {
      name: "popvar",
      execute: function (vm, arg) {
        // Sets the given variable to refer to the top of the stack, and
        // pops the top of the stack. The stack top must be a reference.
        vm.setVariable(arg, vm.stack.pop());
      }
    },
    NEW: {
      name: "new",
      execute: function (vm, arg) {
        // The argument is a typename. Replace the top of the stack with a
        // reference to that value, with the given type.
        var type = vm.types[arg];
        vm.stack.push(new QBasic.ScalarVariable(type, type.copy(vm.stack.pop())));
      }
    },
    END: {
      name: "end",
      numArgs: 0,
      execute: function (vm, arg) {
        // End the program. The CPU ends the program when the program counter
        // reaches the end of the instructions, so make that happen now.
        vm.pc = vm.instructions.length;
      }
    },
    UNARY_OP: {
      name: "unary_op",
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var value;
        if (arg == 'NOT') {
          value = ~rhs;
        } else if (arg == '-') {
          value = -rhs;
        } else {
          throw new Error("No such unary operator: " + arg);
        }

        vm.stack.push(value);
      }
    },
    "=": {
      name: "=",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.push(vm.stack.pop() === vm.stack.pop() ? -1 : 0);
      }
    },
    // Special addition to allow comparison in REPL expression context.
    "==": {
      name: "==",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.push(vm.stack.pop() === vm.stack.pop() ? -1 : 0);
      }
    },
    "<": {
      name: "<",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        vm.stack.push(lhs < rhs ? -1 : 0);
      }
    },
    "<=": {
      name: "<=",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        vm.stack.push(lhs <= rhs ? -1 : 0);
      }
    },
    ">": {
      name: ">",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        vm.stack.push(lhs > rhs ? -1 : 0);
      }
    },
    ">=": {
      name: ">=",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        vm.stack.push(lhs >= rhs ? -1 : 0);
      }
    },
    "<>": {
      name: "<>",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.push(vm.stack.pop() !== vm.stack.pop() ? -1 : 0);
      }
    },
    "AND": {
      name: "and",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.push(vm.stack.pop() & vm.stack.pop());
      }
    },
    "OR": {
      name: "or",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.push(vm.stack.pop() | vm.stack.pop());
      }
    },
    "XOR": {
      name: "xor",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.push(vm.stack.pop() ^ vm.stack.pop());
      }
    },
    "+": {
      name: "+",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        vm.stack.push(lhs + rhs);
      }
    },
    "-": {
      name: "-",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        vm.stack.push(lhs - rhs);
      }
    },
    "*": {
      name: "*",
      numArgs: 0,
      execute: function (vm, arg) {
        vm.stack.push(vm.stack.pop() * vm.stack.pop());
      }
    },
    "/": {
      name: "/",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        if (rhs == 0) {
          throw new Error("Division by zero.");
        }
        vm.stack.push(lhs / rhs);
      }
    },
    "\\": {
      name: "\\",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        if (rhs == 0) {
          throw new Error("Division by zero.");
        }
        vm.stack.push(Math.floor(lhs / rhs));
      }
    },
    "^": {
      name: "^",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        vm.stack.push(Math.pow(lhs, rhs));
      }
    },
    "MOD": {
      name: "mod",
      numArgs: 0,
      execute: function (vm, arg) {
        var rhs = vm.stack.pop();
        var lhs = vm.stack.pop();
        if (rhs == 0) {
          throw new Error("Modulus by zero.");
        }
        vm.stack.push(lhs % rhs);
      }
    },
    BZ: {
      name: "bz",
      addrLabel: true,
      execute: function (vm, arg) {
        // Branch on zero. Pop the top of the stack. If zero, jump to
        // the given address.
        var expr = vm.stack.pop();
        if (!expr) {
          vm.pc = arg;
        }
      }
    },
    BNZ: {
      name: "bnz",
      addrLabel: true,
      execute: function (vm, arg) {
        // Branch on non-zero. Pop the top of the stack. If non-zero, jump
        // to the given address.
        var expr = vm.stack.pop();
        if (expr) {
          vm.pc = arg;
        }
      }
    },
    JMP: {
      name: "jmp",
      addrLabel: true,
      execute: function (vm, arg) {
        // Jump to the given address.
        vm.pc = arg;
      }
    },
    CALL: {
      name: "call",
      addrLabel: true,
      execute: function (vm, arg) {
        // Call a function or subroutine. This creates a new stackframe
        // with no variables defined.
        vm.frame = new StackFrame(vm.pc);
        vm.callstack.push(vm.frame);
        vm.pc = arg;
      }
    },
    GOSUB: {
      name: "gosub",
      addrLabel: true,
      execute: function (vm, arg) {
        // like call, but stack frame shares all variables from the old
        // stack frame.
        var oldvariables = vm.frame.variables;
        vm.frame = new StackFrame(vm.pc);
        vm.frame.variables = oldvariables;
        vm.callstack.push(vm.frame);
        vm.pc = arg;
      }
    },
    RET: {
      name: "ret",
      numArgs: 0,
      execute: function (vm, arg) {
        // Return from a gosub, function, or subroutine call.
        vm.pc = vm.callstack.pop().pc;
        vm.frame = vm.callstack[vm.callstack.length - 1];
      }
    },
    PUSHCONST: {
      name: "pushconst",
      execute: function (vm, arg) {
        // Push a constant value onto the stack. The argument is a
        // javascript string or number.
        vm.stack.push(arg);
      }
    },
    ARRAY_DEREF: {
      name: "array_deref",
      numArgs: 1,
      execute: function (vm, arg) {
        // Dereference an array. The top of the stack is the variable
        // reference, followed by an integer for each dimension.
        // Argument is whether we want the reference or value.
        // get the variable
        var variable = vm.stack.pop();

        var indexes = [];

        // for each dimension,
        for (var i = 0; i < variable.dimensions.length; i++) {
          // pop it off the stack in reverse order.
          indexes.unshift(vm.stack.pop());
        }

        // TODO: bounds checking.
        if (arg) {
          vm.stack.push(variable.access(indexes));
        } else {
          vm.stack.push(variable.access(indexes).value);
        }
      }
    },
    MEMBER_DEREF: {
      name: "member_deref",
      execute: function (vm, arg) {
        // Dereference a user defined type member.
        // Argument is the javascript string containing the name of the
        // member. The top of the stack is a reference to the user
        // variable.
        var userVariable = vm.stack.pop();
        var deref = userVariable[arg];

        vm.stack.push(deref);
      }
    },
    MEMBER_VALUE: {
      name: "member_value",
      execute: function (vm, arg) {
        // Dereference a user defined type member.
        // Argument is the javascript string containing the name of the
        // member. The top of the stack is a reference to the user
        // variable.
        var userVariable = vm.stack.pop();
        var deref = userVariable[arg];

        vm.stack.push(deref.value);
      }
    },
    ASSIGN: {
      name: "assign",
      numArgs: 0,
      execute: function (vm, arg) {
        // Copy the value into the variable reference.
        // Stack: left hand side: variable reference
        // right hand side: value to assign.
        var lhs = vm.stack.pop();
        var rhs = vm.stack.pop();

        lhs.value = lhs.type.copy(rhs);
      }
    },
    SYSCALL: {
      name: "syscall",
      execute: function (vm, arg) {
        // Execute a system function or subroutine. The argument is a
        // javascript string containing the name of the routine.
        if (vm.debug) console.log("TRACE: Execute syscall " + arg);
        if (arg == "print") {
          vm.cons.print(vm.stack.pop().toString());
        } else if (arg == 'alloc_array') {
          var type = vm.stack.pop();
          var numDimensions = vm.stack.pop();
          var dimensions = [];
          for (var i = 0; i < numDimensions; i++) {
            var upper = vm.stack.pop();
            var lower = vm.stack.pop();
            dimensions.unshift(new QBasic.Dimension(lower, upper));
          }

          var variable = new QBasic.ArrayVariable(type, dimensions);
          vm.stack.push(variable);
        } else if (arg == 'print_comma') {
          // This should really align the cursor to the next 14-space boundary
          // but that is not possible with the current API.
          vm.cons.print('\t');
        } else if (arg == 'print_tab') {
          // This should really align the cursor to the column given in the
          // argument but that is not possible with the current API.
          var col = vm.stack.pop();
          // Creates a string of (col - 1) spaces.
          var spaces = (new Array(col)).join(' ');
          vm.cons.print(spaces);
        } else if (arg == 'alloc_scalar') {
          var type = vm.stack.pop();
          var variable = new QBasic.ScalarVariable(type, type.createInstance());
          vm.stack.push(variable);
        } else if (QBasic.SystemFunctions[arg]) {
          QBasic.SystemFunctions[arg].action(vm);
        } else if (QBasic.SystemSubroutines[arg]) {
          QBasic.SystemSubroutines[arg].action(vm);
        } else {
          vm.cons.print("Unknown syscall: " + arg);
        }
      }
    }
  };
})();
